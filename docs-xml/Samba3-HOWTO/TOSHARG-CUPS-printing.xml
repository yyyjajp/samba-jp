<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="CUPS-printing">

<chapterinfo>

	<author>
		<firstname>Kurt</firstname><surname>Pfeifle</surname>
		<affiliation>
			<orgname>Danka Deutschland GmbH </orgname>
                        <address><email>kpfeifle@danka.de</email></address>
		</affiliation>
	</author>
	<author>
		<firstname>Ciprian</firstname><surname>Vizitiu</surname>
		<affiliation>
			<address><email>CVizitiu@gbif.org</email></address>
		</affiliation>
		<contrib>drawings</contrib>
	</author>

	<author>&person.jelmer;<contrib>drawings</contrib></author>

	<pubdate> (27 Jan 2004) </pubdate>
</chapterinfo>

<title>CUPS印刷環境のサポート</title>

<sect1>

	<title>概要</title>

	<sect2>
		<title>機能と利便性</title>

		<para>
<indexterm><primary>既定値の印刷環境</primary></indexterm>
		共通UNIX印刷システム(<ulink url="http://www.cups.org/">CUPS</ulink>)は
		現在非常に一般的になってきている。すべての主要なLinuxディストリビューションは
		現在既定値の印刷システムとしてこれと導入している。ただ、残念ながら、これは
		まだ非常に取っつきづらいツールである。ほとんどの場合、これはちゃんと動く。
		多くの人は、これが動いている間は、その中身を覗きたくなく、それを
		<quote>ブラックボックス</quote>として扱う傾向がある。しかし、ひとたび
		小さな問題が発生すると、どこからデバッグしていいかということを見つける
		困難が生じる。CUPSに関連したより多量の情報もある、
		<link linkend="classicalprinting">旧式の印刷サポート</link>も参照のこと。
		</para>

		<para>
<indexterm><primary>CUPS</primary></indexterm>
		CUPSは固有で強力な機能を持っている。その基本機能は容易に把握でき、
		かつそれらは新しい。これは他のものと違い、より現代的な印刷システムであり、
		この新しいシステムで印刷することに関する以前の知識を適用しないことが最も良い。
		むしろ、最初からCUPSを理解することをすべきである。この文書はCUPSの完全な理解
		を手助けする。まず基本的な点から最初に始めよう。
		</para>

	</sect2>

	<sect2>
	<title>Overview</title>

	<para>
<indexterm><primary>印刷スプールシステム</primary></indexterm>
<indexterm><primary>CUPS</primary></indexterm>
<indexterm><primary>印刷管理システム</primary></indexterm>
<indexterm><primary>IETF</primary></indexterm>
<indexterm><primary>Internet Printing Protocol</primary><see>IPP</see></indexterm>
<indexterm><primary>Internet Engineering Task Force</primary><see>IETF</see></indexterm>
<indexterm><primary>GUI</primary></indexterm>
<indexterm><primary>KDEPrint</primary></indexterm>
	CUPSは印刷スプールシステムというもの以上である。これは、新しいインターネット印刷
	プロトコル(IPP)に従う完全な印刷管理システムである。IPPは産業製品であり、
	ネットワーク印刷に関するInternet Engineering Task Force (IETF)標準である。
	この機能の多くはWebブラウザ(CUPS印刷サーバにアクセスするプラットフォーム非依存の
	アクセスを提供する)経由でリモート(またはローカル)から管理することが出来る。さらに
	追加で、伝統的なコマンド行といくつかのより新しいGUIインタフェースを持っている
	(GUIインタフェースはサードパーティによって開発され、たとえば、KDEのoverwhelming
	<ulink url="http://printing.kde.org/">KDEPrint</ulink>などである)。
	</para>

	<para>
<indexterm><primary>raw printers</primary></indexterm>
<indexterm><primary>smart printers</primary></indexterm>
	CUPSは、<emphasis>smart</emphasis>プリンタ(すなわち、CUPSがプリンタに対して要求
	された時にファイル形式の変換を行う)と同じように、<emphasis>raw</emphasis>プリンタ
	すなわち、印刷ファイル形式を変換しない)の作成が出来る。多くの手段で、Microsoft Windows
	印刷関しシステム同じような機能がCUPSにはある。もちろん、CUPSの推進者ならば、
	CUPSの方がもっと良いと言うだろう!多くの場合、Samba経由でMicrosoft Windows印刷
	クライアントとの間でCUPSがインタフェースを取るための設定方法を説明しよう。
	</para>

	</sect2>

</sect1>

<sect1>
	<title>基本的なCUPSサポート設定</title>

	<para>
<indexterm><primary>CUPS</primary></indexterm>
<indexterm><primary>cupsd.conf</primary></indexterm>
<indexterm><primary>/etc/printcap</primary></indexterm>
<indexterm><primary>Printcap</primary></indexterm>
<indexterm><primary>PrintcapFormat</primary></indexterm>
Samba-3.0(2.2.xから使える)でのCUPSを使った印刷環境の、最も基本的な&smb.conf;のセットアップは
<smbconfoption name="printing">cups</smbconfoption>と
<smbconfoption name="printcap">cups</smbconfoption>という2つのパラメータを必要とする。
CUPSはprintcapファイルを必要としない。しかし、<filename>cupsd.conf</filename>設定ファイルは、
サードパーティアプリケーション(例えば<parameter>Printcap /etc/printcap</parameter>と
<parameter>PrintcapFormat BSD</parameter>)に便利なように、どのように、CUPSによって
自動的に作成され、管理されるファイルを制御する2つの関連するディレクトリを知っている。
旧式のプログラムはしばしばprintcapファイルに含まれているプリンタ名が存在することを
要求するので、そうでないと印刷を拒否してしまう。CUPSがprintcapファイルを作成して管理する
ようにしておくこと。詳細は、<command>man cupsd.conf</command>と、
<ulink noescape="1" url="http://localhost:631/documentation.html">CUPS</ulink>
Webサイトにある、CUPSサーバそれ自身が提供する、関連する貴重な文書のようなCUPS関連の
文書を参照のこと。
	</para>

	<sect2>
	<title>libcups.soを使ったsmbdとのリンク</title>

	<para>
<indexterm><primary>libcups.so</primary></indexterm>
	SambaはCUPSと特別な関係がある。SambaはCUPSライブラリサポート機能を有効にして
	コンパイルできる。最も最新のバージョンでは、このサポートを有効にしている。
	既定値では、CUPSはsmbdとその他のSambaバイナリにリンクされる。もちろん、
	<filename>libcups.so</filename>をSambaにリンクしなくてもCUPSを使う事が
	できるが、要求されるあるいはサポートされる設定にいくつかの違いがある。
	</para>

	<para>
<indexterm><primary>libcups</primary></indexterm>
<indexterm><primary>ldd</primary></indexterm>
	Sambaが<filename>libcups</filename>とリンクされ、コンパイルされた時、
	<smbconfoption name="printcap">cups</smbconfoption>は、プリンタ一覧の表示、
	ジョブの投稿、キューの問い合わせなどにCUPS APIを使う。それ以外は、印刷のために、
	これらの操作を、<command>-oraw</command>オプションを付加して、System Vの
	コマンドにマップする。Linuxシステムでは、smbdが、libcupsライブラリにリンク
	されているかを、<command>ldd</command>ユーティリティを使う事で知ることが出来る
	(<command>ldd</command>は他のOSプラットフォーム上には無いかもしれないか、
	その機能は別のコマンドによって行われるかもしれない):
<screen>
&rootprompt;<userinput>ldd `which smbd`</userinput>
libssl.so.0.9.6 =&gt; /usr/lib/libssl.so.0.9.6 (0x4002d000)
libcrypto.so.0.9.6 =&gt; /usr/lib/libcrypto.so.0.9.6 (0x4005a000)
libcups.so.2 =&gt; /usr/lib/libcups.so.2 (0x40123000)
[....]
</screen>
	</para>

	<para>
<indexterm><primary>libcups.so.2</primary></indexterm>
	<computeroutput>libcups.so.2 =&gt; /usr/lib/libcups.so.2 (0x40123000)</computeroutput>
	行は、このバージョンのSambaがCUPSサポートするようにコンパイルされていることを
	示している。もしもこの場合で、printing = cupsが設定されている場合、
	<emphasis>他の&smb.conf;中にある、手動で設定した印刷関係のコマンドは無視される</emphasis>。
	これは重要な点なので覚えておくこと!
	</para>

	<tip><para>何らかの理由で、固有の印刷コマンドを設定するために、
	<smbconfoption name="printing">sysv</smbconfoption>を設定することにより、これを行える
	ようにする事が必要である。しかし、CUPSとSambaを密に統合する利便性のすべてを
	失うことになる。これを行う場合、以下のように、印刷システムコマンドを手動で設定しなければ
	ならない。
	(最も重要: 
	<smbconfoption name="print command"/>; other commands are
	<smbconfoption name="lppause command"/>,
	<smbconfoption name="lpresume command"/>,
	<smbconfoption name="lpq command"/>,
	<smbconfoption name="lprm command"/>,
	<smbconfoption name="queuepause command"/> and
	<smbconfoption name="queue resume command"/>).
	</para></tip>

	</sect2>

	<sect2>
	<title>CUPSを使う簡単な&smb.conf;の設定</title>

	<para>
	<link linkend="cups-exam-simple">最も簡単な印刷関連の&smb.conf;ファイル</link>
	に、基本的なCUPSサポートを有効にする、最も簡単な印刷関連の&smb.conf;設定を
	要約する:
	</para>

	<example id="cups-exam-simple">
	<title>最も簡単な印刷関連のsmb.confファイル</title>
	<smbconfblock>
	<smbconfsection name="[global]"/>
	<smbconfoption name="load printers">yes</smbconfoption>
	<smbconfoption name="printing">cups</smbconfoption>
	<smbconfoption name="printcap name">cups</smbconfoption>

	<smbconfsection name="[printers]"/>
	<smbconfoption name="comment">All Printers</smbconfoption>
	<smbconfoption name="path">/var/spool/samba</smbconfoption>
	<smbconfoption name="browseable">no</smbconfoption>
	<smbconfoption name="guest ok">yes</smbconfoption>
	<smbconfoption name="writable">no</smbconfoption>
	<smbconfoption name="printable">yes</smbconfoption>
	<smbconfoption name="printer admin">root, @ntadmins, @smbprintadm</smbconfoption>
	</smbconfblock>
	</example>

	<para>
<indexterm><primary>PDF</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>プリンタドライバ</primary></indexterm>
	これはCUPSに対する基本的な印刷設定に必要なもののすべてである。Windowsクライアント
	から投稿されたすべてのグラフィック、PDFとPostscriptファイルは印刷できる。
	しかし、ほとんどのWindowsユーザは、GUIアプリケーションを開かないで、印刷する
	ファイルの種類を送る方法を知らない。Windowsクライアントはインストールされた
	ローカルのプリンタドライバを持つ傾向があり、GUIアプリケーションの印刷ボタンは、
	プリンタドライバを開始する。ユーザは滅多にコマンド行からファイルを送らない。
	UNIXクライアントとは違い、グラフィック、テキストあるいはPDFファイルを直接
	スプーラに送らない。通常、アプリケーションのネイティブな形式と印刷データ
	ストリームの間でホックされた<quote>printer driver</quote>を使うGUI
	アプリケーションから排他的に印刷を行う。もしもバックエンドプリンタが
	Postscriptデバイスでない場合、印刷データストリームは<quote>バイナリ</quote>で、
	対象のプリンタのみが対象である。この問題が引き起こすこととそれを防ぐことを
	学ぶために、この先を読み続けること。
	</para>

	</sect2>

	<sect2>
	<title>より複雑なCUPS &smb.conf;設定</title>

	<para>
	<link linkend="overridesettings">1台のプリンタ用にグローバルなCUPS設定を上書きする例</link> 
	は、&smb.conf;用の、やや複雑な印刷関連設定である。これはすべてのプリンタに対して
	一般的なCUPS印刷サポートを有効にするが、1台だけ設定が異なるプリンタ共有を定義する。
	</para>

	<example id="overridesettings">
	<title>1台のプリンタ用にグローバルなCUPS設定を上書きする</title>
	<smbconfblock>
	<smbconfsection name="[global]"/>
	<smbconfoption name="printing">cups</smbconfoption>
	<smbconfoption name="printcap name">cups</smbconfoption>
	<smbconfoption name="load printers">yes</smbconfoption>

	<smbconfsection name="[printers]"/>
	<smbconfoption name="comment">All Printers</smbconfoption>
	<smbconfoption name="path">/var/spool/samba</smbconfoption>
	<smbconfoption name="guest ok">yes</smbconfoption>
	<smbconfoption name="writable">no</smbconfoption>
	<smbconfoption name="printable">yes</smbconfoption>
	<smbconfoption name="printer admin">root, @ntadmins, @smbprintadm</smbconfoption>

	<smbconfsection name="[special_printer]"/>
	<smbconfoption name="comment">A special printer with his own settings</smbconfoption>
	<smbconfoption name="path">/var/spool/samba-special</smbconfoption>
	<smbconfoption name="printing">sysv</smbconfoption>
	<smbconfoption name="printcap">lpstat</smbconfoption>
	<smbconfoption name="print command">echo "NEW: `date`: printfile %f" >> /tmp/smbprn.log ; echo "     `date`: p-%p s-%s f-%f" >> /tmp/smbprn.log ; echo "     `date`: j-%j J-%J z-%z c-%c" >> /tmp/smbprn.log ; rm %f </smbconfoption>
	<smbconfoption name="guest ok">no</smbconfoption>
	<smbconfoption name="writable">no</smbconfoption>
	<smbconfoption name="printable">yes</smbconfoption>
	<smbconfoption name="printer admin">kurt</smbconfoption>
	<smbconfoption name="hosts deny">0.0.0.0</smbconfoption>
	<smbconfoption name="hosts allow">turbo_xp, 10.160.50.23, 10.160.51.60</smbconfoption>
	</smbconfblock>
	</example>

	<para>
	この特別な共有は、テスト目的専用である。これは印刷ジョブをファイルに書かない。
	これは、ジョブパラメータをSambaが認識する<filename>/tmp/smbprn.log</filename>
	ファイルに記録し、ジョブファイルを削除する。さらに、この共有の
	<smbconfoption name="printer admin"/>は<quote>kurt</quote>で
	(<quote>@ntadmins</quote>グループではなくて)、ゲストアクセスは許可されず、共有は
	ネットワークコンピュータに公開されず(そのため、これが共有であることを知っておく
	必要がある)、3つのホストのみからアクセスできる。その共有に対して、CUPSが起動し、
	印刷ジョブ上で通信をすることを防ぐために、
	<smbconfoption name="printing">sysv</smbconfoption>と
	<smbconfoption name="printcap">lpstat</smbconfoption>を設定する必要がある。
	</para>

	</sect2>

</sect1>

<sect1>
	<title>高度な設定</title>

	<para>
	すべての設定オプションを確認する前に、いくつかの点について明確にする。
	<emphasis>ネットワーク印刷は、きちんと計画されて、正しくセットアップされている
	必要がある</emphasis>。このことは頻繁には発生しない。旧来のシステムや
	小さな業務用LAN環境では、しばしばデザインと良い保守が存在していない。
	</para>


	<sect2>
	<title>集中スプール対<quote>ピアツーピア</quote>印刷</title>


	<para>
<indexterm><primary>スプーリング</primary></indexterm>
	<indexterm><primary>スプーリング</primary><secondary>集中</secondary></indexterm>
	<indexterm><primary>スプーリング</primary><secondary>ピアツーピア</secondary></indexterm>
	多くの小規模オフィスや家庭用ネットワークでは、計画がひどい、より大きな環境と
	同じように、各クライアントがネットワークプリンタへ直接アクセス出来るように
	なっている。これは一般的には悪いアイデアである。他のクライアントのジョブが
	印刷しているときに、あるクライアントのアクセスを頻繁にブロックしてしまう。
	ジョブが終了するのを待っている間、最初のクライアントのアプリケーションは
	フリーズしてしまうかもしれない。同様に、数多くのジョブが印刷しているとき、
	それぞれが異なったページをまぜこぜにしてしまうという苦情もしばしば聞く。
	よりよいコンセプトは、プリントサーバを使うことである。これは、すべてのジョブを
	集中したシステムに一本化し、即時に反応し、複数の並列したクライアントから
	ジョブを受け取り、正しい順序でプリンタに転送する。
	</para>

	</sect2>

	<sect2>
	<title>直接印刷機能:Windowsクライアント上のベンダドライバ</title>

	<para>
	<indexterm><primary>スプールのみ</primary></indexterm>
	<indexterm><primary>直接印刷</primary></indexterm>
	ほとんどの現代的に設定されたUNIX印刷サーバは、本当に単純なセットアップを意味する、
	SambaのWindowsクライアントのために振る舞う。それらの唯一の業務は、Sambaによって
	すべてのジョブが扱われる<quote>直接</quote>スプーリングを管理することである。
	この試みは、Windowsクライアントが、印刷デバイスに送られる準備が出来た印刷ジョブ
	ファイルを準備することが期待されるということである。この場合、ネイティブな
	(ベンダが供給した)Windowsプリンタドライバは、各、およびすべてのクライアントで、
	対象デバイスのものをインストールする必要がある。
	</para>

	<para>
<indexterm><primary>render</primary></indexterm>
<indexterm><primary>ベンダが提供したドライバ</primary></indexterm>
	同様に現代的な、簡単な方法で、CUPS、SambaとWindowsクライアントを設定することは
	可能である。CUPSプリンタが直接印刷モード状態で設定されているならば、完全に
	印刷ジョブ(ファイル)を描画することは、Sambaクライアントの責任である。ファイルは
	プリンタに直接配信するのに適した形式で送られる必要がある。クライアントはこれを
	行うために、ベンダが提供したドライバを動作させる必要がある。この場合、CUPSは
	何ら印刷ファイル形式変換を行わない。
	</para>

	<para>
	可能な、最も簡単な印刷設定は、直接印刷(raw print-through)である。これは、
	Windowsクライアントに物理的に結合されているようにプリンタをインストールする
	事によって行える。次に、それをrawネットワーク印刷キューにリダイレクトする。
	この手続きは、以下の手順によって行えるだろう:
	</para>

	<procedure>
	<title>直接CUPS印刷サポートのための設定手順</title>

		<step><para>
<indexterm><primary>/etc/cups/mime.types</primary></indexterm>
		<filename>/etc/cups/mime.types</filename>の、ファイルの最後あたりにある
		下記の行のコメントを外す: 
<screen>
#application/octet-...
</screen>
		</para></step>

		<step><para>
<indexterm><primary>/etc/cups/mime.convs</primary></indexterm>
		<filename>/etc/cups/mime.convs</filename>に対しても同様に行う。
		</para></step>

		<step><para>
		Webインタフェースを使ってrawプリンタを追加する。ブラウザで
		<constant>http://localhost:631</constant>をクリックする。
		Administrationに入り、プロンプトに従ってプリンタを追加する。
		ドライバをこれにインストールしてはならない。Rawを選択する。
		<constant>Raw Queue</constant>というキュー名を選択する。
		</para></step>

		<step><para>
		&smb.conf;ファイル中の<constant>[printers]</constant>セクションに
		<smbconfoption name="use client driver">Yes</smbconfoption>を追加し、
		<constant>[global]</constant>セクション中に、
		<smbconfoption name="printing">CUPS</smbconfoption>と
		<smbconfoption name="printcap">CUPS</smbconfoption>を追加する。
		</para></step>

		<step><para>
		ローカルプリンタのようにプリンタをインストールし、結果、印刷先が
		<constant>LPT1:</constant>となる。
		</para></step>

		<step><para>
		<guimenu>Detail</guimenu>タブ下の設定を編集し、上記で設定したrawプリンタ
		キューを指し示す<constant>local port</constant>を作成する。例:
		<constant>\\server\raw_q</constant>。ここで、<constant>raw_q</constant>
		という名前はCUPS環境中で印刷キューに割り当てた名前である。
		</para></step>
	</procedure>

	</sect2>

	<sect2>
	<title>Windowsクライアントドライバのインストール</title>

	<para>
	Windowsクライアント上のプリンタドライバは2つの機能的に異なった方法でインストール
	できる:
	</para>

	<itemizedlist>
	<listitem><para>手動で各クライアント上にドライバを1つずつインストールする。
	これは旧式のLanMan形式印刷環境を必要とし、
	<filename>\\sambaserver\printershare</filename>タイプの接続を使う。
	</para></listitem>


	<listitem><para>
	<indexterm><primary>ポイントアンドプリント</primary></indexterm>
	プリントサーバ(Samba)上でドライバ(後でダウンロードするための)の準備と配信を
	行う。これは、プリンタに最初にアクセスするとき、半自動的にドライバを入手して
	インストールする<quote>ポイントアンドプリント</quote>をクライアントが使う
	ことが出来るようになる。この方法を使うと、NT/200x/XPクライアントは、
	<emphasis>SPOOLSS/MS-RPC</emphasis>タイプの印刷呼び出しを使う。
	</para></listitem>
	</itemizedlist>

	<para>
	二番目の方法は、管理コストの削減と、偶然異なったバージョンのドライバが使われる
	ことを防ぐのに、最初のものを使うよりも推奨される。
	</para>
	</sect2>

	<sect2 id="cups-raw">
	<title><emphasis>application/octet-stream</emphasis>のための<quote>raw</quote>印刷を明示的に有効にする</title>


	<para>
	<indexterm><primary>application/octet-stream</primary></indexterm>
	<indexterm><primary>raw印刷</primary></indexterm>
	<indexterm><primary>MIME</primary><secondary>raw</secondary></indexterm>
	もしも最初のオプション(ドライバはクライアントサイド上でインストールされる)を使う
	場合、注意すべき設定が1つある:CUPSに対して、手の込んだ(バイナリ)ファイル形式
	である<quote>raw</quote>印刷を許可するように設定する。rawモード印刷を動かす
	ための、正しい設定する必要があるCUPSファイルは以下の通り:
	</para>

	<itemizedlist>
		<listitem><para><filename>/etc/cups/mime.types</filename></para></listitem>
		<listitem><para><filename>/etc/cups/mime.convs</filename></para></listitem>
	</itemizedlist>

	<para>
	両者はRAMモード操作を許可するためにコメントアウトしなければならないエントリ
	(それぞれのファイルの最後の部分)を含む。<filename>/etc/cups/mime.types</filename>
	中では下記の行が存在するようにする:
<programlisting>
application/octet-stream
</programlisting>
	<indexterm><primary>/etc/cups/mime.convs</primary></indexterm>
	<indexterm><primary>/etc/cups/mime.types</primary></indexterm>
	<filename>/etc/cups/mime.convs</filename>では、この行が存在するようにする:
	<indexterm><primary>application/vnd.cups-raw</primary></indexterm>
<programlisting>
application/octet-stream   application/vnd.cups-raw   0   - 
</programlisting>
	もしも、2つのファイルが、Windowsクライアントからの印刷に対して正しく設定されて
	いない場合、恐ろしい<computeroutput>Unable to convert file 0</computeroutput>
	というメッセージが、が、CUPSの<filename>error_log</filename>ファイル中に現れる
	だろう。
	</para>

	<note><para>
	<filename>mime.convs</filename>と<filename>mime.types</filename>ファイルを
	<quote>raw</quote>印刷を<emphasis>行う</emphasis>ことだけを
	<emphasis>許可する</emphasis>ように編集する。
	</para></note>

	<formalpara><title>背景</title>

	<para>
	<indexterm><primary>application/octet-stream</primary></indexterm>
<indexterm><primary>MIME type</primary></indexterm>
	CUPSは、伝統的な印刷システムが既定値では印刷デバイスに手の込んだ(おそらく
	バイナリ)のデータを、ユーザに送ることを認めていないと比べて、より
	セキュリティに気づいている印刷システムである。これは、プリンタに対して、
	少なくとも大量の紙とインクを無駄にすることとなる、
	<quote>サービス不能</quote>攻撃を引き起こす不正な使い方を簡単に行える。
	<quote>不明な</quote>データはCUPSによって、
	<parameter>MIME type: application/octet-stream</parameter>とタグ付けられ、
	プリンタに送ることを許可されない。既定値では、他の(既知の)MIMEタイプである
	<quote>raw</quote>のみを送ることが出来る。<quote>raw</quote>を送ることは、
	CUPSがそれらを変換せず、何もさわらないでプリンタに渡すことを意味する。
	</para>
	</formalpara>

	<para>
	これが、ベンダドライバをローカルにインストールしたWindowsクライアントによって
	準備された<quote>raw</quote>ファイルをCUPS/Sambaの協調印刷で行うときに知っておく
	必要があることのすべてである。もしもより詳細なCUPS/Samba印刷についての背景
	情報について興味がないならば、この章の残りの部分を読み飛ばせばよいだろう。
	</para>

	</sect2>

	<sect2>
	<title>ドライバアップロード手法</title>

	<para>
	この節では、プリンタドライバをアップロードする、3つのなじみやすい方法に、
	さらに新しいもの1つについて説明する。
	</para>

	<para>
	<indexterm><primary>ポイントアンドプリント</primary></indexterm>
	もしも、MS-RPCタイプの印刷を使いたいならば、最初にSambaサーバ上に
	(<smbconfsection name="[print$]"/>共有)ドライバをアップロードしなければならない。
	Sambaホスト上からプリンタドライバを配信する方法(結果、Windowsクライアントは
	<quote>ポイントアンドプリント</quote>経由でダウンロードしそれを利用できる)
	についての議論は、この資料の
	<link linkend="classicalprinting">旧式の印刷 の章</link>を参照のこと。
	以下は、Sambaサーバ上にクライアントドライバを準備するための3つの方法への
	説明又は参照である:
	</para>

	<itemizedlist>
		<listitem><para>
		<indexterm><primary>プリンタウィザードによる追加</primary></indexterm>
		GUIである<quote>Add Printer Wizard</quote>を使う
		<emphasis>Windowsクライアントからのアップロード</emphasis>方法。
		</para></listitem>

		<listitem><para>
		コマンドラインの<quote>smbclient/rpcclient</quote>を使う
		UNIXワークステーションからのアップロード方法。
		</para></listitem>

		<listitem><para>
		<indexterm><primary>imprints</primary></indexterm>
		Imprintsツールセットを使う方法。
		</para></listitem>
	</itemizedlist>

	<para> 
<indexterm><primary>cupsaddsmb</primary></indexterm>
	これらの3つの方法は、CUPSに対して同じように適用される。
	<command>cupsaddsmb</command>ユーティリティは最新で、CUPSを使っている場合、
	WindowsドライバをSamba中に起き、提供するより便利な方法である。
	</para>

	<para>
	<command>cupsaddsmb</command>は、この章の後の方でより詳細に説明される。しかし、
	まず初めにCUPSフィルタリングシステムを説明し、WindowsとUNIXの印刷アーキテクチャの
	違いを比較する。
	</para>

	</sect2>

</sect1>

<sect1>
	<title>Postscriptドライバダウンロードを使う高度に賢い印刷</title>

	<para>
	<indexterm><primary>PostScript</primary><seealso>Ghostscript</seealso></indexterm>
	<quote>dump</quote>プリントサーバをセットアップする方法は分かっているが、それは
	すなわち、プリントジョブを<quote>raw</quote>でスプールするサーバは、印刷データを
	変更しないということである。
	</para>

	<para>
	よりか指向違法方でCUPSをセットアップする必要があるかもしれない。その理由は
	いろいろとある:
	</para>

<indexterm><primary>印刷統計</primary></indexterm>
<indexterm><primary>average print run</primary></indexterm>
<indexterm><primary>print quota</primary></indexterm>
	<itemizedlist>
	<listitem><para>もしかしたら、あなたの上司は月次の印刷統計報告を希望しているだろう。
	すなわち、どのプリンタがどのくらいページを印刷したか?、印刷における平均的な
	時間ピークはどのくらいか?、どの部署がどのくらい印刷したか?</para></listitem>

	<listitem><para>もしかしたらプリントquotaシステムを設定したかと聞かれるだろう:
	ユーザが、一定期間内での制限より超えたジョブを印刷出来ないという。</para></listitem>

	<listitem><para>もしかしたら以前のネットワーク印刷の設定はひどい状態で、
	一から再構成しなければならないだろう。</para></listitem>

	<listitem><para>もしかしたらNT<quote>kernelモード</quote>で動作するあまりデバッグ
	されていないプリンタドライバに起因する<quote>ブルースクリーン</quote>を、とても
	たくさん体験しているだろう?</para></listitem>
	</itemizedlist>

	<para>
	これらのゴールはraw印刷サーバによっては成し遂げることが出来ない。それらの要求に
	auサーバを構築するためには、最初にどのようにCUPSが動作するかと、どのように
	それらの機能を有効にするかを学ぶ必要がある。
	</para>

	<para>
	以下では、WindowsとUNIX印刷環境における、いくつかの基本的なコンセプトの
	比較をまず行い、次に、CUPSフィルタリングシステムについて、どのように動作するか、
	どのように微調整できるかの説明を行う。
	</para>

	<sect2 id="gdipost">
	<title>Windows上でのGDI、UNIX上でのPostScript</title>

	<para>
	<indexterm><primary>GDI</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
	ネットワーク印刷は最も複雑でエラーが発生しがちであり、ユーザや管理者が
	遭遇しがちである日々の作業の1つである。これはすべてのOSプラットフォーム上で
	真実であり、そうなる理由がある。
	</para>


	<para>
	<indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>PDL</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>Adobe</primary></indexterm>
<indexterm><primary>ページ記述言語</primary><see>PDL</see></indexterm>
	プリンタに任意のファイルフォーマットを送り込み、それが印刷されることを期待する
	ことはできない。ファイルフォーマット変換を行う必要がある。問題は、すべての
	メーカとプリンタタイプに共通の、共通標準印刷ファイルフォーマットがないという
	ことである。Postscript(Adobeの商標)とその拡張であるPCL(HPの商標)はページ記述言語
	(PDL)として使われていることにより、ほぼ公式な<quote>標準</quote>として開発されて
	いる。しかし、多くのメーカは引き続き<quote>固有のものを使っている</quote>
	(それらの理由は、プリンタ内蔵のPostscriptインタプリタの、受け入れられないような
	ライセンス費用などである)。
	</para>

	</sect2>

	<sect2>
	<title>Windowsドライバ、GDIとEMF</title>

	<para>
	<indexterm><primary>GDI</primary></indexterm>
	<indexterm><primary>EMF</primary></indexterm>
	<indexterm><primary>WYSIWYG</primary></indexterm>
<indexterm><primary>拡張MetaFile</primary><see>EMF</see></indexterm>
	WindowsOSでは、フォーマット変換ジョブはプリンタドライバによって行われる。
	Microsoft Windows OSプラットフォーム上ではすべてのアプリケーションプログラマは、
	それらの基盤となるOSそれ自身の一部分、あるいは一区画として、自由に使える
	組み込みのAPI、グラフィカルデバイスインタフェース(GDI)を使える。このGDIコアは
	絵、フォントと文書を<emphasis>画面上に</emphasis>描画するのと同様に
	<emphasis>紙の上に</emphasis>(印刷)する、すべてのWindowsプログラムにある1つの
	共通基盤として使える。そのため、プリンタドライバ開発者はよく定義されたGDI出力を
	固有のドライバ入力として標準化できる。WYSIWYG(What You See Is What You Get)の
	実現は、スクリーン上のグラフィックプリミティブが紙上の描画オブジェクトと同じ
	ようで、同じソースから来るために、相対的に容易である。このソース、すなわちGDIは、
	しばしば拡張メタファイル(EMF)と呼ばれるファイルフォーマットを生成する。EMFは
	プリンタドライバによって処理され、プリンタ固有のファイルフォーマットに変換される。
	</para>

	<note><para>
	<indexterm><primary>PDF</primary></indexterm>
<indexterm><primary>Xprint</primary></indexterm>
<indexterm><primary>core graphic engine</primary></indexterm>
	Microsoft Windows中のGDI基盤に対して、Appleは紙と画面出力を、その(BSDUNIXベース
	なのだがご存じだろうか?)Mac OS XとDarwinオペレーティングシステムという
	<indexterm><primary>X Window System</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
        <indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>Xprint</primary></indexterm>
	同じ基盤上に置くことを選んだ。Appleの<emphasis>コアグラフィックエンジン</emphasis>
	は、すべての表示作業に<emphasis>PDF</emphasis>派生のものを使う。
	</para></note>

	<para>
	<link linkend="1small">ローカルプリンタに対するWindowsの印刷</link>中の例は、
	ローカルWindows印刷を図示している。
	</para>

	<figure id="1small">
		<title>ローカルプリンタに対するWindowsの印刷</title>
		<imagefile>1small</imagefile>
	</figure>

	</sect2>

	<sect2>
	<title>UNIX印刷ファイル変換とGUIの基礎</title>

	<para>
	<indexterm><primary>X Window System</primary></indexterm>
	<indexterm><primary>PostScript</primary></indexterm>
	<indexterm><primary>PCL</primary></indexterm>
	<indexterm><primary>Xprint</primary></indexterm>
	UNIXとLinuxでは、OSカーネルかX(画面表示)サーバ中に、構築された、類似のレイヤは
	ない。すべてのアプリケーションはそれ自身でその印刷出力を作成することに責任が
	ある。幸い、大部分がPostscriptを使い、それを何らかの共通基盤としている。
	また、悪いことに、同じ文書を画面上に表示することとどのようにそれを紙に
	印刷するかを行う、非常にたくさんの(そして何ら共通項がない)方法がある。
	これは、数10年前にさかのぼってみると、グラフィカルユーザインタフェースのための
	UNIX 基盤とプロトコルを設計したX.orgの前身は、幾人かがその時点で要求したように、
	<quote>紙出力</quote>についての責任を取るのを拒否し、それ自身を
	<quote>画面表示のみ</quote>に制限した(何年か後、<quote>Xprint</quote>
	プロジェクトが開発中で、Xのフレームワーク中に、PostscriptとPCLドライバを含む
	印刷サポートを構築することを試みたが、まだ完成していない)。この、余り好ましくない
	遺産は、使用しているシステムの、種々の<quote>font</quote>ディレクトリ中で、今も
	見ることができる。X表示用と印刷用に使うフォントが分かれている。
	</para>

	<formalpara>
	<title>背景</title>

	<para>
	<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>color</primary></indexterm>
<indexterm><primary>linewidth</primary></indexterm>
<indexterm><primary>scale</primary></indexterm>
<indexterm><primary>distort</primary></indexterm>
<indexterm><primary>rotate</primary></indexterm>
<indexterm><primary>shift</primary></indexterm>
<indexterm><primary>raster images</primary></indexterm>
<indexterm><primary>display PostScript</primary></indexterm>
<indexterm><primary>graphical objects</primary></indexterm>
	Postscriptプログラミング言語はAdobeの<quote>開発物</quote>であるが、その仕様は
	広範囲に公開されている。その能力は、その強力なグラフィカルオブジェクト
	(フォント、シェープ、パターン、行、曲線、と点)を記述する能力、その属性
	(色、線の幅)とそれらを操作する(拡大縮小、変形、回転、移動)ことによっている。
	その公開された仕様により、能力がある誰でも、固有のPostscriptインタプリタ実装を
	作成でき、画面あるいは紙状にPostscriptファイルを表示するのに使える。
	ほとんどのグラフィック出力デバイスは <quote>ラスタイメージ</quote>か
	<quote>ピクセル</quote>(ペンプロッタは特筆すべき例外)というコンセプトを基盤と
	している。もちろん、テキスト形式でPostscriptファイルを見ることもでき、
	ラスタライザによって解釈されるに必要な言語命令であるPostscriptコードを読む
	ことも出来る。ラスタライザは、ビューワプログラムによって画面上で表示されるか、
	プリンタによって印刷されるかする、ピクセルイメージを生成する。
	</para>
	</formalpara>
	</sect2>

	<sect2 id="post-and-ghost">
	<title>PostScriptとGhostscript</title>

	<para>
	<indexterm><primary>PostScript</primary></indexterm>
	<indexterm><primary>GhostScript</primary><seealso>PostScript</seealso></indexterm>
	<indexterm><primary>PostScript</primary><secondary>RIP</secondary></indexterm>
<indexterm><primary>PostScriptインタプリタ</primary></indexterm>
<indexterm><primary>ラスタイメージプロセッサ</primary><see>RIP</see></indexterm>
	UNIXは紙への印刷と画面上への表示についての共通基盤が欠けている。UNIXの、好ましく
	ない遺産にもかかわらず、自由に使えるPostscriptプリンタを持っている場合、基本的な
	印刷はかなり簡単である。その理由は、それらのデバイスは、ラスタイメージプロセッサ
	(RIP)と呼ばれる内蔵PostScript言語<quote>インタプリタ</quote>を持っているという
	(それにより、他のタイプのプリンタよりも値段が高い)ことである。それに向けて
	PostScriptを送り込むと、印刷したページを出力する。RIPは紙の上で見る事ができる、
	ビットマップの絵にPostScript描画コマンドを変換するすべての大変な仕事をこなし、
	プリンタによってそれを処理してしまう。これは、Windows上からPostScript印刷を
	行うのと何ら違いはない。
	</para>

	<note><para>
	<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>PPD-aware</primary></indexterm>
<indexterm><primary>PostScriptプリンタ記述</primary><see>PPD</see></indexterm>
	一般的なUNIXプログラムと印刷システムが、PostScriptを使っている間は、主にPPDを
	認識していない。PPDは<quote>PostScriptプリンタ記述</quote>ファイルである。これは
	プリンタがサポートしているすべてのオプションを指定し、制御する事を可能にする。
	そのオプションとは、たとえば、両面印刷、ステープル留めと穴空けである。そのため、
	WindowsかAppleユーザとは違って、たくさんのサポートされたデバイスとジョブ
	オプションを、UNIXユーザは長い時間選択できなかった。しかし、今では、CUPSがある。
	<link linkend="2small">PostScriptプリンタによる印刷</link>で図示されているように。
	</para>
	</note>

	<figure id="2small">
		<title>PostScript Printerによる印刷</title>
		<imagefile>2small</imagefile>
	</figure>

	<para>
	<indexterm><primary>PDL</primary></indexterm>
	しかしながら、それ以外のタイプのプリンタもある。それらはどのようにPostscriptを
	印刷するかが分からない。それらは、しばしばメーカ固有のPDLを使う。それらに対して
	印刷を行う事の注文はもっと多い。利用しているUNIXアプリケーションはほとんどの
	場合、Postscriptを生成し、それらのデバイスはPostscriptを理解しないので、
	それに対してデータを送る前に、ホスト上で使用しているプリンタに合わせた印刷
	ファイルのフォーマット変換を行う必要がある。
	</para>

	</sect2>

	<sect2>
	<title>Ghostscript: 非Postscriptプリンタに対するソフトウェアRIP</title>

	<para>
	<indexterm><primary>GhostScript</primary></indexterm>
	ここからGhostscriptの説明を始める。Ghostscriptは、UNIXプラットフォームで
	使われている、伝統的な(そしてとても強力な)Postscriptインタプリタである。
	これはソフトウェアによるRIPであり、ソフトウェアファイルフォーマットと同様、
	非常に広範囲のハードウェアデバイスへの、たくさんのファイル変換を行う能力がある。
	Ghostscript技術とドライバは非PostscriptハードウェアでPostscript印刷を実行
	できるようにするものである。これについては
	<link linkend="3small">非Postscriptプリンタに対するRIPとしてのGhostscript</link>
	に説明がある。
	</para>

	<figure id="3small">
		<title>非Postscriptプリンタに対するRIPとしてのGhostscript</title>
		<imagefile>3small</imagefile>
	</figure>

	<tip><para>
<indexterm><primary>PNG</primary></indexterm>
<indexterm><primary>AFPL</primary></indexterm>
<indexterm><primary>ESP</primary></indexterm>
	使用しているGhostscriptバージョンの内蔵<quote>デバイス</quote>すべてを確認する
	ために、<quote>gs -h</quote>コマンドを使う。もしも、使用しているGhostscriptの
	コマンド行に<parameter>-sDEVICE=png256</parameter>というパラメータを指定した
	ならば、入力をPNGファイルに変換するように、Ghostscriptに指定する。コマンド行上の
	<quote>device</quote>の名前指定は、入力をどのように描画するかを正確に
	Ghostscriptに指示するのに最も重要な単一パラメータである。新しいGhostscriptの
	バージョンは、現在artofcode LCCにおいて、通常かなり間隔を空けてリリースされる。
	通常最初は<quote>AFPL</quote>ライセンスで提供されるが、次のAFPLバージョンが
	リリースされると、すぐにGNU GPLライセンスで再リリースされる。GNU Ghostscript
	はおそらくほとんどのSambaシステム上にインストールされているバージョンである。
	しかし、いくつかの違いがある。
	<indexterm><primary>Ghostscript</primary><secondary>ESP</secondary><see>ESP GhostScript</see></indexterm>
	そのため、ESP Ghostscriptは、たくさんのバグ修正、追加のデバイスと改善がある、
	GNU Ghostscriptの拡張として開発されている。これは、CUPS, Gutenprint, MandrakeSoft,
	SuSE, Red Hatと Debianからの開発者によって一緒に保守されている。それには
	<quote>cups</quote>デバイス(CUPSから非PSプリンタに印刷する基本部分)を含む。
	</para></tip>

	</sect2>

	<sect2>
	<title>PostScriptプリンタ定義(PPD)の仕様</title>

	<para>
	<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>PDL</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
	Postscriptの本質がデバイス非依存の方式でページレイアウトを表現するための
	PDLである間は、実世界での印刷上部は常時デバイス固有の機能を持ったハードウェア
	上で最終的に出力される。ハードウェアの違いに気を遣うことと、機能改善を図るため、
	Adobeは文法とPostscriptプリンタ定義(PPD)ファイルのファイルフォーマットを定義
	してきた。すべてのPostscriptプリンタはそれらのファイルの1つを同梱して出荷されて
	いる。
	</para>

	<para>
	PPDは、そのプリンタに割り当てられた一般的および特別な機能についてのすべての情報を
	含んでいる。扱える異なった解像度は何か?両面印刷ユニットがあるか?ペーパートレイは
	いくつあるか?メディアのタイプとサイズは何が使えるか?それぞれの要素について、
	プリンタに送られる特別なコマンド文字列を、それを有効にするために指定する事が
	出来る(ほとんどの場合、Postscriptファイル中に)。
	</para>

	<para>
	PPDからの情報はプリンタドライバによって考慮されることを意味する。そのため、
	与えられたプリンタのための、Windows PostScriptドライバの一部としてインストール
	されるものはプリンタのPPDである。それが意味をなす場合、PPD機能は、印刷
	オプションをユーザに選択されるために表示される、ドライバのユーザインタフェース
	ダイアログ中で提供される。最後に、ユーザの選択は、ドライバによって作成された
	PostScriptファイル中に(特別なPostScript、PJL、JCLあるいはベンダ固有のコマンド
	形式として)何らかの形で書かれる。
	</para>

	<warning><para>
	<indexterm><primary>PDF</primary></indexterm>
<indexterm><primary>PDF抽出</primary></indexterm>
	特定の印刷ジョブ出力を行うために、デバイス固有のコマンドを含んで作成された
	特定のマシン上のPostScriptファイルは期待通りには印刷出来ないかもしれなく、
	すべてのモデル上で印刷可能ではないかもしれない。それはソフトウェアによる
	追加処理に適さないかもしれない(すなわち、PDF抽出プログラムによって)。
	</para></warning>
	</sect2>

	<sect2>
	<title>Windows形式のベンダPPDの使用</title>

	<para>
<indexterm><primary>CUPS</primary></indexterm>
<indexterm><primary>PPDs</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
	CUPSはそのPostScriptモデルのための、開発元によって供給された、すべての仕様に
	従っているPPDを扱うことが出来る。もしもベンダがマニュアルとパンフレットに
	使用しているOSについての言及がなかったとしても、それらを安全に信用できる:
	<emphasis>もしも、Windows NTバージョンのPPDを入手したならば、CUPS中で変更なしに利用でき</emphasis>、
	その結果、Windows NTユーザが出来るように使用するプリンタのすべての能力に
	アクセスできる。
	</para>

	<tip><para>
	オンラインでどのようなPPDの仕様遵守状態を確認するためには、
	<ulink noescape="1" url="http://www.cups.org/testppd.php">http://www.cups.org/testppd.php</ulink>
	に行き、PPDをアップロードする。すぐにその結果を見ることができる。バージョン
	1.1.19以降のすべてのバージョンのCUPSは、よりずっと厳しい内蔵PPD解析と検査
	コードが有効になっている。印刷トラブルが起きたら、このオンラインリソースを
	最初に調べる場所としてほしい。
	</para></tip>

	<warning><para>
	<indexterm><primary>foomatic</primary></indexterm>
	<indexterm><primary>cupsomatic</primary></indexterm>
	実際のPostScriptプリンタのためには、Linuxprinting.orgからの
	<emphasis>Foomatic</emphasis>か<emphasis>cupsomatic</emphasis>PPDを
	<emphasis>使ってはならない</emphasis>。それらのデバイスには、オリジナルの
	ベンダが提供したPPDが常時最初の選択肢となる。
	</para></warning>

	<tip><para>
<indexterm><primary>W32X86/2</primary></indexterm>
	もしも、特定のデバイスに対するオリジナルのベンダ提供PPDを捜していて、LAN上の
	NT4マシン(あるいは他の任意のWindowsマシン)がインストールされているPostScript
	プリンタを持っている場合、すべてのプリンタドライバが格納されているWindows
	ディレクトリにアクセスするために、
	<command>smbclient //NT4-box/print\$ -U username</command>を使用する。
	最初に、捜しているPPDのために、<filename>W32X86/2</filename>サブディレクトリを
	捜してみる。
	</para></tip>
	</sect2>

	<sect2>
	<title>非PostScriptプリンタのためにCUPSはPPDを使う</title>

	<para>
<indexterm><primary>非PostScript</primary></indexterm>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>CUPSフィルタリング</primary></indexterm>
	CUPSは非PostScriptプリンタを扱うために、特別に作成されたPPDをも使う。それらの
	PPDは通常ベンダから供給されない(そして、同じモデル名のPostScriptプリンタ用の
	PPDファイルを使うことが出来ず、非PostScriptバージョンが動くことを期待することも
	同じである)。非PostScriptプリンタに対してPPDがどのように適用されるかを知るため
	には、最初にCUPSフィルタリングとファイルフォーマット変換アーキテクチャについて
	深く言及する必要がある。引き続き読み続けること。
	</para>

	</sect2>

</sect1>

<sect1>
<title>CUPSフィルタリングアーキテクチャ</title>

<para>
<indexterm><primary>CUPSフィルタリング</primary></indexterm>
<indexterm><primary>Ghostscript</primary></indexterm>
<indexterm><primary>MIME タイプ</primary></indexterm>
<indexterm><primary>MIME 認識</primary></indexterm>
<indexterm><primary>MIME 変換規則</primary></indexterm>
CUPSフィルタリングシステムの中核は、Ghostscriptによっている。Ghostscriptを追加する事で、
CUPSはそれ自身固有のフィルタ以外のいくつかを使う。あなた自身(あるいはベンダ)はさらに
フィルタを追加しても良い。CUPSはすべてのデータファイルフォーマットを種々のMIMEタイプの
ラベル配下で取り扱う。入力された各印刷ファイルは、最初に行われる自動タイプわけに基づいて
扱われる。自動タイプわけにより、MIMEタイプが決定する。与えられたMIMEタイプは、選択された対象
プリンタに、0またはそれ以上の、フィルタリングチェーンが自動的に(暗黙のうちに)設定される。
この節では、どのようにMIMEタイプ認識と変換ルールが相互に作用するかについて説明する。
それらは、与えられた入力データフォーマットに対する、動作させるフィルタリングチェーンを
自動的に設定するために、CUPSによって使われる。
</para>

<para>
もしもCUPSがネイティブにビットマップにPostScriptファイルをラスタライズするならば、
それは以下の2つのステージで行われる:
</para>

<itemizedlist>
	<listitem><para>
<indexterm><primary>一般的なラスタ形式</primary></indexterm>
<indexterm><primary>CUPS raster</primary></indexterm>
	最初のステージでは、<quote>cups</quote>という名前のGhostscriptデバイスを使い
	(これは、バージョン1.15以降)、<quote>CUPS raster</quote>と呼ばれる一般的な
	ラスタ形式を生成する。
	</para></listitem>

	<listitem><para>
<indexterm><primary>raster driver</primary></indexterm>
	第二のステージでは、標準的なCUPSラスタをデバイス固有のラスタに変換する、
	<quote>ラスタドライバ</quote>を使う。
	</para></listitem>
</itemizedlist>

<para>
<indexterm><primary>Ghostscript</primary></indexterm>
<indexterm><primary>GNU Ghostscript</primary></indexterm>
<indexterm><primary>ESP Ghostscript</primary></indexterm>
使用するGhostscriptのバージョンが<quote>cups</quote>デバイスをコンパイルしてあるように
しておくこと(これは<command>gs -h |grep cups</command>で調べられる。それ以外だと、
CUPS CUPS error_logファイルに<computeroutput>Unable to convert file 0</computeroutput>
というエラーメッセージが表示されるだろう。使用しているGhostscript中にデバイスとして
<quote>cups</quote>が含まれるようにするには、GNU Ghostscriptにパッチを当てて再コンパイル
するか、
<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary></indexterm>
<ulink url="http://www.cups.org/ghostscript.php">ESP Ghostscript</ulink>を
使う必要がある。良い代替はESP Ghostscriptである。これはCUPSサポートだけではなく、
300もの他のデバイス(GNU Ghostscriptがおおよそ180くらいしかサポートしないのに対して)を
サポートする。この広範囲なデバイスサポートがあるという理由で、ESC Ghostscriptは
非CUPSスプーラ用の、最初の選択肢としても使える。すべてのスプーラに対して、
Linuxprinting.orgによって現在は推奨されている。
</para>

<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>foomatic</primary></indexterm>
<indexterm><primary>foomatic-rip</primary></indexterm>
<indexterm><primary>ESP Ghostscript</primary></indexterm>
CUPSプリンタは外部レンダリングパスを使うように設定しても良い。最も共通的なものは、
<ulink url="http://www.linuxprinting.org/">Linuxprinting.org</ulink>からの
Foomatic/cupsomaticコンセプトによって提供されるものである。これは古いGhostscript
を用いて、すべてを1ステップで処理する。これは<quote>cups</quote>デバイスを使わないが、
その他の多くを使う。しかし、Foomatic/cupsomaticの使用にもかかわらず、最も良い解と
<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary></indexterm>
広範囲のプリンタモデルのサポートはESC Ghostscriptによって提供される
(Foomatic/cupsomaticについての詳細、現在<emphasis>foomatic-rip</emphasis>と
呼ばれている、特に新しいバージョンについては、以下を参照)。
</para>

	<sect2>
	<title>MIMEタイプとCUPSフィルタ</title>


	<para>
	<indexterm><primary>MIME</primary><secondary>filters</secondary></indexterm>
	<indexterm><primary>MIME</primary></indexterm>
<indexterm><primary>mime.types</primary></indexterm>
<indexterm><primary>application/pdf</primary></indexterm>
<indexterm><primary>autotyping</primary></indexterm>
	CUPSは<filename>/etc/cups/mime.types</filename>(と、同じディレクトリ中にある、
	すべての<filename>*.types</filename>ファイル)を起動時に読み込む。これらの
	ファイルはCUPSがそのautotyping機能を動かしているときに適用されるMIMEタイプ
	認識ルールを含む。ルールの文法は<filename>mime.types</filename>のマニュアル
	ページと<filename>mime.types</filename>ファイルそれ自身のコメントセクションに
	記述されている。簡単なルールは以下の通りである:
	<indexterm><primary>application/pdf</primary></indexterm>
<programlisting>
application/pdf         pdf string(0,%PDF)
</programlisting>
<indexterm><primary>%PDF</primary></indexterm>
<indexterm><primary>.pdf</primary></indexterm>
	これは、もしファイル名に<filename>.pdf</filename>という拡張子が付いているか、
	あるいは、マジック文字列<emphasis>%PDF</emphasis>がファイルそれ自身の先頭の
	正しいところ(開始時点からオフセット0)にある場合、それはPDFファイルである
	(<parameter>application/pdf</parameter>)。その他のルールは以下の通り:
<programlisting>
application/postscript  ai eps ps string(0,%!) string(0,&lt;04&gt;%!)
</programlisting>
<indexterm><primary>suffixes</primary></indexterm>
<indexterm><primary>.ai</primary></indexterm>
<indexterm><primary>.eps</primary></indexterm>
<indexterm><primary>.ps</primary></indexterm>
<indexterm><primary>一般的な PostScript</primary></indexterm>
<indexterm><primary>application/postscript</primary></indexterm>
	もしも、ファイル名が<filename>.ai</filename>, <filename>.eps</filename>,
	<filename>.ps</filename>という拡張子のどれかを持つか、ファイルそれ自身が
	<emphasis>%!</emphasis>か<emphasis><![CDATA[<04>%!]]></emphasis>という文字列の
	どれかで始まるならば、それは一般的なPostScriptファイルである
	(<parameter>application/postscript</parameter>)。
	</para>

	<warning><para>
<indexterm><primary>/etc/cups/</primary></indexterm>
	使用するシステムが、<filename>/etc/cups/</filename>ディレクトリ中のどれかを
	使うかもしれない、他のmime.typesファイルと混同しないこと。
	</para></warning>

	<note><para>
<indexterm><primary>application/postscript</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>filter</primary></indexterm>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>変換</primary></indexterm>
	CUPS中の2つの似たようなMIMEタイプとの間で、重要な違いがある。1つは
	<parameter>application/postscript</parameter>で、もう一つは
	<parameter>application/vnd.cups-postscript</parameter>である。
	<parameter>application/postscript</parameter>がデバイス非依存を意味するので、
	ファイルのジョブオプションは引き続きPSファイルの内容の外側にあり、CUPSによって
	コマンドラインか環境変数中に埋め込まれ、
	<parameter>application/vnd.cups-postscript</parameter>は、PostScriptそれ自身
	中に埋め込まれるジョブオプションがあるかもしれない(適用可能ならば)。一般的な
	PostScript(<parameter>application/postscript</parameter>)の、デバイス固有の
	バージョン(<parameter>application/vnd.cups-postscript</parameter>)への変換は、
	CUPSの<parameter>pstops</parameter>フィルタの責任である。pstopsは変換を行う
	ためにPPD中に含まれる情報を使う。
	</para></note>

	<para>
<indexterm><primary>ASCII</primary></indexterm>
<indexterm><primary>HP-GL</primary></indexterm>
<indexterm><primary>PDF</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>DVI</primary></indexterm>
<indexterm><primary>GIF</primary></indexterm>
<indexterm><primary>PNG</primary></indexterm>
<indexterm><primary>TIFF</primary></indexterm>
<indexterm><primary>JPEG</primary></indexterm>
<indexterm><primary>Photo-CD</primary></indexterm>
<indexterm><primary>SUN-Raster</primary></indexterm>
<indexterm><primary>PNM</primary></indexterm>
<indexterm><primary>PBM</primary></indexterm>
<indexterm><primary>SGI-RGB</primary></indexterm>
<indexterm><primary>MIME</primary></indexterm>
<indexterm><primary>filters</primary></indexterm>
	CUPSはASCIIテキスト,HP-GL, PDF, PostScript, DVIと多くの画像イメージ形式
	(GIF, PNG, TIFF, JPEG, Photo-CD, SUN-Raster,PNM, PBM, SGI-RGBやその他)と
	それらに関連したMIMEタイプとそのフィルタを扱うことが出来る。
	</para>

	</sect2>

	<sect2>
	<title>MIMEタイプ変換ルール</title>


	<para>
	<indexterm><primary>MIME</primary></indexterm>
	<indexterm><primary>application/pdf</primary></indexterm>
<indexterm><primary>/etc/cups/mime.convs</primary></indexterm>
<indexterm><primary>application/pdf</primary></indexterm>
<indexterm><primary>application/postscript</primary></indexterm>
	CUPSは<filename>/etc/cups/mime.convs</filename>(と、同じディレクトリ中にある、
	その他の<filename>*.convs</filename>というファイルも)を起動時に読み込む。
	それらのファイルには入力MIMEタイプ、出力MIMEタイプ、入力タイプから出力を生成
	できるフォーマット変換フィルタとその変換に関連する仮想のコストを意味する行を
	含む。その1つの例は以下のようになる:
<programlisting>
application/pdf         application/postscript   33   pdftops
</programlisting>
<indexterm><primary>pdftops</primary></indexterm>
	これは、<parameter>pdftops</parameter>フィルタが入力として
	<parameter>application/pdf</parameter>を取り、出力として
	<parameter>application/postscript</parameter>を生成する。この操作の仮想コストは
	33 CUPS-$である。次のフィルタはより高価で、66 CUPS-$かかる:
	<indexterm><primary>pdf</primary></indexterm>
<programlisting>
application/vnd.hp-HPGL application/postscript   66   hpgltops
</programlisting>
<indexterm><primary>hpgltops</primary></indexterm>
	これは、HP-GLプロッタファイルをPostScriptへ変換処理する
	<parameter>hpgltops</parameter>である。
	<indexterm><primary>application/octet-stream</primary></indexterm>
<programlisting>
application/octet-stream
</programlisting>
	さらに2つの例である:
	<indexterm><primary>text/plain</primary></indexterm>
<indexterm><primary>application/x-shell</primary></indexterm>
<indexterm><primary>text/plain</primary></indexterm>
<indexterm><primary>texttops</primary></indexterm>
<programlisting>
application/x-shell     application/postscript   33    texttops
text/plain              application/postscript   33    texttops
</programlisting>
<indexterm><primary>application/x-shell</primary></indexterm>
	最後の2つの例は<parameter>application/x-shell</parameter>上と同じように
	<parameter>text/plain</parameter>で動作する<parameter>texttops</parameter>
	フィルタを意味する(ヒント:この違いは、<parameter>texttops</parameter>の
	特筆すべき機能の文法のために必要とされる)。
	</para>
	</sect2>

	<sect2>
	<title>フィルタリングの概要</title>

	<para>
	<indexterm><primary>MIME</primary></indexterm>
	<filename>mime.convs</filename>という名前の、よりたくさんの組み合わせがある。
	しかし、あらかじめ定義してあるもの以外を使うことに制限はない。好みの、CUPS
	フレームワークに対する任意のフィルタを追加できる。それは最小限の要求に適合
	するか、させねばならない。もしも、ある種の効果的なフィルタを見つける(か書くか)
	場合、CUPSの要求が要求するものに従い、適切な行を<filename>mime.types</filename>と
	<filename>mime.convs</filename>に書く。そうするとCUPS内部でシームレスに動作する。
	</para>

	<sect3>
	<title>フィルタの要求</title>

	<para>
	フィルタに対する<quote>CUPSの要求</quote>は単純である。入力としてファイル名か
	<filename>標準入力</filename>を取り、<filename>標準出力</filename>に出力する。
	これはまた下記の引数を持つ:
	</para>

	<variablelist>
		<varlistentry><term>printer</term>
			<listitem><para>
			プリンタキューの名前(通常これは動かすフィルタの名前である)。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>job</term>
			<listitem><para>
			印刷するジョブのジョブID値(数字)。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>user</term>
			<listitem><para>
			オリジナルのユーザ名属性からの文字列。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>title</term>
			<listitem><para>
			ジョブ名属性からの文字列。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>copies</term>
			<listitem><para>
			コピー数属性からの数値。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>options</term>
			<listitem><para>
			ジョブのオプション。
			</para></listitem>
		</varlistentry>

		<varlistentry><term>filename</term>
			<listitem><para>
			(オプション)印刷を要求するファイル(もしも指定されなければ、
			フィルタは<filename>標準入力</filename>からのデータ供給を
			仮定する)。ほとんどの場合、CUPSで動作するようにさせるための
			存在するフィルタを囲む単純なラッパプログラムを書くことは
			簡単である。
			</para></listitem>
		</varlistentry>
	</variablelist>

	</sect3>

	</sect2>

	<sect2>
	<title>Prefilters</title>

	<para>
	<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>非PostScriptプリンタ</primary></indexterm>
<indexterm><primary>raster</primary></indexterm>
	以前に説明したように、PostScriptは、任意のUNIXベースの印刷システムにおいて
	中核となるファイル形式である。PostScriptから、非PostScriptプリンタに送る
	ためのラスタデータを、CUPSは生成する。
	</para>

	<para>
<indexterm><primary>prefilters</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>ASCIIテキスト</primary></indexterm>
<indexterm><primary>PDF</primary></indexterm>
<indexterm><primary>DVI</primary></indexterm>
<indexterm><primary>HP-GL.</primary></indexterm>
<indexterm><primary>MIMEタイプ</primary></indexterm>
<indexterm><primary>application/postscript</primary></indexterm>
<indexterm><primary>pstops</primary></indexterm>
<indexterm><primary>application/vnd.cups-postscript</primary></indexterm>
	しかし、印刷するためにサポートされた非PSフォーマットのどれかを送る時に何が起きる
	のだろうか?次にCUPSはPostScriptを最初に生成するために、それらの入力上で
	<quote>prefilters</quote>を動かす。これは、ASCIIテキスト,PDF, DVI,かHP-GLから
	PostScriptを生成するためのprefilterである。それらのフィルタからの出力は常時
	<parameter>application/postscript</parameter>というMIMEタイプである
	(これは任意のデバイス固有のオプションはCUPSによってまだPostScriptに埋め込まれて
	おらず、呼ばれる次のフィルタはpstopsであることを意味する)。その出力は常時
	<parameter>application/vnd.cups-postscript</parameter>というMIMEタイプである
	(application/postscriptではない)場合、プリントオプションはすでにファイルに
	埋め込まれている事を意味する。これは、
	<link linkend="4small">PostScriptを整形するためのCUPS内のprefiltering</link>
	で説明されている。
	</para>

	<figure id="4small">
		<title>PostScriptを整形するためのCUPS内のprefiltering</title>
		<imagefile scale="25">4small</imagefile>
	</figure>

	</sect2>

	<sect2>
	<title>pstops</title>

	<para>
<indexterm><primary>pstops</primary></indexterm>
<indexterm><primary>application/postscript</primary></indexterm>
<indexterm><primary>application/vnd.cups-postscript</primary></indexterm>
<indexterm><primary>両面印刷</primary></indexterm>
<indexterm><primary>stapling</primary></indexterm>
<indexterm><primary>穴空け</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
	<emphasis>pstops</emphasis>は、<parameter>application/postscript</parameter>を
	<parameter>application/vnd.cups-postscript</parameter>に変換するために使われる
	フィルタである。以前に説明したように、このフィルタはすべてのデバイス固有の印刷
	オプション(両面印刷やstanpingと穴あけなどをプリンタに指示するコマンド)を、
	PostScriptファイル中に挿入する。その例は、
	<link linkend="5small">デバイス固有印刷オプションの追加</link>に例示されている。
	</para>

	<figure id="5small">
		<title>デバイス固有印刷オプションの追加</title>
		<imagefile scale="25">5small</imagefile>
	</figure>

	<para>
	これがすべてではない。これにより行われるその他の処理は以下の通り:
	</para>

	<itemizedlist>
		<listitem><para>
		印刷ページ範囲を指定する(すなわち、<quote>3, 6, 8-11, 16と19-21</quote>
		か、偶数ページのみ印刷することを選べる)。
		</para></listitem>

		<listitem><para>
		1枚に2枚あるいはそれ以上のページを配置する(<quote>数値-up</quote>
		機能と呼ばれる)。
		</para></listitem>

		<listitem><para><filename>/var/log/cups/page_log</filename>に、
		課金情報を記録するための、ジョブのページ数をカウントする。
		</para></listitem>
	</itemizedlist>
	</sect2>

	<sect2>
	<title>pstoraster</title>

	<para>
<indexterm><primary>pstoraster</primary></indexterm>
<indexterm><primary>ラスタライズ</primary></indexterm>
<indexterm><primary>ラスタデバイス</primary></indexterm>
	<parameter>pstoraster</parameter>はCUPSフィルタリングシステムの中核である。
	これは、ラスタライズ処理の最初のステージに対して責任がある。その入力は
	application/vnd.cups-postscriptというMIMEタイプである。その出力は、
	application/vnd.cups-rasterである。この出力形式はまだ印刷可能にはなっていない。
	その目的は、デバイス固有印刷データの生成を有効にする、より特殊化した
	<emphasis>ラスタデバイス</emphasis>のための汎用入力形式として提供することである。
	これについては、
	<link linkend="cups-raster">PostScriptから中間ラスタ形式への変換ダイアグラム</link>
	を参照のこと。
	</para>

	<figure id="cups-raster">
		<title>PostScriptから中間ラスタ形式への変換ダイアグラム</title>
		<imagefile scale="25">6small</imagefile>
	</figure>

	<para>
<indexterm><primary>CUPS ラスタ</primary></indexterm>
<indexterm><primary>汎用ラスタ</primary></indexterm>
<indexterm><primary>IANA</primary></indexterm>
<indexterm><primary>ラスタドライバ</primary></indexterm>
	CUPSラスタは強力な機能を持つ汎用ラスタフォーマットである。これは、ページ単位
	情報、色のプロファイルなど、下位のラスタドライバで使われるものを含むことが
	出来る。そのMIMEタイプはIANAに登録されていてその仕様はもちろん完全に公開されて
	いる。それを作るのはとても簡単で、選択したものに対応すべきプリンタモデル用に、
	LinuxとUNIXラスタドライバを製造元が作成するために、費用がかからないように
	設計されている。CUPSは常時ラスタライズする最初のステージに注意を払っているので、
	ベンダはGhostscript互換について注意を払う必要はない(実際、CUPSラスタドライバの
	開発の資金調達を行っている、1つ以上のベンダが現在存在する)。これは、
	<link linkend="cups-raster2">Ghostscriptを使うCUPSラスタ生成の図解</link>
	に図示している。
	</para>

	<figure id="cups-raster2">
		<title>Ghostscriptを使うCUPSラスタ生成の図解</title>
		<imagefile>7small</imagefile>
	</figure>

	<para>
<indexterm><primary>pstoraster</primary></indexterm>
<indexterm><primary>GNU Ghostscript</primary></indexterm>
<indexterm><primary>AFPL Ghostscript</primary></indexterm>
<indexterm><primary>独立フィルタ</primary></indexterm>
	バージョン1.1.15より前のCUPSバージョンでは、バイナリ(あるいはソースコードで)、
	<parameter>pstoraster</parameter>という名前の独立フィルタを提供していた。
	<parameter>pstoraster</parameter>はGNU Ghostscript 5.50由来で、代替インストール
	可能で、競合なしにGNUあるいはAFPL Ghostscriptパッケージに追加される。
	</para>

	<para>
	バージョン1.1.15以降、この機能は変更された。このフィルタの機能は、Ghostscriptに
	統合された(現在はGNU Ghostscript バージョン 7.05をベースとしている)。
	<parameter>pstoraster</parameter>フィルタは現在<command>-sDEVICE=cups</command>
	パラメータを付けた<command>gs</command>を呼び出す単純なシェルスクリプトである。
	もしも、<command>gs -h |grep cups</command>を実行したときにGhostscriptがエラーに
	なるならば、印刷は出来ないので、Ghostscriptをアップデートする必要がある。
	</para>
	</sect2>

	<sect2>
	<title>imagetops と imagetoraster</title>

	<para>
<indexterm><primary>prefilter</primary></indexterm>
<indexterm><primary>imagetoraster</primary></indexterm>
	prefiltersについての節において、イメージ形式からPostScriptを生成するprefilter
	について言及した。<parameter>imagetoraster</parameter>フィルタは中間PostScript
	ステージなしにイメージからラスタに直接変換するために使われる。これは以前に
	言及したprefilterよりもより頻繁に使われる。イメージファイルのフィルタリングに
	ついての要約フローチャートは
	<link linkend="small8">イメージ形式をCUPSラスタ形式に変換する流れ</link>である。
	</para>

	<figure id="small8">
		<title>イメージ形式をCUPSラスタ形式に変換する流れ</title>
		<imagefile>8small</imagefile>
	</figure>

	</sect2>

	<sect2>
	<title>rasterto [プリンタ固有]</title>

	<para>
<indexterm><primary>rastertoalps</primary></indexterm>
<indexterm><primary>rastertobj</primary></indexterm>
<indexterm><primary>rastertoepson</primary></indexterm>
<indexterm><primary>rastertoescp</primary></indexterm>
<indexterm><primary>rastertopcl</primary></indexterm>
<indexterm><primary>rastertoturboprint</primary></indexterm>
<indexterm><primary>rastertoescp</primary></indexterm>
<indexterm><primary>rastertohp</primary></indexterm>
<indexterm><primary>rastertoprinter</primary></indexterm>
<indexterm><primary>rastertoprinter</primary></indexterm>
<indexterm><primary>Gutenprint</primary></indexterm>
	CUPSはCUPSラスタを処理するための非常に数多くのラスタドライバを提供している。
	筆者の環境では、/usr/lib/cups/filter/配下に
	<parameter>rastertoalps</parameter>,<parameter>rastertobj</parameter>,
        <parameter>rastertoepson</parameter>,<parameter>rastertoescp</parameter>,
	<parameter>rastertopcl</parameter>,<parameter>rastertoturboprint</parameter>,
	<parameter>rastertoapdk</parameter>,<parameter>rastertodymo</parameter>,
	<parameter>rastertoescp</parameter>, <parameter>rastertohp</parameter>と
        <parameter>rastertoprinter</parameter>があった。これよりドライバの数が少なくても
	心配することはない。上記のいくつかはCUPSに対する商用アドオンであり
	(<parameter>rastertoturboprint</parameter>のような)、その他
	(<parameter>rastertoprinter</parameter>のような)は、可能な限りCUPSと協調する
	ことを望んでいるサードパーティドライバ開発プロジェクトに由来する
	(たとえばGutenprint)。
	<link linkend="small9">ラスタからプリンタ固有形式への変換図</link>
	を参照。
	</para>

		<figure id="small9">
			<title>ラスタからプリンタ固有形式への変換図</title>
			<imagefile>9small</imagefile>
		</figure>
	</sect2>

	<sect2>
	<title>CUPSバックエンド</title>

	<para>
<indexterm><primary>CUPSフィルタリングチェーン</primary></indexterm>
<indexterm><primary>印刷キュー</primary></indexterm>
	CUPSフィルタリングチェーンについての最後の部分はバックエンドである。
	バックエンドは、最終的なデバイスに印刷可能なファイルを送るための、特別な
	プログラムである。ネットワーク経由でと、すべてのローカルなインタフェースに
	印刷ジョブを送るための、任意の異なった分離されたバックエンドプログラムが
	ある。すべてのCUPS印刷キューは、それに関連づけられているCUPS
	<quote>device-URI</quote>を持つ必要がある。device URIは、その送付先にジョブを
	送るときに使われる、バックエンドをエンコードする方法である。以下で一覧表示
	されているもので分かるように、ネットワークdevice URLは記述の中に2つの
	スラッシュ(斜線)を使い、ローカルdevice URLは1つのみを使う。ローカル
	インタフェース名は、OSがLinux以外の場合、筆者の例では非常に自由度があっても
	よいことを心にとめておくこと:
	</para>

	<variablelist>
		<varlistentry><term>usb</term>
		<listitem><para>
		このバックエンドはUSB接続のプリンタに印刷ファイルを送る。使用する
		CUPS device URIの例は以下の通り。
		<filename>usb:/dev/usb/lp0</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>serial</term>
		<listitem><para>
		このバックエンドはシリアル接続したプリンタに印刷ファイルを送る。使用する
                CUPS device URIの例は以下の通り。
		<filename>serial:/dev/ttyS0?baud=11500</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>parallel</term>
		<listitem><para>
		このバックエンドはパラレルポートに接続したプリンタに印刷ファイルを送る。使用する
                CUPS device URIの例は以下の通り。
		<filename>parallel:/dev/lp0</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>SCSI</term>
		<listitem><para>
		このバックエンドはSCSIインタフェースに接続されたプリンタに印刷ファイルを送る。使用する
                CUPS device URIの例は以下の通り。
		<filename>scsi:/dev/sr1</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>lpd</term>
		<listitem><para>
		このバックエンドはLPR/LPDで接続されたネットワークプリンタに印刷ファイルを送る。使用する
                CUPS device URIの例は以下の通り。
		<filename>lpd://remote_host_name/remote_queue_name</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>AppSocket/HP JetDirect</term>
		<listitem><para>
		このバックエンドはAppSocket(別名JetDirect)で接続されたネットワークプリンタに
		印刷ファイルを送る。使用するCUPS device URIの例は以下の通り。
		<filename>socket://10.11.12.13:9100</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>ipp</term>
		<listitem><para>
		このバックエンドはIPPで接続されたネットワークプリンタ(か他のCUPSサーバ)に
		印刷ファイルを送る。使用するCUPS device URIの例は以下の通り。
		<filename>ipp:://192.193.194.195/ipp</filename>
		(多くのHPプリンタ用)と
		<filename>ipp://remote_cups_server/printers/remote_printer_name</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>http</term>
		<listitem><para>
		このバックエンドはHTTPで接続されたプリンタにファイルを送る
		(http:// CUPSバックエンドはipp://バックエンドの単なるシンボリックリンクである)。
		CUPS device URIの例は以下の通り。
		<filename>http:://192.193.194.195:631/ipp</filename>
		(多くのHPプリンタ用)と
		<filename>http://remote_cups_server:631/printers/remote_printer_name</filename>
		</para></listitem></varlistentry>

		<varlistentry><term>smb</term>
		<listitem><para>
		このバックエンドはWindowsホストによって共有されているプリンタに印刷ファイルを送る。
                CUPS device URIの例は以下の通り。
		</para>

		<para>
		<simplelist>
		<member><filename>smb://workgroup/server/printersharename</filename></member>
		<member><filename>smb://server/printersharename</filename></member>
		<member><filename>smb://username:password@workgroup/server/printersharename</filename></member>
		<member><filename>smb://username:password@server/printersharename</filename></member>
		</simplelist>
		</para>

		<para>
		The smb:// backendはSambaユーティリティ<parameter>smbspool</parameter>
		(CUPSによって提供されていない)へのシンボリックリンクである。もしも
		CUPSバックエンドディレクトリ中にシンボリックリンクがない場合、root
		ユーザになって、
		<command>ln -s `which smbspool' /usr/lib/cups/backend/smb</command>
		を実行してこれを作ること。
		</para></listitem></varlistentry>
	</variablelist>

	<para>
	CUPS印刷システムに対して任意の変更又は拡張の必要性がある場合、シェル又はPerl
	スクリプトで固有のバックエンドを書くことは簡単である。印刷ジョブをメールとして
	(<quote>mailto:/</quote>バックエンド経由で)送る、PDFに変換する
	(<quote>pdfgen:/</quote>バックエンド経由で)、あるいは<quote>/dev/null</quote>に
	ダンプするというような<quote>特別な</quote>プリンタを作成したいというような
	希望が理由としてあげられる(実際、システム全体での既定値のプリンタとして、
	devnull:/バックエンドに接続するプリンタを用意している)。とても多くの人が、
	プリンタを指定しないでジョブを送信したり、スクリプトとプログラムがプリンタを
	指定しない。システム全体での既定値はジョブを削除し、$USERに、
	正しいプリンタ名を常時指定するようにという丁寧なメールを送る)。
	</para>

	<para>
<indexterm><primary>lpinfo</primary></indexterm>
<indexterm><primary>CUPSバックエンド</primary></indexterm>
	説明したバックエンドすべて以外が使用しているシステム上にあるか、利用可能に
	(ハードウェア設定に依存する)なっていてもよい。すべての有効なCUPSバックエンドを
	調べる1つの方法は<emphasis>lpinfo</emphasis>として提供されている。これを
	<option>-v</option>を付けて付こうと、すべての有効なバックエンドを下記のように
	表示する:
	</para>

	<para><screen>
	&prompt;<userinput>lpinfo -v</userinput>
	</screen></para>
	</sect2>

	<sect2>
	<title><parameter>cupsomatic/foomatic</parameter>の役割</title>

	<para>
	<indexterm><primary>cupsomatic</primary></indexterm>
	<indexterm><primary>foomatic</primary></indexterm>
<indexterm><primary>PPDs</primary></indexterm>
<indexterm><primary>Foomaticプリンタ</primary></indexterm>
<indexterm><primary>Linuxprinting.org</primary></indexterm>
	<parameter>cupsomatic</parameter>フィルタはCUPSをインストールするときに最も広く
	使われているだろう。これらはCUPS開発者によって開発されたものではないということを
	明確にする必要がある。これらはCUPSに対するサードパーティアドオンである。これらは
	CUPSのためにジョブをレンダリングする従来のGhostscriptデバイスを使う。
	問題が発生したときの調査時にはその違いを知っておく必要がある。ここでは1ステージで
	すべてのレンダリングプロセスがGhostscript内部で、対象のプリンタに適したデバイスを
	使って行われる。<parameter>cupsomatic</parameter>は、Linuxprinting.orgにある
	Foomaticプリンタドライバデータベースから生成されたPPDを使う。
	</para>

	<para>
	You can recognize these PPDs from the line calling the
	<parameter>cupsomatic</parameter> filter:
<programlisting>
*cupsFilter: "application/vnd.cups-postscript  0  cupsomatic"
</programlisting>
	PPDファイルの最初の40かそのあたりで、この行を見つけるかもしれない。
	もしも、そのような、インストールされたPPDがあるならば、プリンタは
	<parameter>foomatic</parameter>の名前部分に<parameter>foomatic</parameter>が
	表示されたCUPS Webインタフェース中で表示される。
	<parameter>cupsomatic</parameter>は、選択されたPPDとプリントジョブに与えられた
	コマンドラインオプションから自動的に構成された、すべての複雑なコマンドライン
	オプションを付けたGhostscriptを実行させるPerlスクリプトである。
	</para>

	<para>
	<indexterm><primary>ポイントアンドプリント</primary></indexterm>
<indexterm><primary>foomatic-rip</primary></indexterm>
<indexterm><primary>Adobeの仕様</primary></indexterm>
<indexterm><primary>高解像度の写真</primary></indexterm>
<indexterm><primary>normal color</primary></indexterm>
<indexterm><primary>grayscale</primary></indexterm>
<indexterm><primary>draft</primary></indexterm>
<indexterm><primary>メディアタイプ</primary></indexterm>
<indexterm><primary>解像度</primary></indexterm>
<indexterm><primary>inktype</primary></indexterm>
<indexterm><primary>dithering algorithm</primary></indexterm>
	しかし、<parameter>cupsomatic</parameter>は現在廃止されている。そのPPD(特に
	最初に生成したものは、そこで引き続き頻繁に使用される)は、Adobeの仕様に適合して
	いない。Windowsクライアントに<quote>ポイントアンドプリント</quote>でそれらを
	ダウンロード仕様とするときに困難に遭遇するかもしれない。よりよい、かつ
	強力な解決方法は現在提供されている。それは、<parameter>foomatic-rip</parameter>
	と呼ばれる。CUPSでフィルタとして<parameter>foomatic-rip</parameter>を使うために、
	似たようだが異なった行を持つ、新しいタイプのPPDが必要である:
<programlisting>
*cupsFilter: "application/vnd.cups-postscript  0  foomatic-rip"
</programlisting>
	Linuxprinting.orgにあるPPD生成エンジンは修正された。新しいPPDはAdobeの仕様に
	従っている。これらは異なった品質レベル(高解像度の写真、通常の色、グレースケールと
	ドラフトモード)をシングルクリックで、5つまたはそれ以上の異なった選択(メディア
	タイプ、解像度、インク種別とディザリングアルゴリズム)を要求できる新しい方法を
	提供する。ビルトインされた固有のサイズのメディアサポートもある。ジョブの中間で、
	ページ毎に印刷オプションを切り替えることのサポートもある。さらに、最もすばらしい
	ことは、新しい<constant>foomatic-rip</constant>は、印刷時にPPDを使うための
	アクセスに対するサポートを、すべての旧式なスプーラ(LPRng,BSD-LPD, PDQ, PPRなど)
	に対してもシームレスに動作するということである。
	</para>
	</sect2>

	<sect2>
	<title>完全な図解</title>

	<para>
	すべてのフィルタの概要とどのようにそれらが関連するかを知りたい場合、
	パズルの完全な図解はこの章の最後にある。
	</para>
	</sect2>

	<sect2>
	<title><filename>mime.convs</filename></title>

	<para>
	CUPSは与えられたMIMEタイプとインストールされたすべてのプリンタに対する可能な
	すべてのフィルタリングチェーンパスを自動構築する。しかし、どのようにして
	優先するものや特定の選択肢を決めるのであろうか(2つ以上の、同じターゲット
	プリンタに対するフィルタリングチェーンが存在するような場合があるだろう)?
	簡単である。mime-convファイルの3番目のカラム中にある数字に気がついたかも
	しれない。それはこのフィルタに割り当てられている仮想コストを表現している。
	すべての可能なフィルタリングチェーンは全体の<quote>フィルタコスト</quote>
	として集計される。CUPSは最も<quote>コストの小さい</quote>ルートを選ぶ。
	</para>

	<tip><para>
<indexterm><primary>cupsd.conf</primary></indexterm>
<indexterm><primary>FilterLimit</primary></indexterm>
	<filename>cupsd.conf</filename>中で<parameter>FilterLimit 1000</parameter>を
	設定すると、仮想フィルタコストが合計1000を消費するより多く、フィルタが同時に動く
	ことを許可しない。これは適切な<quote>FilterLimit</quote>値を設定することにより
	CUPSサーバの負荷を制限する効率的な方法である。200というFilterLimitの値はおおよそ
	一度に1つのジョブを許可し、FilterLimitを1000にするとおおよそ最大5つのジョブが
	同時に動作する。
	</para></tip>
	</sect2>

	<sect2>
	<title><quote>Raw</quote>印刷</title>

	<para>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>lpadmin</primary></indexterm>
<indexterm><primary>rawprinter</primary></indexterm>
	CUPSに対して任意の<quote>raw</quote>ファイルを印刷(ほとんど)させることが出来る。
	<quote>raw</quote>はフィルタされないことを意味する。CUPSは、プリンタがそれを理解
	できる時に、思い悩まずに<quote>そのまま</quote>プリンタに対してファイルを送る。
	ユーザは賢明なデータ形式のみをそれらに送る事について注意を払う必要がある。raw
	形式の印刷は、もしも<quote><parameter>-o raw</parameter></quote>オプションが
	コマンド行上で指定されたときにどのキューにおいても発生する。任意のPPDを単に関連
	づけない事によってrawのみのキューを設定することも出来る。以下のように行う:
<screen>
&prompt;<userinput>lpadmin -P rawprinter -v socket://11.12.13.14:9100 -E</userinput>
</screen>
	これは、<quote>rawprinter</quote>という<quote>socket</quote>プロトコル
	(別名<quote>HP JetDirect</quote>)経由で接続してポート9100のIPアドレス
	11.12.1.3.14のデバイスに接続するように設定する(もしもこのコマンド行に
	<command>-P /path/to/PPD</command>を付けたPPDを追加したならば、
	<quote>通常の</quote>印刷キューとしてインストールされる。
	</para>

	<para>
	CUPSは、もしもキューに関連づけられるPPDを見いだせない場合、自動的に各ジョブを
	<quote>raw</quote>と見なしてキューに送るように扱う。しかし、CUPSは既知の
	MIMEタイプ(CUPSが持つmime.typesファイルで定義されている)のみを送り、それ以外は
	拒否する。
	</para>
	</sect2>

	<sect2>
	<title>application/octet-stream 印刷</title>

	<para>
<indexterm><primary>/etc/cups/mime.types</primary></indexterm>
<indexterm><primary>application/octet-stream</primary></indexterm>
	<filename>/etc/cups/mime.types</filename>ファイル中にルールがない任意のMIME
	タイプは、unknownか<parameter>application/octet-stream</parameter>と
	見なされ、送信されない。既定値で不明なMIMEタイプの印刷をCUPSが拒否するので、
	Windowsクライアント由来の印刷ジョブが印刷されないということを経験するかも
	しれない。以下のようなエラーメッセージがCUPSログファイル中に見つかるかもしれない:
	</para>

	<para><computeroutput>
	 Unable to convert file 0 to printable format for job
	</computeroutput></para>

	<para>
	<parameter>application/octet-stream</parameter>の印刷を有効にするためには、以下の
	2つのファイルを編集する:
	</para>

	<itemizedlist>
		<listitem><para><filename>/etc/cups/mime.convs</filename></para></listitem>

		<listitem><para><filename>/etc/cups/mime.types</filename></para></listitem>
	</itemizedlist>

	<para>
<indexterm><primary>raw mode</primary></indexterm>
	両方とも<parameter>application/octet-stream</parameter>のためのrawモード操作を
	有効にするためにコメントアウトしなければならないエントリ(それぞれのファイルの
	最後の所)を含む。下記の行が<filename>/etc/cups/mime.types</filename>に存在する
	ようにすること:
	<indexterm><primary>application/octet-stream</primary></indexterm>
<programlisting>
application/octet-stream
</programlisting>
	自動タイプルールセットが指定されていないこの行は、他の行で
	<parameter>application/octet-stream</parameter>のメンバが自動タイプされていない
	限り、全てのファイルを作成する。<filename>/etc/cups/mime.convs</filename>中では
	以下のような行になる:
<programlisting>
application/octet-stream   application/vnd.cups-raw   0   -
</programlisting>
	<indexterm><primary>MIME</primary></indexterm>
	この行はCUPSに、<parameter>application/octet-stream</parameter>上で
	(<quote>-</quote>で示される、何もしない)<emphasis>Null Filter</emphasis>
	を使うことを指示し、<parameter>application/vnd.cups-raw</parameter>として
	結果をタグづける。この最後の部分は、プリンタに接続しファイルを送信するための
	バックエンドに向けてCUPSスケジューラがいつでも今あるファイルを引き渡せるように
	している。
	</para>

	<note><para>
	<filename>mime.convs</filename>と<filename>mime.types</filename>ファイルの編集は
	<quote>raw</quote>印刷を<emphasis>強制せず</emphasis>、それを
	<emphasis>許可する</emphasis>のみである。
	</para></note>

	<formalpara>
	<title>Background</title>

	<para>
<indexterm><primary>security-aware</primary></indexterm>
<indexterm><primary>MIME type</primary></indexterm>
<indexterm><primary>/etc/cups/mime.types</primary></indexterm>
<indexterm><primary>/etc/cups/mime.convs</primary></indexterm>
	そのCUPSは従来のものよりセキュリティに気を払っている印刷システムで、既定値では、
	印刷デバイスに対して手の込んだ(おそらくバイナリ)データを送ることを誰にも許可して
	いない(これは、使用しているプリンタに対してサービス不能攻撃をかける不正使用が
	簡単にでき、少なくとも大量の紙とインクが無駄になることが発生する)。
	<quote>不明な</quote>データはCUPSによって、<emphasis>MIMEタイプ</emphasis>
	<emphasis>application/octet-stream</emphasis>と見なされる。
	<quote>raw</quote>形式でデータを送ることが<emphasis>できる</emphasis>場合、
	それらのMIMEタイプは、CUPSとそれによって許可された、既知のもののどれかでなければ
	ならない。<filename>/etc/cups/mime.types</filename>というファイルはCUPSが
	どのようにMIMEタイプを認識するかの<quote>規則</quote>を定義する。
	<filename>/etc/cups/mime.convs</filename>というファイルはどのファイル変換
	フィルタがそのMIMEタイプに適用されるかを定義する。
	</para>
	</formalpara>
	</sect2>

	<sect2>
	<title>非PostScriptプリンタのためのPostScriptプリンタ記述</title>

	<para>
	<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>非PostScript</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>RIP</primary></indexterm>
<indexterm><primary>Ghostscript</primary></indexterm>
<indexterm><primary>デバイス固有のコマンド</primary></indexterm>
	オリジナルのPPDはPostScriptプリンタのみに使われることを意図していた。それらは
	ジョブファイルを処理する、RIPのためのデバイス固有のコマンドと設定を送るための
	手助けとなる。CUPSはPPDに対するこのスコープを拡張し、非PostScriptプリンタにも
	カバーするようにした。これが標準化されたファイル形式のために、これを行うのは
	難しくない。その方法は論理的でもある:CUPSはPostScriptを取り扱い、ジョブファイルを
	処理するためにPostScript RIP(Ghostscript)を使う。唯一の違いはPostScriptプリンタは
	RIPを内蔵していて、その他のタイプのプリンタはホストコンピュータ上でGhostscript
	のRIPを動かすと言うことである。
	</para>

	<para>
	非PostScriptプリンタに対するPPDはCUPS固有のいくつかの行を持っている。最も
	重要なものは下記と似たようなものである:
	<indexterm><primary>application/vnd.cups-raster</primary></indexterm>
<programlisting>
*cupsFilter: application/vnd.cups-raster  66   rastertoprinter
</programlisting>
	これが CUPS フィルタリングの最後の難所のひとつである。この行では、CUPSデーモンに
	対して、<parameter>rastertoprinter</parameter>を最後のフィルタとして使うように
	設定している。このフィルタは <parameter>application/vnd.cups-raster</parameter>
	というMIMEタイプのファイルが入力の際に用いられることになる。CUPSは指定されたMIME
	タイプを最終的な出力とするようなフィルタのチェインを自動的に生成する。
	次にこれは指定された<parameter>rastertoprinter</parameter>フィルタのための入力と
	なる。最後のフィルタが処理を終えた後(<parameter>rastertoprinter</parameter>は
	Gutenprintフィルタである)、ファイルは、出力デバイスに送信を行うバックエンドに
	送られる。
	</para>

	<para>
	CUPSが提供しているPPDは数少ないが、プリンタモデルは数多くある。異なった紙の
	トレイや指定されたモデルがサポートしているよりもより大きなマージンを取ることが
	出来ないかもしれない。要約は表21.1<link linkend="cups-ppds"></link>を参照。
	</para>

	<table frame="all" id="cups-ppds">
		<title>CUPSに同梱されているPPD</title>
		<tgroup cols="2" align="left">
			<colspec align="left"/>
			<colspec align="justify" colwidth="1*"/>
			<thead><row><entry>PPDファイル</entry><entry>プリンタタイプ</entry></row></thead>
			<tbody>
			<row><entry>deskjet.ppd</entry><entry>古いHP inkjetプリンタとその互換</entry></row>

			<row><entry>deskjet2.ppd</entry> <entry>新しいHP inkjetプリンタとその互換</entry> </row>

			<row><entry>dymo.ppd</entry> <entry>labelプリンタ</entry> </row>

			<row><entry>epson9.ppd</entry> <entry>エプソン9-ピンインパクトプリンタとその互換</entry> </row>

			<row><entry>epson24.ppd</entry> <entry>エプソン 24-ピンインパクトプリンタとその互換</entry> </row>

			<row><entry>okidata9.ppd</entry> <entry>Okidata 9-ピンインパクトプリンタとその互換</entry> </row>

			<row><entry>okidat24.ppd</entry> <entry>Okidata 24-ピンインパクトプリンタとその互換</entry> </row>

			<row><entry>stcolor.ppd</entry> <entry>古いエプソン Stylusカラープリンタ</entry> </row>

			<row><entry>stcolor2.ppd</entry> <entry>新しいエプソン Stylusカラープリンタ</entry> </row>

			<row><entry>stphoto.ppd</entry> <entry>古いエプソン Stylus Photoプリンタ</entry> </row>

			<row><entry>stphoto2.ppd</entry> <entry>新しいエプソン Stylus Photoプリンタ</entry> </row>

			<row><entry>laserjet.ppd</entry> <entry>すべての PCL プリンタ</entry> </row>

			</tbody>
		</tgroup>
	</table>

	</sect2>

	<sect2>
	<title><emphasis>cupsomatic/foomatic-rip</emphasis> 対 <emphasis>ネイティブなCUPS</emphasis>印刷</title>

	<para>
	<indexterm><primary>cupsomatic</primary></indexterm>
	<indexterm><primary>foomatic-rip</primary></indexterm>
	ネイティブなCUPSラスタライズ作業は2つのステップに分かれている:
	</para>

	<itemizedlist>
		<listitem><para>
<indexterm><primary>pstoraster</primary></indexterm>
		最初のものは、<parameter>pstoraster</parameter>ステップである。これは、
		ESP Ghostscript 7.05.xからの特別なCUPSデバイスを、そのツールとして使う。
		<indexterm><primary>ESP</primary><secondary>Ghostscript</secondary></indexterm>
		</para></listitem>

		<listitem><para>
		二番目のものは<parameter>rasterdriver</parameter>ステップである。これは、
		種々のデバイス固有のフィルタを使う。このステップに対して良い品質をもつ
		フィルタを提供するいくつかのベンダがある。それらのいくつかはフリー
		ソフトウェアであり、いくつかはシェアウェアであり、いくつかは商用製品である。
		</para></listitem>
	</itemizedlist>

	<para>
	しばしばこれは、その他の方法よりもより良い品質のものを生成する(そして、
	いくつかのより優位な点がある)。これについては
	<link linkend="cupsomatic-dia">cupsomatic/foomaticの処理対ネイティブなCUPSの図</link>
	に図解がある。
	</para>

	<figure id="cupsomatic-dia">
		<title>cupsomatic/foomaticの処理対ネイティブなCUPSの図</title>
		<imagefile>10small</imagefile>
	</figure>

	<para>
	1つの他の方法は、<parameter>cupsomatic/foomatic-rip</parameter>によるものである。
	<parameter>cupsomatic</parameter>は、決してCUPS開発者によって
	<emphasis>作られたものではない</emphasis>ということに注意。これは、印刷環境に
	対する独立した貢献であり、Linuxprinting.orgの人々によって作られたものである。
	<footnote><para>
	<ulink noescape="1" url="http://www.cups.org/cups-help.html">http://www.cups.org/cups-help.html</ulink></para>を参照。</footnote>
	<parameter>cupsomatic</parameter>はもはや開発、メンテナンス、サポートされいない。
	これは現在 <parameter>foomatic-rip</parameter>によって置き換えられている。
	<parameter>foomatic-rip</parameter>は古い<parameter>cupsomatic</parameter>の
	アイデアを完全に書き換えたものであるが、とても改善され、他の(非CUPS)スプーラに
	対して汎用化されている。 <parameter>foomatic-rip</parameter>へのアップグレードは、
	特にもしも最新バージョンのCUPSにアップグレードするならば強く推奨される。
	</para>

	<para>
	<indexterm><primary>cupsomatic</primary></indexterm>
	<indexterm><primary>foomatic</primary></indexterm>
	古い<parameter>cupsomatic</parameter>のように、(新しい)Linuxprinting.orgが使う
	現代的なGhostscript印刷処理からの<parameter>foomatic-rip</parameter>は、すべてを
	単一のステップで行う。従ってそれはGhostscript中に組み込まれる他のすべての
	デバイスに依存する。他のスプーラでのGhostscriptのレンダリングと同じくらい
	品質は良い(あるいは悪い)。優位点は、この方法は、より最新のCUPSによる方法によって
	(まだ)サポートされていない、たくさんのプリンタモデルをサポートするということで
	ある。
	</para>

	<para>
	もちろん、あるシステムで並列に両方の手法を使うことが出来(もしも異なったキューを
	設定するならば1つのプリンタに対しても)、どれが一番うまく動作するかを見いだせる。
	</para>

	<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>pstoraster</primary></indexterm>
<indexterm><primary>rastertosomething</primary></indexterm>
<indexterm><primary>ラスタライズ</primary></indexterm>
<indexterm><primary>Foomatic/cupsomatic</primary></indexterm>
<indexterm><primary>レンダリング</primary></indexterm>
	<parameter>cupsomatic</parameter>は印刷ファイルを
	<parameter>application/vnd.cups-postscript</parameter>ステージ後に捕まえ、
	システム全体でインストールされたGhostscriptである、CUPS-externalを通してそれを
	横取りする。その結果、印刷ファイルは<parameter>pstoraster</parameter>フィルタ
	をバイパスする(さらにCUPSラスタドライバ<parameter>rastertosomething</parameter>も
	バイパスする)。Gostscriptがラスタライズ処理を終えた後、
	<parameter>cupsomatic</parameter>はレンダリングされたファイルディレクトリをCUPS
	バックエンドに渡す。
	<link linkend="cupsomatic-dia">cupsomatic/foomaticの処理対ネイティブなCUPS</link>
	にはネイティブなCUPSレンダリングと<parameter>Foomatic/cupsomatic</parameter>手法の
	違いについて図解している。
	</para>
	</sect2>

	<sect2>
	<title>フィルタリングチェインの例</title>

	<para>
	以下は、CUPSの動作を図解するための、よくあるフィルタリングチェインの例である。
	</para>

	<para>
<indexterm><primary>HP JetDirect</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>2アップ</primary></indexterm>
<indexterm><primary>両面印刷</primary></indexterm>
	HP JetDirect接続のPostScriptプリンタにPDFファイルを印刷しようとしていることを
	仮定するが、ページ3-5,7と11-13のみを印刷したく、更にそれを<quote>2アップ</quote>
	と<quote>両面印刷</quote>にしたいとする:
	</para>

	<itemizedlist>
	<listitem><para>使用する印刷オプション(要求されたページの選択、2アップ、両面印刷)
	は、コマンドライン上でCUPSに渡される。</para></listitem>

	<listitem><para>(完全な)PDFファイルがCUPSに送られ、
	<parameter>application/pdf</parameter>として自動タイプされる。</para></listitem>

	<listitem><para>その結果ファイルはPostScript MIMEタイプである
	<parameter>application/postscript</parameter>(ここでのプレビューは引き続き
	オリジナルのPDFファイルのすべてのページを表示する)を生成する
	<parameter>pdftops</parameter>prefilterに、最初に渡さねばならない。</para></listitem>

	<listitem><para>ファイルは次にコマンドラインオプションを適用する
	<parameter>pstops</parameter>フィルタに渡される:これはページ2-5,7と11-13を
	選択し、<quote>1枚のページ上に2つのページ</quote>という合成されたレイアウトを
	作成し、正しい<quote>両面印刷</quote>コマンド(プリンタのPPD中で定義されている)
	を、新しいPostScriptファイルに挿入する。ファイルはこの時点でPostScript MIME
	タイプ<parameter>application/vnd.cups-postscript</parameter>となる。</para></listitem>

	<listitem><para>ファイルは、プリンタにジョブを転送する
	<parameter>ソケット</parameter>バックエンドに送られる。</para></listitem>
	</itemizedlist>

	<para>
	フィルタリングチェーンの結果は以下の
	<link linkend="pdftosocket">PDFからソケットへのチェーンの模式図</link>のようになる。
	</para>

<indexterm><primary>pdftosocket</primary></indexterm>
	<figure id="pdftosocket">
		<title>PDFからソケットへのチェーン</title>
		<imagefile>pdftosocket</imagefile>
	</figure>

	<para>
<indexterm><primary>USB</primary></indexterm>
<indexterm><primary>Epson Stylus</primary></indexterm>
<indexterm><primary>stphoto2.ppd</primary></indexterm>
	CUPS<filename>stphoto2.ppd</filename>をインストールした、USB接続の
	Epson Stylus Photo Printerに同じフィルタで印刷したいと仮定しよう。最初の
	いくつかのフィルタリングステージはおおよそ同じである:
	</para>

	<itemizedlist>
		<listitem><para>
		印刷オプション(要求されたページの選択、2アップ、両面印刷)は、
		コマンドラインでCUPSに渡される。
		</para></listitem>

		<listitem><para>
		(完全な)PDFファイルはCUPSに送られて、
		<parameter>application/pdf</parameter>と自動タイプされる。
		</para></listitem>

		<listitem><para>
<indexterm><primary>pdftops</primary></indexterm>
<indexterm><primary>PDF</primary></indexterm>
		ファイルは、最初に、
		PostScript MIMEタイプ<parameter>application/postscript</parameter>を
		生成する<parameter>pdftops</parameter>prefilterに渡されなければならない
		(ここでのプレビューは引き続きオリジナルのPDFのすべてのページを表示する)。
		</para></listitem>

		<listitem><para>
<indexterm><primary>pstops</primary></indexterm>
<indexterm><primary>両面印刷</primary></indexterm>
		ファイルは次にコマンドラインオプションを適用する<quote>pstops</quote>
		フィルタに送られる。ここでページ2-5,7と11-13を選択し、
		<quote>一枚の紙の上に2ページを</quote>合成し、正しい<quote>両面印刷</quote>
		コマンド(おっと、このプリンタとPPDは両面印刷をサポートしていないので、
		このオプションは無視される)を新しいPostScriptファイルに挿入する。
		ファイルはこの時点でPostScript MIMEタイプ
		<parameter>application/vnd.cups-postscript</parameter>となる。
		</para></listitem>

		<listitem><para>
		ファイルは次に<parameter>pstoraster</parameter>ステージに送られ、MIME
		タイプが<parameter>application/cups-raster</parameter>となる。
		</para></listitem>

		<listitem><para>
<indexterm><primary>rastertoepson</primary></indexterm>
		最後に、<parameter>rastertoepson</parameter>フィルタは、その処理を行い
		(プリンタのPPD中で示されるように)、プリンタ固有のラスタデータを生成し、
		ユーザが選択した任意の印刷オプションを、印刷データストリーム中に
		埋め込む。
		</para></listitem>

		<listitem><para>
		ファイルは、ジョブをプリンタに転送する<parameter>usb</parameter>
		バックエンドに送られる。
		</para></listitem>
	</itemizedlist>

	<para>
	フィルタリングチェーンの結果は
	<link linkend="pdftoepsonusb">PDFからUSBチェーンへの模式図</link>のようになる。
	</para>

	<figure id="pdftoepsonusb">
		<title>PDFからUSBチェーン</title>
		<imagefile>pdftoepsonusb</imagefile>
	</figure>
	</sect2>

	<sect2>
	<title>CUPSドライバ/PPDの提供元</title>

	<para>
	インターネット上でたくさんのCUPS-PPDファイルを(それに適したフィルタと一緒に)、
	たくさんの言語環境で、1000以上の非PostScriptモデル用をサポートしているものを
	見つけることが出来る。
	</para>

	<itemizedlist>
		<indexterm><primary>ESP</primary><secondary>Print Pro</secondary></indexterm>
		<indexterm><primary>PrintPro</primary><see>ESP Print Pro</see></indexterm>
		<listitem><para>
		<ulink url="http://www.easysw.com/printpro/">ESP PrintPro</ulink>
		(商用、自由ではない)は、3000以上のPPDをパッケージしていて、
		Linux, Mac OS X, IBM-AIX,HP-UX, Sun-Solaris, SGI-IRIX, Compaq Tru64,
		Digital UNIXと他の商用UNIX上での<quote>外部ドライバ</quote>として使える
		(これは、CUPS開発者それ自身で書かれていて、その売り上げは
		開発者を食べさせるという形で、将来のCUPS開発費用を助ける)。
		</para></listitem>

		<listitem><para>
		<ulink url="http://gimp-print.sourceforge.net/">Gutenprint Project</ulink>
		(GPL、フリーソフトウェア)は140ほどのPPDを提供し(おおよそ400のプリンタを
		サポートしていて、多くは写真品質出力を提供する)、Gutenprint CUPS
		ドライバと共に使われる。
		</para></listitem>

		<listitem><para>
		<ulink url="http://www.turboprint.de/english.html/">TurboPrint </ulink>
		(シェアウェア、自由ではない)は、とても良い品質で、おおよそ、プリンタの数と
		同じくらいのサポートがある。
		</para></listitem>

		<listitem><para>
		<ulink url="http://www-124.ibm.com/developerworks/oss/linux/projects/omni/">OMNI </ulink>
		(LGPL、自由)は、IBMによって作られたパッケージで、現在400以上のプリンタ
		サポートを含み、IBM OS/2のノウハウの遺産をLinux上に移植している
		(CUPSサポートは現在β状態である)。
		</para></listitem>

		<listitem><para>
		<ulink url="http://hpinkjet.sourceforge.net/">HPIJS </ulink> (BSD系のライセンス、自由)
		は、おおよそ150のHP製プリンタをサポートし、優れた印刷品質をも提供する
		(現在Foomaticパス経由でのみ有効)。
		</para></listitem>

		<listitem><para>
		<ulink url="http://www.linuxprinting.org/">Foomatic/cupsomatic </ulink>
		(LGPL、自由)は、Linuxprinting.orgからのもので、(Omni、GunenprintとHPIJS
		を含む)世界中に知られているほとんどすべての各Ghostscriptフィルタ用の
		PPDを提供する。
		</para></listitem>
	</itemizedlist>

	</sect2>

	<sect2>
	<title>インタフェーススクリプトを伴う印刷</title>

	<para>
<indexterm><primary>PCL</primary></indexterm>
<indexterm><primary>lpadmin</primary></indexterm>
	CUPSはまたSystemV AT&amp;T印刷システムからとして知られている
	<quote>interface scripts</quote>の使用もサポートしている。それらはしばしば
	PCL印刷ジョブを生成するアプリケーションから、PCLプリンタにおいて使われる。
	interface scriptsはプリンタモデルに特化している。これらはPostScriptプリンタの
	ためのPPDと同様の役割を持っている。interface scriptsは、たとえば、もしも
	ユーザが特定のペーパートレイを選択したか、紙の方向を変更したかA3用紙を
	しようするような場合、印刷データストリーム中に要求されたESCシーケンスを
	追加してもよい。interface scriptsはLinux領域ではほとんど知られていない。
	HP-UXプラットフォームでは、もう少し使われている。動作する任意の
	interface scriptsをCUPS上で一緒に使うことも可能である。以下のように、
	<command>-i</command>を使ってインストールする:
<screen>
&rootprompt;<userinput>lpadmin -p pclprinter -v socket://11.12.13.14:9100 \
          -i /path/to/interface-script</userinput>
</screen></para>

	<para>
	interface scriptsは多くの人にとって<quote>未知の動物</quote>かもしれない。
	しかし、これは、CUPSと共に使うことで、ある特定の印刷キューに対する、固有の、
	専用として記述した、フィルタリングスクリプトやプログラムを組み込む最も簡単な
	方法を提供する(現代的なinterface scriptsの使い方に関するいくつかの情報は、
	<ulink noescape="1" url="http://playground.sun.com/printing/documentation/interface.html">
        http://playground.sun.com/printing/documentation/interface.html</ulink>にある)。
	</para>
	</sect2>
</sect1>

<sect1>
<title>ネットワーク印刷(Windowsのみ)</title>

<para>
ネットワーク印刷は多くの分野をカバーしている。Windowsクライアントのために印刷するとき
Samba上で何が起こるかを正確に理解するために、まず初めに、Windows NTサーバと共に使う
Windowsクライアントという、<quote>Windowsのみ</quote>の設定を見てみよう。
</para>

<sect2>
<title>WindowsクライアントからNT印刷サーバへ</title>

<para>
WindowsクライアントからNTベースの印刷サーバへの印刷は、2つのオプションがある。
それらは以下の2つである:
<indexterm><primary>GDI</primary></indexterm>
<indexterm><primary>EMF</primary></indexterm>
</para>


<itemizedlist>
	<listitem><para>ドライバをローカルに実行し、GDI出力(EMF)を、使用している
	    プリンタに対するプリンタ固有の形式に描画する。
	</para></listitem>

	<listitem><para>プリンタ固有の出力に描画するためにドライバが実行されたときに、
	    GDI出力(EMF)をサーバに送る。
	</para></listitem>
</itemizedlist>

<para>
両方の印刷パスは
<link linkend="small11">クライアント上での印刷ドライバの実行</link>と
<link linkend="small12">サーバ上での印刷ドライバの実行</link>という
フローチャートで図示されている。
</para>
</sect2>

<sect2>
<title>クライアント上でのドライバの実行</title>

<para>
最初の場合、印刷サーバはraw形式でファイルをスプールせねばならない。これはジョブファイルに
さわらず、何らの方法での変換もしないことを意味する。これは、現代的なUNIXベースの印刷
サーバが同じように行えることでもあり、NT印刷サーバよりもよりよいパフォーマンスとより
信頼性がある。これは、おそらくほとんどのSamba管理者が慣れ親しんでいるものである。この
設定の1つの利点は、この<quote>スプールのみ</quote>の印刷サーバが、UNIX用のドライバがない
場合にも使えるかもしれないと言うことである。これは、有効なWindowsクライアントドライバが
あり、クライアントにインストールされていれば十分である。これは
<link linkend="small11">クライアント上での印刷ドライバの実行ダイアグラム</link>
で図示されている。
</para>

<figure id="small11">
	<title>クライアント上での印刷ドライバの実行</title>
	<imagefile>11small</imagefile>
</figure>

</sect2>

<sect2>
<title>サーバ上でのドライバの実行</title>


<para>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>PCL</primary></indexterm>
<indexterm><primary>ESC/P</primary></indexterm>
<indexterm><primary>EMF</primary></indexterm>
<indexterm><primary>GDI</primary></indexterm>
他のパスはサーバ上でプリンタドライバを実行する。クライアントはサーバにEMF形式で印刷
ファイルを送る。サーバはPostScript, PCL, ESC/Pか他のドライバを、EMFファイルをプリンタ
固有の言語に変換するために使う。同じ事はUNIX上ではできない。現在、プリンタが理解できる
ものに、UNIXサーバ上でWindowsクライアントのGDI出力を変換するプログラムか手法はない。
これは<link linkend="small12">サーバ上での印刷ドライバの実行ダイアグラム</link>で
図示されている。
</para>

	<figure id="small12">
		<title>Print Driver Execution on the Server.</title>
		<imagefile>12small</imagefile>
	</figure>

<para>
しかし、似たようなものはCUPSで可能なので、引き続き読むこと。
</para>
</sect2>
</sect1>

<sect1>
<title>ネットワーク印刷(WindowsクライアントとUNIX/Samba印刷サーバ)</title>

<para>
UNIX印刷サーバがそのプラットフォーム上でWin32プログラムコードを
<emphasis>実行できない</emphasis>ので、絵は若干異なる。しかしながら、
これは、それほど選択権を制限するものではない。それどころか、他では不可能な
印刷機能を実装することができるかもしれない。
</para>

<sect2>
<title>WindowsクライアントからCUPS/Samba印刷サーバへ</title>

<para>
Windowsネットワーク印刷クライアントに対する、CUPSの強力な機能の利点をどのように
利用するかを示す簡単なレシピである:
</para>

<itemizedlist>
	<listitem><para>WindowsクライアントにPostScriptをCUPSサーバに送らせる。
	</para></listitem>

	<listitem><para>CUPSサーバにPostScriptをドライバ固有のラスタフォーマットに変換させる。</para></listitem>
</itemizedlist>

<para>
これは、クライアントにPostScriptドライバ(プリンタが非PostScriptモデルであっても。CUPS
サーバ上でのドライバがあることも要求する)を使うことを要求する。
</para>

<para>
最初に、Samba経由でのCUPSベースの印刷を有効にするため、以下のオプションを&smb.conf;
ファイルの<parameter>[global]</parameter>セクションに設定すべきである:
</para>

<smbconfblock>
<smbconfoption name="printing">cups</smbconfoption>
<smbconfoption name="printcap">cups</smbconfoption>
</smbconfblock>

<para>
これらのパラメータが指定されると、&smb.conf;中の(Sambaそれ自身と同様)、すべての手動設定
した印刷ディレクティブ(たとえば<smbconfoption name="print command"/>か
<smbconfoption name="lppause command"/>)は無視される。その代わりSambaは、SambaがCUPS
ライブラリ(libcups)をサポートするようにコンパイルされているとき、CUPS APIを通してCUPSと
直接やりとりする。他の印刷コマンドが設定されていない場合、印刷は、-orawオプションを
自動的に付けてパススルーする、<emphasis>System V</emphasis>AT&amp;Tコマンドセットを
使う(もし、コンパイル時にCUPSサポートをするようしたSambaサーバで動作するよう、個別に
定義した印刷コマンドを使いたい場合、単に
<smbconfoption name="classicalprinting">sysv</smbconfoption>を使う)。これは
<link linkend="13small">CUPS/Sambaサーバ経由での印刷ダイアグラム</link>で図示されている。
</para>

	<figure id="13small">
		<title>CUPS/Sambaサーバ経由での印刷</title>
		<imagefile>13small</imagefile>
	</figure>
</sect2>

<sect2>
<title>Sambaによるジョブファイルの受け取りとCUPSへの引き渡し</title>

<para>
Sambaはそれ固有のスプールディレクトリ
(<smbconfoption name="path">/var/spool/samba</smbconfoption>に類似したもので設定される)
を、&smb.conf;の<smbconfsection name="[printers]"/>か<smbconfsection name="[printername]"/>
セクション中で<emphasis>使わなければならない</emphasis>。
Sambaは固有スプール空間にジョブを受け取り、CUPSのスプールディレクトリ(CUPSのスプール
ディレクトリは、既定値が<parameter>RequestRoot /var/spool/cups</parameter>である、
<parameter>RequestRoot</parameter>ディレクティブ行で設定される)中に渡す。
CUPSはそのスプールディレクトリのアクセス権限を検査し、毎回の再起動に備えて適切な値に
それをリセットする。
SambaとCUPSで共通のスプール空間を使う例は滅多に見たことがなく、何週間もこの
<quote>問題</quote>と苦闘してきた。
</para>

<para>
WindowsユーザはSambaでのみ認証する(構成されるどんな手段でも)。もしもSambaがCUPSと同じ
ホストで動作しているならば、印刷においては<quote>localhost</quote>のみ許可しなければ
ならない。もしも異なったマシンで動作しているならば、CUPSで印刷できるように、Samba
ホストがアクセス権を得られるようにしておかねばならない。
</para>
</sect2>
</sect1>

<sect1>
<title>ネットワーク PostScript RIP</title>

<para>
この節では、クライアントがCUPS-PPDと一緒にPostScriptドライバを使うようにさせる、サーバの
&smbmdash;設定上でのCUPSフィルタの使い方について議論する。
</para>


<para>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>PCL</primary></indexterm>
<indexterm><primary>PJL</primary></indexterm>
PPDはすべての印刷デバイスオプションを制御できる。もしも、固有のPostScriptプリンタを
持っているならば、&smbmdash;すなわちこれらは通常開発元によって提供される。PPDファイルは
、つねに、Microsoft WindowsまたはApple Mac OSシステム上でのPostScriptプリンタドライバの
コンポーネントである。それらはユーザが選択できる印刷オプション、適切なPostScriptへの
マッピング、対象プリンタ用のPCLあるいはPJLコマンドを含むASCIIファイルである。プリンタ
ドライバGUIダイアログはこれらのオプションを<quote>その場で</quote>ユーザが選択できる、
ボタンとドロップダウンリストに変換する。
</para>

<para>
CUPSは、何らの変換なしに、任意のWindows(NTが推奨される)PostScriptドライバからのPPD
ファイルロードでき、それらのオプションを扱える。印刷オプションのためのWebブラウザ
インタフェース
(<ulink noescape="1" url="http://localhost:631/printers/">http://localhost:631/printers/</ulink>
を選択し、そこにある<guibutton>Configure Printer</guibutton>ボタンをクリック)か、
コマンドラインインタフェース(<command>man lpoptions</command>か、システム上にあるならば、
<command>lphelp</command>を参照)がある。これらはユーザへのPPDオプションを提供出来る
Linux/UNIX上のGUIフロントエンドとは若干異なる。PPDオプションは通常、実際ののPostScript
プリンタ上のPostScript RIPによって評価される事を意味する。
</para>

<sect2>
<title>UNIX上の、非PSプリンタのためのPPD</title>


<para>
<indexterm><primary>PPD</primary></indexterm>
CUPSはそのPPDの使用にあたっては<quote>実際の</quote>PostScriptプリンタだけにに制限
されない。CUPS開発者は非PostScriptプリンタに対してもCUPS-PPDを使って有効なデバイスと
ドライバオプションを記述するPPDコンセプトの範囲を拡張した。
</para>

<para>
CUPSは完全なPostScriptインタプリタ(RIP)を含んでいるため、これは合理的である。RIPは
GhostScriptをベースにしている。これはクライアントからすべてのPostScript(と更に追加で、
その他のファイル形式)を受け取り処理できる。すべてのCUPS-PPDは、キーワード
<parameter>*cupsFilter</parameter>で始まる追加の行を含んでいると非PostScriptプリンタに
ギアを切り替える。この行はCUPS印刷システムに、受け取ったPostScriptを解釈するための
プリンタ固有のフィルタを使うように告げる。そのため、そのプリンタに対してPostScript RIP
として振る舞うことが出来るため、そのクライアントに対してPostScriptデバイスとしてその
すべてのプリンタを見せるようにし、受け取ったPostScriptコードを適切なラスタ印刷形式に
処理する。
</para>
</sect2>

<sect2>
<title>Windows上の非PostScriptプリンタのためのPPD</title>

<para>
<indexterm><primary>PPD</primary></indexterm>
CUPS-PPDは、<quote>core</quote>PostScriptドライバの一番上として、Windowsクライアント
上でも使用できる(現在推奨はWindows NT/200x/XP用のCUPS PostScriptドライバで、
制限付きだがAdobeのものも使う事が出来る)。この機能は他のスプーラが出来ないいくつかの
トリックを行う事が出来る:
CUPS-PPDs can also be used on Windows clients, on top of a <quote>core</quote> PostScript driver (now
recommended is the CUPS PostScript Driver for Windows NT/200x/XP; you can also use the Adobe one, with
limitations). This feature enables CUPS to do a few tricks no other spooler can do:
</para>

<itemizedlist>
	<listitem><para>
	統一した方法で、すべてのクライアントプラットフォームから、ネットワーク対応の
	印刷ファイルを扱うPostScript RIPとして振る舞う。
	</para></listitem>

	<listitem><para>
	すべてのファイルがpstopフィルタを通し、その結果<filename>page_log</filename>に
	記録されるため、CUPSの集中アカウント件請求サーバとして振る舞う。
	<emphasis>注意:</emphasis>これは、常時定義毎にフィルタなしが存在するため、
	<quote>raw</quote>印刷ジョブでは該当しない。
	</para></listitem>

	<listitem><para>
	たくさんの異なった対象プリンタがあっても、クライアントが、単一のPostScript
	ドライバに集約することが出来るようになる。
	</para></listitem>
</itemizedlist>

<para>
Windowsクライアント上のCUPS PPDを使うと、すべての印刷ジョブ設定をUNIXクライアントが
出来るように制御する事が出来るようになる。
</para>
</sect2>
</sect1>

<sect1>
<title>CUPSクライアントとしてのWindowsターミナルサーバ (WTS)</title>

<para>
この設定は、WTS環境で大きな問題を体験している人にとって、特別な興味を引くかもしれない。
WTSはしばしば、そのクライアントの数多くのプリンタモデルを動かすために､多数の非PostScript
プリンタドライバをインストールする必要がある。これはしばしば非常に不安定性を増大させる。
</para>

<sect2>
<title><quote>カーネルモード</quote>でのプリンタドライバの実行は多くの問題を引き起こす</title>

<para>
<quote>カーネルモード</quote>で動作するWindows NTプリンタドライバは、ドライバが安定せず、
よくテストされていない場合には、システムの安定性にとって高いリスクとなる。そして、できの
悪いドライバはたくさんあるのである!特に、悪名高いものは、ジョブの終了時にサウンドカード
経由でユーザに通知を行う追加のサウンドモジュールが動くものを持っているPCLドライバが例で
ある。通常使っていて、<quote>ブルースクリーン</quote>をこれが出してしまうと言うことを言う
必要があるだろうか?
</para>

<para>
PostScriptドライバは一般的によくテストされている。カーネルモードで動作したとしても、
それらが何かの問題を引き起こすことは知られていない。これは2つの異なったPostScript
ドライバが現在存在しているという事によるのかもしれない。1つはAdobeのものであり、もう1つは
Microsoftのものである。両方ともよくテストされ、Windows上で想像できるように安定している。
CUPSドライバはマイクロソフトのもの由来である。
</para>
</sect2>

<sect2>
<title>Workarounds Impose Heavy Limitations</title>

<para>
回避方法として、サイト管理者は、WTS上にインストールされる許可されたドライバを、1つの
汎用PCLと1つのPostScriptドライバだけに制限するという方針を選んだ。しかしこれは、
クライアントが使う事が出来るたくさんの印刷オプションを制限することになる。
異なったドライバによって制御される場合、そのデバイスはより良い動作が出来るはずが、
しばしば、1つの標準ペーパトレイでの単純な印刷よりも複雑なことが出来なくなる!
</para>
</sect2>

<sect2>
<title>CUPS: A <quote>Magical Stone</quote>?</title>

<para>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
PostScriptドライバを使い、CUPS-PPDを有効にすることは、すべてのこれらの欠点を解決する
とてもエレガントな方法に見える。これらは使用するWindows OSバージョンに依存する、最大3つの
異なったドライバ、すなわちAdobe、MicrosoftとCUPS PostScriptドライバが現在有効である。
WTS上で大きな安定性の問題を引き起こすことは、上記3つのどれも知られていない(たとえ、
たくさんの異なったPPDを使ったとしても)。クライアントは(再度)ペーパトレイ、両面印刷や
その他の設定を選択できる。しかし、確かな代価もある:そのクライアントに対して、CUPSサーバは
PostScript RIPとして振る舞い、<quote>raw スプール</quote>デバイスとして振る舞うよりも
よりCPUとメモリを必要とする。更に、この設定は、最初のフィードバックがとても有望ではあるが、
広範囲にはテストされていない。
</para>
</sect2>

<sect2>
<title>カーネルモードでもPostScriptドライバは大きな問題はない</title>

<para>
<indexterm><primary>DDK</primary></indexterm>
<indexterm><primary>W32X86</primary></indexterm>
<indexterm><primary>PostScript</primary></indexterm>
<indexterm><primary>Visual Studio</primary></indexterm>
<indexterm><primary>Microsoft driver</primary></indexterm>
<indexterm><primary>Adobe</primary></indexterm>
最近のW200xとXPプリンタドライバでは、Windows NTと違い、もはやカーネルモードでは動かない。
しかし、両OSは引き続き、カーネルモードで動作するドライバを使える
(サブディレクトリ<quote>W32X86</quote>中の<quote>2</quote>にあるドライバは
<quote>古い</quote>ものか...........)
以前に説明したように、AdobeはMicrosoft PostScriptドライバのように安定している。CUPS
ドライバはMicrosoft由来である。こうなる簡単な理由がある。(Visual Studioのライセンス者に
対しては無償で使える)Windows NT用の、MicrosoftのDDK(Device Development Kit)は、
Microsoftのドライバのソースコードが含まれ、Visual Studioのライセンス者は固有のドライバ
開発作業にそれを使用し、変更する事が許可されている。これが、CUPS開発者が行った理由
である。ライセンスはソースコード全体を公開することは許可していない。しかし、GPL
配下で<quote>差分</quote>をリリースしているので、もしも
<quote>MS DDK for Windows NT,</quote>の所有者であれば、ドライバを自分自身で調べる事が
出来る。
</para>
</sect2>
</sect1>

<sect1>
<title>ドライバダウンロードを行うためのCUPSの設定</title>

<para>
前に説明したように、ダウンロードのためにSambaサーバ上でクライアントプリンタドライバを
準備するためと、Windowsワークステーションの利便性のためのポイントアンドプリントのための、
すべての以前に知られている方法も、CUPS上で動作する。これらの方法は
<link linkend="classicalprinting">旧式の印刷サポート</link>で説明されている。実際は、
これは真のSambaビジネスで、Samba-Windowsクライアントの連携にのみ関連している。
</para>

<sect2>
<title><emphasis>cupsaddsmb</emphasis>: 不明なユーティリティ</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<parameter>cupsaddsmb</parameter>ユーティリティ(現在すべてのCUPSバージョンに同梱)は、
Sambaの<smbconfsection name="[print$]"/>共有中に、プリンタドライバを転送する別の解で
ある。思い出してほしいのは、この共有は、クライアントが、ドライバが配布されると期待
し、ダウンロードとインストールのためにセットアップする場所であるということである。
これは、とても簡単に、任意の(か全部の)インストールされたCUPSプリンタの共有が出来るように
なる。<command>cupsaddsmb</command>は、Adobe PostScriptドライバを、最近開発された
Windows NT/200x/XP用のCUPS PostScriptドライバと同様に使うことが出来る。
<parameter>cupsaddsmb</parameter>は、ベンダプリンタドライバと一緒に
<emphasis>動作することはできず</emphasis>、そのマニュアルページ中に名前がある
ドライバと<emphasis>同じもののみ</emphasis>動作する。
</para>

<para>
CUPSプリンタドライバはCUPSダウンロードサイトにある。そのパッケージ名は
<filename>cups-samba-[version].tar.gz</filename>である。これには以下のような数多くの
利点があるので、Adobeドライバよりも好まれる:
</para>

<itemizedlist>
	<listitem><para>より正確なページ印刷情報をサポートする。</para></listitem>

	<listitem><para>すべてのプリンタで、バナーページとページラベルをサポートする。</para></listitem>

	<listitem><para>数多くのジョブのIPP属性の設定をサポートする
	    (たとえば、ジョブの優先度、ページラベルとジョブの費用請求など)</para></listitem>
</itemizedlist>

<para>
しかし、現在Windows NT,2000とXPのみがCUPSドライバによってサポートされている。もしも、
Windows95、98とMEクライアントのサポートが必要ならば、Adobe Driverのそれぞれの部分を
入手する事も必要である。
</para>
</sect2>

<sect2>
<title><command>cupsaddsmb</command>用の&smb.conf;の準備</title>

<para>
<command>cupsaddsmb</command>を走らせる前に、
<link linkend="cupsadd-ex">cupsaddsmb使用のための&smb.conf;</link>で示されるように、
&smb.conf;を設定する必要がある。
</para>

<example id="cupsadd-ex">
<title>cupsaddsmb使用のためのsmb.conf</title>
<smbconfblock>
<smbconfsection name="[global]"/>
<smbconfoption name="load printers">yes</smbconfoption>
<smbconfoption name="printing">cups</smbconfoption>
<smbconfoption name="printcap name">cups</smbconfoption>

<smbconfsection name="[printers]"/>
<smbconfoption name="comment">All Printers</smbconfoption>
<smbconfoption name="path">/var/spool/samba</smbconfoption>
<smbconfoption name="browseable">no</smbconfoption>
<smbconfcomment>setting depends on your requirements</smbconfcomment>
<smbconfoption name="guest ok">yes</smbconfoption>
<smbconfoption name="writable">no</smbconfoption>
<smbconfoption name="printable">yes</smbconfoption>
<smbconfoption name="printer admin">root</smbconfoption>
 <smbconfsection name="[print$]"/>
<smbconfoption name="comment">Printer Drivers</smbconfoption>
<smbconfoption name="path">/etc/samba/drivers</smbconfoption>
<smbconfoption name="browseable">yes</smbconfoption>
<smbconfoption name="guest ok">no</smbconfoption>
<smbconfoption name="read only">yes</smbconfoption>
<smbconfoption name="write list">root, @smbprintadm</smbconfoption>
</smbconfblock>
</example>
</sect2>

<sect2>
<title>Windows NT/200x/XP用のCUPS<quote>PostScript Driver</quote></title>

<para>
<indexterm><primary>PostScript</primary></indexterm>
CUPSユーザは
<ulink noescape="1" url="http://www.cups.org/software.html">http://www.cups.org/software.html</ulink>
から正確に同じパッケージを入手できる。これは、CUPSベースのソフトウェアファイルから
分離されたパッケージで、CUPS 1.1.x Windows NT/200x/XP Printer Driver for Samba (tar.gz,192k)
とタグづけられている。ダウンロードするファイル名は<filename>cups-samba-1.1.x.tar.gz</filename>
である。tar.gzファイルを解凍後、以下のファイルが展開される:
<screen>
&rootprompt;<userinput>tar xvzf cups-samba-1.1.19.tar.gz</userinput>
cups-samba.install
cups-samba.license
cups-samba.readme
cups-samba.remove
cups-samba.ss
</screen></para>

<para>
<indexterm><primary>ESP</primary><secondary>meta packager</secondary></indexterm>
<indexterm><primary>EPM</primary><see>ESP meta packager</see></indexterm>
これらはESPメタパッケージャソフトウェアEPMでパッケージ化されている。
<filename>*.install</filename>と<filename>*.remove</filename>ファイルは簡単なシェル
スクリプトで、<filename>*.ss</filename>のtarファイルを展開したものである
(<filename>*.ss</filename>は、<quote>tar</quote>によって回答できる、tarアーカイブ
以外の何者でもない)。次に、これは内容物を<filename>/usr/share/cups/drivers/</filename>に
置く。この内容物は以下のファイルを含む:
<screen>
&rootprompt;<userinput>tar tv cups-samba.ss</userinput>
cupsdrvr.dll
cupsui.dll
cups.hlp  
</screen></para>

<para>
<parameter>cups-samba.install</parameter>シェルスクリプトは簡単に扱える:
<screen>
&rootprompt;<userinput>./cups-samba.install</userinput>
[....]
Installing software...
Updating file permissions...
Running post-install commands...
Installation is complete.       
</screen></para>

<para>
スクリプトは<filename>/usr/share/cups/drivers/</filename>ディレクトリ中に
ドライバファイルを自動的に置く:
<screen>
&rootprompt;<userinput>cp /usr/share/drivers/cups.hlp /usr/share/cups/drivers/</userinput>
</screen></para>

<warning><para>
バグのために、ある最近のCUPSリリースでは、<filename>cups.hlp</filename>ドライバファイルを
<filename>/usr/share/cups/drivers/</filename>の代わりに
<filename>/usr/share/drivers/</filename>中に置いてしまう。これを直すためには、
手動で正しい場所にファイルをコピー/移動する(<command>./cups-samba.install</command>
スクリプト実行後)。
</para></warning>

<para>
<indexterm><primary>DDK</primary></indexterm>
この新しいCUPS PostScriptドライバは現在バイナリのみである。しかし、無料で使える。
(まだ)完全なソースコードは提供されていない。その理由は、Microsoft DDKの手助けを得て
Microsoft Visual Studio 6でコンパイルしつつ、開発されているからである。ドライバ開発者は
フリーソフトウェアとしてソースコード全体を配布する許可を得ていない。しかし、CUPS開発者は
GPL配下でソースコードの<quote>差分</quote>をリリースしているので、Visual StudioとDDK
のライセンスを持つ人は誰でも自分自身でコンパイルすることが出来る。
</para>
</sect2>

<sect2>
<title>異なったドライバファイルの認識</title>

<para>
CUPSドライバは古いWindows 95/98/Meをサポートせず、Windows NT/2000/XPクライアントのみサポートする。
</para>

<para>Windows NT, 2000と XPは以下でサポートされる:</para>

<itemizedlist>
	<listitem><para>cups.hlp</para></listitem>
	<listitem><para>cupsdrvr.dll</para></listitem>
	<listitem><para>cupsui.dll</para></listitem>
</itemizedlist>

<para>
古いWindows 95/98/MeのためのAdobeドライバはWindows NT/2000/XPクライアントと
同じように提供されている。ファイルの組み合わせは異なったプラットフォームでは
異なる。
</para>

<para>Windows 95, 98と MEは以下でサポートされる:</para>

<itemizedlist>
	<listitem><para>ADFONTS.MFM</para></listitem>
	<listitem><para>ADOBEPS4.DRV</para></listitem>
	<listitem><para>ADOBEPS4.HLP</para></listitem>
	<listitem><para>DEFPRTR2.PPD</para></listitem>
	<listitem><para>ICONLIB.DLL</para></listitem>
	<listitem><para>PSMON.DLL</para></listitem>
</itemizedlist>

<para>Windows NT, 2000, と XPは以下でサポートされる:</para>

<itemizedlist>
	<listitem><para>ADOBEPS5.DLL</para></listitem>
	<listitem><para>ADOBEPSU.DLL</para></listitem>
	<listitem><para>ADOBEPSU.HLP</para></listitem>
</itemizedlist>

<note><para>
<indexterm><primary>Adobeドライバファイル</primary></indexterm>
もしも、Windows NT/2000/XPサポート用の、AdobeドライバファイルとCUPSドライバファイルの
両方がサーバ上に現在インストールされているならば、Adobeファイルは無視されCUPSファイルが
使われる。もしも理由がなんであれ、Adobeのみのドライバを使いたいと思うのであれば、3つの
CUPSドライバをどこかに移動すること。Windows 9x/Meクライアントはどんな場合にもAdobeの
ドライバを使う。
</para></note>
</sect2>

<sect2>
<title>ドライバファイルの入手</title>

<para>
Adobeドライバファイルの入手は、多くのユーザにとって予想外に難しいように見える。それらは
Adobe Webサイトに1つのファイルとして見えているわけではなく、自己解凍か自動インストールを
行うWindows-.exeファイルを見つけるのも難しい。おそらく内蔵されたネイティブな
インストーラを使用しなければならず、クライアント上で一回はインストールプロセスを動かす
ことが必要である。これは、クライアント上ローカルにドライバ(と1つの汎用PostScriptプリンタ)
をインストールする。それらがインストールされた後、汎用PostScriptプリンタを共有する。
この作業後、クライアントの<smbconfsection name="[print$]"/>共有は、CUPSホストから
smbclientで入手可能なAdobeファイルを保持する。
</para>
</sect2>

<sect2>
<title>Windows NT/200x/XP用のESP Print Pro PostScriptドライバ</title>

<para>
<indexterm><primary>ESP</primary><secondary>Print Pro</secondary></indexterm>
ESP Print ProソフトウェアのユーザはAdobe PostScriptドライバの代替として、ESCプリント
ドライバパッケージをインストールすることが出来る。これを行うために、
<ulink noescape="1" url="http://www.easysw.com/software.html">Easy Software</ulink>
Webサイトで、ESC Print Proソフトウェアの通常のダウンロード領域からドライバファイルを
検索できる。<guilabel>Download Printer Drivers for ESP Print Pro 4.x</guilabel>
領域の間で<quote>SAMBA</quote>と名前が付いたリンクを探し、パッケージをダウンロード
する。一度インストールすると、Printer Manager GUI中の中のメニューの、
<guilabel>Export Driver...</guilabel>を選択して、プリンタを単にハイライトさせる
ことによって任意のドライバを準備できる。もちろん、ドライバファイルを扱うために、
あらかじめ準備されたSambaが必要である。すなわち、<smbconfsection name="[print$]"/>
共有を設定することなどである。ESP Print ProパッケージにはWindows 95/98/Me
クライアントファミリ用の(ライセンスされた)Adobeドライバ一式と同様にCUPSドライバ
ファイルが含まれている。
</para>
</sect2>

<sect2>
<title>考慮すべき警告</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>cups.hlp</primary></indexterm>
<indexterm><primary>WIN40</primary></indexterm>
<indexterm><primary>W32X86</primary></indexterm>
一度インストールスクリプト(と、<filename>/usr/share/cups/drivers/</filename>への
<filename>cups.hlp</filename>ファイルの手動での移動)を実行すると、ドライバはSambaの
<smbconfsection name="[print$]"/>共有(これはしばしば
<filename>/etc/samba/drivers/</filename>にマップされ、<emphasis>WIN40</emphasis>と
<emphasis>W32X86</emphasis>という枝を持つサブディレクトリを含む)中に、ドライバが
配置できるようになる。これは、<command>cupsaddsmb</command>を動かすことによって
行える(CUPSリリース1.1.16以降では<command>man cupsaddsmb</command>も参照)。
</para>

<tip><para>
<indexterm><primary>シングルサインオン</primary></indexterm>
<indexterm><primary>ドメインコントローラ</primary></indexterm>
<command>smbpasswd</command>を動かしてrootをsmbpasswdファイル中に格納する必要が
あるかもしれない。もしも、全体の手順を最初に動かすときに、これは、特に重要であり、
Windowsドメインコンピュータでの<emphasis>シングルサインオン</emphasis>用にすべてが
設定されている環境中では動かない。
</para></tip>

<para>
いったんドライバファイルが<smbconfsection name="[print$]"/>共有に置かれ、初期化
されると、それらはダウンロード可能になり、Windows NT/200x/XPクライアントによって
インストールされる。
</para>

<note><para>
Windows 9x/MeクライアントはCUPS PostScriptドライバでは動かない。それらには
前述の通り、<filename>ADOBE*.*</filename>ドライバを使うことが引き続き必要である。
</para></note>

<note>
<para>
もしも、<filename>/usr/share/cups/drivers/</filename>ディレクトリ中に以前の
インストールによる<filename>ADOBE*.*</filename>ドライバファイルが引き続きあるならば、
それは無害である。
</para></note>

<note><para>
<indexterm><primary>"Printers" フォルダ</primary></indexterm>
<indexterm><primary>Adobe PostScript</primary></indexterm>
使用しているWindowsクライアントが、Adobe PostScriptドライバ用の古い
<filename>ADOBE*.*</filename>ファイルがインストールされていると、新しい
Windows NT/200x/XP用のCUPS PostScriptドライバのダウンロードとインストールは最初に失敗する。
最初にクライアントから古いドライバを消し去る必要がある。もしも、プリンタを再インストール
しようとしたときのために、ドライバファイルはクライアントによって引き続き保存され、
再利用されることによりプリンタを<quote>削除</quote>するだけでは十分ではない。
クライアント上のAdobeドライバファイルを完全に取り除くためには、まず
<guilabel>プリンタフォルダ</guilabel>を開き(おそらく
<guilabel>スタート -> 設定 -> コントロールパネル ->プリンタ</guilabel>)、
フォルダの背景を右クリックし、<guilabel>ドライバ</guilabel>タブを選択する。
一覧表示上で削除したいドライバを選択し、<guilabel>削除</guilabel>ボタンをクリックする。
これは1つも特定のドライバを使うプリンタが残っていないときに動作する。まず初めに
<guilabel>プリンタ</guilabel>フォルダ中でこのドライバを使うすべてのプリンタを
<quote>削除</quote>する必要がある。これを行うには管理者権限が必要である。
</para></note>

<note><para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<indexterm><primary>CUPS PostScript</primary></indexterm>
一度クライアントにCUPS PostScriptドライバをダウンロードすると、
<link linkend="classicalprinting">旧式の印刷サポート</link>で説明したような手続きで、
すべてのプリンタを簡単に切り替えることが出来る。
<guilabel>プリンタのプロパティ</guilabel>ダイアログを動かすことか、
<command>setdriver</command>サブコマンドを指定した<command>rpcclient</command>
を使うことのどちらかで、存在するプリンタのドライバを切り替えられる。
</para></note>
</sect2>

<sect2>
<title>WindowsのCUPS PostScriptドライバ対Adobeドライバ</title>

<para>
CUPSとAdobe PostScriptドライバの比較に興味があるだろうか?我々の目的のために、
Are you interested in a comparison between the CUPS and the Adobe PostScript drivers? For our purposes, these
are the most important items that weigh in favor of CUPS:
</para>

<itemizedlist>
	<listitem><para>Adobe EULAに縛られない。</para></listitem>

	<listitem><para><quote>ADOBE*.*ドライバファイルをダウンロードできる所はどこか?</quote>
        という質問に縛られない。</para></listitem>

	<listitem><para>
	<indexterm><primary>PJL</primary></indexterm>
	Adobe ドライバ(sれに関連するプリンタのPPD要求において)はしばしば印刷ファイルの
	メイン部分の先頭にPJLヘッダを置く。そのため、印刷ファイルは
	<parameter>%!PS</parameter>の代わりに<parameter>&lt;1B&gt;%-12345X</parameter>か
	<parameter>&lt;escape&gt;%-12345X</parameter>で始まる。これはCUPSデーモンが入力
	ファイルを印刷可能なファイルと自動タイプすることをさせるようにし、
	<parameter>pstops</parameter>フィルタ経由で初期化しない(もう少し技術的に言うと、
	これは一般的なMIMEタイプ
	<indexterm><primary>application/postscript</primary></indexterm>
	<parameter>application/postscript</parameter>と見なされないが、より特別な
	MIMEタイプである
	<indexterm><primary>application/cups.vnd-postscript</primary></indexterm>
        <parameter>application/cups.vnd-postscript</parameter>とみなす)ので、
	<parameter>/var/log/cups/page_log</parameter>中におけるページの計数は正確な
	ページ数を受け取れない。その代わりに標準的な設定では、ダミーのページ数
	<quote>1</quote>が記録される。
	</para></listitem>

	<listitem><para>Adobeドライバは、それによって生成するPostScriptを間違って
	設定するいくつかのオプションがある
<indexterm><primary>Adobe driver</primary></indexterm>
	(CUPSがそれを処理することが出来ないようにしてしまう、
	<guilabel>Optimize for Speed</guilabel>を、
	<guilabel>Optimize for Portability</guilabel>の代わりに、うっかりして
	設定してしまう)。</para></listitem>

	<listitem><para>WindowsクライアントによるCUPSサーバへのCUPS PostScriptドライバの
	出力は、汎用MIMEタイプ<parameter>application/postscript</parameter>として
<indexterm><primary>CUPS PostScriptドライバ</primary></indexterm>
	自動タイプされ、CUPS <parameter>pstops</parameter>フィルタに渡され、会計と
	quota目的のために<filename>page_log</filename>中に正しいページ数を記録する。
	</para></listitem>

	<listitem><para>
	<indexterm><primary>バナーページ</primary></indexterm>
	CUPS PostScriptドライバは、Windows NT/200x/XPクライアントによる、追加の標準(IPP)
	印刷オプションを送信することをサポートする。そのような追加印刷オプションは、
	CUPS標準<emphasis>バナーページ</emphasis>(かカスタムなもので、ドライバは
	ダウンロード時点でインストールされるべき)と名前を付けられ、CUPSページラベル
	オプションを使い、ジョブのプライオリティを設定し、(将来、追加の便利な
	IPPジョブ属性をサポートするオプションで)印刷予定時間を設定する。
	</para></listitem>

	<listitem><para>CUPS PostScriptドライバは、PostScriptファイルの先頭に、新しい
	<parameter>*cupsJobTicket</parameter>コメントの挿入をサポートする
	(これは、将来、すべての種類のCUPS上での便利な拡張のために使われるが、
	これがコメントとして扱われ、単に無視されるため、任意の他の
	アプリケーションのじゃまをしない)。</para></listitem>

	<listitem><para>CUPS PostScriptドライバは、近々リリースされる、
	Windows NT/200x/XP用の完全なCUPS IPPクライアントの心臓部である
	(おそらく最初のCUPS 1.2のβリリースと一緒に)。</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>cupsaddsmbの実行(Quiet Mode)</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>ポイントアンドプリント</primary></indexterm>
<command>cupsaddsmb</command>コマンドは、必要とされるファイルを
<smbconfsection name="[print$]"/>共有にコピーする。さらに追加で、このプリンタに関連
づけられているPPDは、<filename>/etc/cups/ppd/</filename>から
<smbconfsection name="[print$]"/>にコピーされる。これらファイルはポイントアンドプリント
経由でWindowsクライアントのインストールの都合のために待機している。コマンドを
正しく実行できる前に、Sambaに対して認証を行っておく必要がある。小さなネットワーク
環境では、おそらくユーザレベルのセキュリティ
(<smbconfoption name="security">user</smbconfoption>)を使っているだろう。
</para>

<para>
以下は、正しく動く<command>cupsaddsmb</command>コマンドの例である:
<indexterm><primary>banner pages</primary></indexterm>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<screen>
&rootprompt;<userinput>cupsaddsmb -U root infotec_IS2027</userinput>
Password for root required to access localhost via Samba: <userinput>['secret']</userinput>
</screen></para>

<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<emphasis>すべての</emphasis>プリンタとドライバを共有するために、プリンタ名の代わりに
<option>-a</option>パラメータを使う。<command>cupsaddsmb</command>がプリンタドライバを
Sambaに<quote>エクスポート</quote>してから、CUPSドライバに関連づけられているキュー
のみ動作することは明白になるべきである。
</para>
</sect2>

<sect2>
<title>詳細な結果を表示するcupsaddsmbの実行</title>


<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
おそらく何が起きているかを見たいのだと思う。より詳細な出力は、<option>-v</option>
パラメータを使う。可読性向上のために下記の出力には手を入れてある。
すべての行末の<quote>\</quote>は手動で入れてあり、そのほかにインデントもしている:
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>cupsaddsmb -U root -v infotec_2105</userinput>
Password for root required to access localhost via &example.server.samba;:
Running command: smbclient //localhost/print\$ -N -U'root%secret' \
    -c 'mkdir W32X86; \
    put /var/spool/cups/tmp/3e98bf2d333b5 W32X86/infotec_2105.ppd; \
	put /usr/share/cups/drivers/cupsdrvr.dll W32X86/cupsdrvr.dll; \
    put /usr/share/cups/drivers/cupsui.dll W32X86/cupsui.dll; \
    put /usr/share/cups/drivers/cups.hlp W32X86/cups.hlp'
added interface ip=10.160.51.60 bcast=10.160.51.255 nmask=255.255.252.0
Domain=[CUPS-PRINT] OS=[UNIX] Server=[Samba 2.2.7a]
NT_STATUS_OBJECT_NAME_COLLISION making remote directory \W32X86
putting file /var/spool/cups/tmp/3e98bf2d333b5 as \W32X86/infotec_2105.ppd
putting file /usr/share/cups/drivers/cupsdrvr.dll as \W32X86/cupsdrvr.dll
putting file /usr/share/cups/drivers/cupsui.dll as \W32X86/cupsui.dll
putting file /usr/share/cups/drivers/cups.hlp as \W32X86/cups.hlp
  
Running command: rpcclient localhost -N -U'root%secret' 
   -c 'adddriver "Windows NT x86"   \
   "infotec_2105:cupsdrvr.dll:infotec_2105.ppd:cupsui.dll:cups.hlp:NULL: \
    RAW:NULL"'
cmd = adddriver "Windows NT x86" \
   "infotec_2105:cupsdrvr.dll:infotec_2105.ppd:cupsui.dll:cups.hlp:NULL: \
	RAW:NULL"
Printer Driver infotec_2105 successfully installed.
  
Running command: smbclient //localhost/print\$ -N -U'root%secret' \
-c 'mkdir WIN40; \
    put /var/spool/cups/tmp/3e98bf2d333b5 WIN40/infotec_2105.PPD; \
	put /usr/share/cups/drivers/ADFONTS.MFM WIN40/ADFONTS.MFM;   \
    put /usr/share/cups/drivers/ADOBEPS4.DRV WIN40/ADOBEPS4.DRV; \
    put /usr/share/cups/drivers/ADOBEPS4.HLP WIN40/ADOBEPS4.HLP; \
    put /usr/share/cups/drivers/DEFPRTR2.PPD WIN40/DEFPRTR2.PPD; \
	put /usr/share/cups/drivers/ICONLIB.DLL WIN40/ICONLIB.DLL; \
	put /usr/share/cups/drivers/PSMON.DLL WIN40/PSMON.DLL;'
  added interface ip=10.160.51.60 bcast=10.160.51.255 nmask=255.255.252.0
  Domain=[CUPS-PRINT] OS=[UNIX] Server=[Samba 2.2.7a]
  NT_STATUS_OBJECT_NAME_COLLISION making remote directory \WIN40
  putting file /var/spool/cups/tmp/3e98bf2d333b5 as \WIN40/infotec_2105.PPD
  putting file /usr/share/cups/drivers/ADFONTS.MFM as \WIN40/ADFONTS.MFM
  putting file /usr/share/cups/drivers/ADOBEPS4.DRV as \WIN40/ADOBEPS4.DRV
  putting file /usr/share/cups/drivers/ADOBEPS4.HLP as \WIN40/ADOBEPS4.HLP
  putting file /usr/share/cups/drivers/DEFPRTR2.PPD as \WIN40/DEFPRTR2.PPD
  putting file /usr/share/cups/drivers/ICONLIB.DLL as \WIN40/ICONLIB.DLL
  putting file /usr/share/cups/drivers/PSMON.DLL as \WIN40/PSMON.DLL
  
  Running command: rpcclient localhost -N -U'root%secret' \
   -c 'adddriver "Windows 4.0"      \
   "infotec_2105:ADOBEPS4.DRV:infotec_2105.PPD:NULL:ADOBEPS4.HLP: \
   PSMON.DLL:RAW:ADOBEPS4.DRV,infotec_2105.PPD,ADOBEPS4.HLP,PSMON.DLL, \
    ADFONTS.MFM,DEFPRTR2.PPD,ICONLIB.DLL"'
	cmd = adddriver "Windows 4.0" "infotec_2105:ADOBEPS4.DRV:\
	infotec_2105.PPD:NULL:ADOBEPS4.HLP:PSMON.DLL:RAW:ADOBEPS4.DRV,\
	infotec_2105.PPD,ADOBEPS4.HLP,PSMON.DLL,ADFONTS.MFM,DEFPRTR2.PPD,\
	ICONLIB.DLL"
  Printer Driver infotec_2105 successfully installed.
  
  Running command: rpcclient localhost -N -U'root%secret'  \
   -c 'setdriver infotec_2105 infotec_2105'
  cmd = setdriver infotec_2105 infotec_2105
  Successfully set infotec_2105 to driver infotec_2105.
</screen></para>

<warning><para>
出力結果上ではSambaアカウントのためのrootパスワードが表示されている。
</para></warning>

<para>
もし、しっかり見た場合、ネットワーク上で暗号化されていないrootパスワードが転送されて
いることを発見するはずなので、注意するように。また、もしもさらによく見てみると、
出力中にNT_STATUS_OBJECT_NAME_COLLISIONというようなエラーメッセージを見つけるだろう。
これは、WIN40とW32X36というディレクトリが(以前のドライバインストールにより)
すでに<smbconfsection name="[print$]"/>というドライバダウンロード共有中に存在
している時に発生する。これらは問題のないエラーメッセージである。
</para>
</sect2>

<sect2>
<title>cupsaddsmbについて理解する</title>

<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
何が起きたのか?<command>cupsaddsmb</command>は何をしたのか?手順には5つのステージがある:
</para>

<orderedlist>
	<listitem><para>
	<indexterm><primary>IPP</primary></indexterm>
	IPP経由でCUPSサーバを呼び出し、その名前のプリンタ用のドライバファイルとPPDファイルを要求する。</para></listitem>

	<listitem><para>ローカルのTEMPDIR中(<filename>cupsd.conf</filename>で定義されている)に、
	ファイルを一時的に格納する。</para></listitem>

	<listitem><para>smbclient経由でSambaサーバの<smbconfsection name="[print$]"/>共有に
	接続し、共有のWIN40(Windows 9x/Me用)とW32X86(Windows NT/200x/XP用)サブディレクトリ
	中にファイルを書き込む。</para></listitem>

	<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
	rpcclient経由でSambaサーバに接続し、正しいパラメータで<command>adddriver</command>
	コマンドを実行する。
	</para></listitem>

	<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
	rpcclient経由でSambaサーバにもう一度接続し、<command>setdriver</command>コマンドを実行する。</para></listitem>
</orderedlist>

<note>
<para>
1番目のリモートホストとしてSambaホストを、2番目のリモートホストとしてCUPSホストを指定する
ためのパラメータを付けて<command>cupsaddsmb</command>ユーティリティを実行できる。
特に、もしもより深く理解したい場合、何が起きたかをより明快にするためにテストしてみるのは
良いことである(実際には、ほとんどの人はCUPSとSambaサーバを同じホストで動作させている):
<screen>
&rootprompt;<userinput>cupsaddsmb -H sambaserver -h cupsserver -v printer</userinput>
</screen>
</para></note>

</sect2>

<sect2>
<title>もしもcupsaddsmbが正しく終了した場合、どのように認識するか</title>

<para>
もしもユーティリティがすべてのフィールドで正しく終わった場合、常時検査を
<emphasis>しなければならない</emphasis>。少なくとも出力中の、以下の3つの
メッセージをチェックする必要がある:
</para>

<orderedlist>
	<listitem><para><emphasis>Printer Driver infotec_2105 successfully
	installed.</emphasis> # (for the W32X86 == Windows NT/200x/XP
	architecture).</para></listitem>

	<listitem><para><emphasis>Printer Driver infotec_2105 successfully
	installed.</emphasis> # (for the WIN40 == Windows 9x/Me
	architecture).</para></listitem>

	<listitem><para><emphasis>Successfully set [printerXPZ] to driver
	[printerXYZ].</emphasis></para></listitem>
</orderedlist>

<para>
これらのメッセージはおそらく一般的な出力中では簡単に認識できない。もしも
(ダウンロードのための、<emphasis>すべての</emphasis>有効なプリンタドライバを
準備しようとする)<option>-a</option>オプションを付けて<command>cupsaddsmb</command>を
動かした場合、もしも個々のプリンタドライバに、正しくにインストールすることに関して
問題がある場合、失敗するかもしれない。出力のリダイレクトは、結果を解析することを
手助けする。
</para>

<para>
もしも下記のメッセージが出た場合:
<screen>
SetPrinter call failed!
result was WERR_ACCESS_DENIED
</screen>
これは、このプリンタに対して<smbconfoption name="use client driver">yes</smbconfoption>
という設定がされているかもしれないということを意味する。この設定を<quote>no</quote>に
すると、この問題が解決する。&smb.conf;マニュアルページ中の、
<parameter>use client driver</parameter>についての説明を参照のこと。
</para>

<note><para>
もしも、verboseモードで<command>cupsaddsmb</command>を動かしていないと、何らかの診断
出力を得るのは不可能である。そのため、既定値であるquietモードを使わないことを強く
推奨する。quietモードを使うと、発生するかもしれない何らかの問題を隠してしまうだろう。
</para></note>
</sect2>

<sect2>
<title>Samba PDCににおけるcupsaddsmb</title>

<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>PDC</primary></indexterm>
Samba PDC上で動かすために、標準の<command>cupsaddsmb</command>コマンドは動かないのか?
認証のためにパスワードを繰り返し聞かれ、コマンドは全く起動しないのか?以下にある応用の
どれかを試してみてほしい:
</para>

<para><screen>
&rootprompt;<userinput>cupsaddsmb -U &example.workgroup;\\root -v printername</userinput>
&rootprompt;<userinput>cupsaddsmb -H &example.pdc.samba; -U &example.workgroup;\\root -v printername</userinput>
&rootprompt;<userinput>cupsaddsmb -H &example.pdc.samba; -U &example.workgroup;\\root -h cups-server -v printername</userinput>
</screen></para>

<para>
(2つのバックスラッシュに注意:最初のものは二番目のものに対する<quote>escape</quote>である)。
</para>
</sect2>

<sect2>
<title>cupsaddsmbフローチャート</title>

<para>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>raw印刷</primary></indexterm>
<link linkend="small14">cupsaddsmbフローチャート</link>は、<command>cupaddsmb</command>の
処理手順、コマンドフローとデータフローを示すチャートである。再度注意:cupsaddsmbは
raw印刷キューと一緒に動かないし、そういうことを意図してもいない!
</para>

	<figure id="small14">
		<title>cupsaddsmbのフローチャート</title>
		<imagefile>14small</imagefile></figure>
</sect2>

<sect2>
<title>クライアント上でのPostScriptドライバのインストール</title>

<para>
<indexterm><primary>point'n'print</primary></indexterm>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<command>cupsaddsmb</command>の完了後、ドライバは、クライアントから使えるようになる。
以下は、ポイントアンドプリント経由でダウンロードしインストールするために行わなければ
ならない手順である。Windowsクライアントから、CUPS/Sambaサーバをブラウズする:
</para>

<itemizedlist>

	<listitem><para>
	<indexterm><primary>"プリンタ"フォルダ</primary></indexterm>
	ネットワークコンピュータ中のSambaの<guilabel>プリンタ</guilabel>共有を開く</para></listitem>

	<listitem><para>問い合わせ(question)中のプリンタを右クリックする</para></listitem>

	<listitem><para>開いたコンテキストメニューから下記を選択する
	<guimenuitem>インストール...</guimenuitem> あるいは 
	<guimenuitem>接続...</guimenuitem> (使用しているWindowsのバージョンに依存する)</para></listitem>
</itemizedlist>

<para>
数秒後、クライアントの<emphasis>ローカル</emphasis><guilabel>プリンタ</guilabel>
フォルダ中に新しいプリンタが現れる。Windows XP上では、
<emphasis>Sambaサーバ上のプリンタ名</emphasis>という名前が付けられている
(現在多くの場合kde-bitshop上のinfotec_2105のようになる)。もしもMicrosoft Wordのような
アプリケーションから、テストと最初のジョブを送りたい場合、有効なプリンタ一覧の
ドロップダウンリスト中に、<filename>\\SambaServer\PrinterName</filename>という
エントリで新しいプリンタが現れる。
</para>

<para>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>Adobe PostScript ドライバ</primary></indexterm>
<indexterm><primary>net use lpt1:</primary></indexterm>
<command>cupsaddsmb</command>はCUPSバージョン1.1.15以上とSamba バージョン2.2.4以降でのみ
確実に動作する。もしも動かない場合か、クライアントへの自動プリンタダウンロードが成功
しないばあい、クライアント上でAdobe PostScriptドライバのtop ofのCUPSプリンタPPDを手動で
インストールトーすすることができる。次に、UNCタイプの接続のために、クライアントの
プリンタキューをSambaプリンタ共有に指定する:
<command>cupsaddsmb</command> will only reliably work with CUPS version 1.1.15 or higher and with Samba
version 2.2.4, or later. If it does not work, or if the automatic printer driver download to the clients does
not succeed, you can still manually install the CUPS printer PPD on top of the Adobe PostScript driver on
clients. Then point the client's printer queue to the Samba printer share for a UNC type of connection:
<screen>
&dosprompt;<userinput>net use lpt1: \\sambaserver\printershare /user:ntadmin</userinput>
</screen>
これは、CUPSでネットワークされたPostScript RIP機能を使用することが出来るようになる
(ユーザ<quote>ntadmin</quote>はプリンタ共有にアクセスするための必要な権限を持つ
有効なSambaユーザである必要がある)。これは、従来からのLanManによる方法(MS-RPCを使わない)
でプリンタの接続を設定する。
</para>
</sect2>

<sect2 id="cups-avoidps1">
<title>クライアント上での危険なPostScriptドライバ設定を防止する</title>

<para>
印刷が動作するが、まだ問題があるとする。ほとんどのジョブは正しく印刷するが、いくつかは
全く印刷できない。いくつかのジョブは、とても良いとは見えないフォントの問題を抱えている。
いくつかのジョブは速やかに処理されるが、いくつかはとても遅い。これらの問題の多くは、
いくつかのガイドラインに従うことで、劇的に軽減できるか、完全になくなる。思い出して
ほしいが、もしも使用している印刷デバイスがPostScriptが有効でない場合、
使用しているクライアントドライバの設定が生成する出力を使って、CUPSホスト上での
Ghostscriptインストールを取り扱ているはずである。以下のようにうまく処理するようにする:
</para>

<itemizedlist>
	<listitem><para>
	Optimize for Speedという設定のPostScript出力オプションを抑制する。その代わりに
	Optimize for Portabilityを使用する(Adobe PostScriptドライバ)。</para></listitem>

	<listitem><para>
	Page Independenceを使わない:設定なしにする。その代わりに、Page Independence: YES
	とする(CUPS PostScriptドライバ)。
	</para></listitem>

	<listitem><para>
	推奨はTrue Typeフォントダウンロードオプション:Native True Type over Automatic and Outline
	である。なんとしてもBitmapを避けるべきである(Adobe PostScriptドライバ)。</para></listitem>

	<listitem><para>
	True Typeフォントを選択する:Download as Softfont into Printer over the default Replace by Device Font
	(Adobeにおいては、各国のフォントは、出力を得るためにそれを戻す必要があるかもしれない。</para></listitem>

	<listitem><para>
	時には、PostScript言語レベルを選択することが出来る:問題が発生した場合は
	3のかわりに2を試してみる(Adobeにおいては、最新のESP Ghostscriptパッケージは
	レベル3のPostScriptをとてもうまく扱える)。
	</para></listitem>

	<listitem><para>
	PostScriptエラーハンドラにYesと答える(Adobe)。</para></listitem>
</itemizedlist>

</sect2>
</sect1>

<sect1>
<title>rpcclientを使ったPostScriptドライバファイルの手動インストール</title>

<para>
もちろん、1つずつ、cupsaddsmbという便利なユーティリティ中に埋め込まれているすべての
コマンドを動かすことと、アップロードと、将来のクライアントダウンロードのためにドライバ
ファイルを準備することは出来る。
</para>

<orderedlist>
	<listitem><para>Sambaを準備する(そこにあるべきプリンタの名前を使うCUPSプリントキュー。
	ドライバを提供している。)</para></listitem>

	<listitem><para><smbconfsection name="[print$]"/>にファイルをコピー。</para></listitem>

	<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
	<command>rpcclient adddriverを動かす</command>
	(サポートしたい各クライアントアーキテクチャ毎に)。</para></listitem>

	<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
	Run <command>rpcclient setdriver.</command></para></listitem>
</orderedlist>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumports</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumdrivers</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
今これを行おうとしよう。最初に、最初の案を得るために、<parameter>rpcclient</parameter>の
マニュアルを読む。印刷に関連するすべてのサブコマンドを見る:
<command>enumprinters</command>,<command>enumdrivers</command>,
<command>enumports</command>, <command>adddriver</command>と
<command>setdriver</command>は最も興味があるものである。
<parameter>rpcclient</parameter>はMS-RPCプロトコルの重要な一部を実装している。
これをWindows NT(か200x/XP)に問い合わせ(とコマンド)を行うのにも使える。MS-RPCは
Windowsクライアントによって使われ、とりわけ、ポイントアンドプリント機能に適合する
ために使われる。Sambaは今、同様にこれをまねることが出来る。
</para>

<sect2>
<title>rpcclientマニュアルページのチェック</title>

<para>
最初に、<parameter>rpcclient</parameter>マニュアルページをチェックしよう。
個々には2つの読むべきな文節がある:
</para>

<para>
<indexterm><primary>adddriver</primary></indexterm>
<indexterm><primary>AddPrinterDriver()</primary></indexterm>
<indexterm><primary>getdriverdir</primary></indexterm>
<command>adddriver &lt;arch&gt; &lt;config&gt;</command>は、サーバ上でプリンタドライバ
情報をインストールするために、<command>AddPrinterDriver()</command>RPCを実行する。
ドライバファイルは<command>getdriverdir</command>によって返されるディレクトリ中に
すでに存在すべきである。<parameter>arch</parameter>が取れる値は
<command>getdriverdir</command>コマンドのものと同じである。<parameter>config</parameter>
パラメータは以下のように定義される:
<screen>
Long Printer Name:\
Driver File Name:\
Data File Name:\
Config File Name:\
Help File Name:\
Language Monitor Name:\
Default Data Type:\
Comma Separated list of Files
</screen></para>

<para>
任意の空白のフィールドは<quote>NULL</quote>という文字列を入力すべきである。
</para>

<para>
Sambaはプリントモニタというコンセプトをサポートする必要がないので、通信のために双方向
リンクを使うことが出来るドライバがあるローカルプリンタのためにのみそれらは適用される。
このフィールドは<quote>NULL</quote>にすべきである。リモートNT印刷サーバ上で、ドライバに
対する印刷モニタはドライバを追加する前にすでにインストールされていなければならない。
そうしないと、RPCは失敗する。
</para>

<para>
<indexterm><primary>setdriver</primary></indexterm>
<indexterm><primary>SetPrinter()</primary></indexterm>
<command>setdriver &lt;printername&gt; &lt;drivername&gt;</command>は、インストール
されたプリンタに関連するプリンタドライバをアップロードするために、
<command>SetPrinter()</command>コマンドを実行する。プリンタドライバはプリンタサーバ
上にあらかじめ正しくインストールされている必要がある。
</para>

<para>
<indexterm><primary>enumprinters</primary></indexterm>
<indexterm><primary>enumdrivers</primary></indexterm>
インストールされたプリンタとドライバの一覧を得るための、
<command>enumprinters</command>と<command>enumdrivers</command>コマンドも
参照のこと。
</para>

</sect2>

<sect2>
<title>rpcclientマニュアルページの理解</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<emphasis>正確な</emphasis>フォーマットはマニュアルページによって明快にはならないので、
空白を含むパラメータを扱う必要がある。以下は、それに対するもう少しわかりやすい説明で
ある。ここではコマンドを改行し、改行は<quote>\</quote>で示している。通常、改行なしに
1行でコマンドを記述するだろう:
The <emphasis>exact</emphasis> format isn't made too clear by the man page, since you have to deal with some
parameters containing spaces. Here is a better description for it. We have line-broken the command and
indicated the breaks with <quote>\</quote>. Usually you would type the command in one line without the line
breaks:
<screen>
adddriver "Architecture" \
   "LongPrinterName:DriverFile:DataFile:ConfigFile:HelpFile:\
   LanguageMonitorFile:DataType:ListOfFiles,Comma-separated"
</screen></para>

<para>
マニュアルページが示すものは、実際に存在する3つのコロンで分離されたフィールド中の、
単純な<parameter>&lt;config&gt;</parameter>キーワードである。最後のフィールドは、
複数の(あまり尋常でない場合では、異なった20のもの)ファイルである。これは、最初は
混乱するように見えるかもしれない。<quote>LongPrinterName</quote>とマニュアルページが
呼んでいるものは、実際では<quote>ドライバ名</quote>と呼ばれるべきである。これは
自由に名前を付けられ、後で<command>rpcclient ... setdriver</command>コマンド中で
この名前を使える。実用的な理由で、多くはプリンタと同じ名前をドライバに付ける。
What the man pages denote as a simple <parameter>&lt;config&gt;</parameter> keyword in reality consists of
eight colon-separated fields. The last field may take multiple (in some very insane cases, even 20 different
additional) files. This might sound confusing at first.  What the man pages call the
<quote>LongPrinterName</quote> in reality should be called the <quote>Driver Name</quote>. You can name it
anything you want, as long as you use this name later in the <command>rpcclient ... setdriver</command>
command. For practical reasons, many name the driver the same as the printer.
</para>

<para>
これは全く単純ではない。<quote>どのファイルがドライバファイルをどうやったら分かるか</quote>、
各<quote>データファイル</quote>, <quote>構成ファイル</quote>, <quote>ヘルプファイル</quote>
と<quote>Language Monitorファイルの場合は?</quote>という質問があるだろう。答えのために、
共有プリンタを持つWindows NTがそれらのファイルをどのように提供しているかを見てみるのも
よいかもしれない。覚えておいてほしいが、この全体の手続きはネットワーク上でWindows
コンピュータが発生させたトラフィックをモニタすることによってSambaチームにより開発
されねばならなかったと言うことである。Windowsマシンに切り替えて、UNIX
ワークステーションからうまくアクセスしても良い。それが何を送っているかを見るために、
<command>rpcclient</command>で問い合わせてもよく、より明快にするために、マニュアル
ページの理解を試みても良い。
It isn't simple at all. I hear you asking: <quote>How do I know which files are Driver File</quote>,
<quote>Data File</quote>, <quote>Config File</quote>, <quote>Help File</quote> and <quote>Language Monitor
File in each case?</quote> For an answer, you may want to have a look at how a Windows NT box with a shared
printer presents the files to us. Remember that this whole procedure has to be developed by the Samba Team by
listening to the traffic caused by Windows computers on the wire. We may as well turn to a Windows box now and
access it from a UNIX workstation. We will query it with <command>rpcclient</command> to see what it tells us
and try to understand the man page more clearly.
</para>
</sect2>

<sect2>
<title>Producing an Example by Querying a Windows Box</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
We could run <command>rpcclient</command> with a <command>getdriver</command> or a
<command>getprinter</command> subcommand (in level 3 verbosity) against it. Just sit down at a UNIX or Linux
workstation with the Samba utilities installed, then type the following command:
<screen>
&rootprompt;<userinput>rpcclient -U'user%secret' NT-SERVER -c 'getdriver printername 3'</userinput>
</screen></para>

<para>
結果から、どれがどれであるか明快になるべきである。以下はインストールの例である:
<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -U'Danka%xxxx' W200xSERVER \
    -c'getdriver "DANKA InfoStream Virtual Printer" 3'</userinput>
    cmd = getdriver "DANKA InfoStream Virtual Printer" 3

 [Windows NT x86]
 Printer Driver Info 3:
         Version: [2]
         Driver Name: [DANKA InfoStream]
         Architecture: [Windows NT x86]
         Driver Path: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRIPT.DLL]
         Datafile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\INFOSTRM.PPD]
         Configfile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRPTUI.DLL]
         Helpfile: [C:\WINNT\System32\spool\DRIVERS\W32X86\2\PSCRIPT.HLP]
 
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
         Dependentfiles: []
 
         Monitorname: []
         Defaultdatatype: []
</screen></para>

<para>
いくつかのプリンタドライバは<parameter>Dependentfiles</parameter>というラベルで、
追加のファイルを一覧表示し、それらは最後のフィールドである
<parameter>ListOfFiles,Comma-separated</parameter>中に押し込まれる。CUPS PostScript
ドライバ用には、それらは不要で(Adobe PostScriptドライバも)、それゆえ、フィールドには
<quote>NULL</quote>が入るだろう。
Some printer drivers list additional files under the label <parameter>Dependentfiles</parameter>, and these
would go into the last field <parameter>ListOfFiles,Comma-separated</parameter>. For the CUPS PostScript
drivers, we do not need any (nor would we for the Adobe PostScript driver); therefore, the field will get a
<quote>NULL</quote> entry.
</para>
</sect2>

<sect2>
<title>adddriverとsetdriverを完了させるための要求事項</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<indexterm><primary>cupsaddsmb</primary></indexterm>
<indexterm><primary>setdriver</primary></indexterm>
マニュアルページから(と上記の<command>cupsaddsmb</command>の引用された出力から)、
手動でのアップロードとドライバファイルの初期化を成功させるために、一定の状態を用意
する必要があることが明確になる。2つの<command>rpcclient</command>サブコマンド
(<command>adddriver</command>と<command>setdriver</command>)は、成功させるために、
以下の前提条件を準備する必要がある:
</para>

<itemizedlist>
	<listitem><para><smbconfoption name="printer admin"/>かroot(これはNTの
	<quote>Printer Operators</quote>グループ<emphasis>ではないが</emphasis>、
	&smb.conf;の<smbconfsection name="[global]"/>セクションで定義されている
	<emphasis>printer admin</emphasis>グループ)で接続する。
	</para></listitem>

	<listitem><para>要求されたドライバを<filename>\\SAMBA\print$\w32x86</filename>
	と<filename>\\SAMBA\print$\win40</filename>に、適切にすべてコピーする。
	これらは、その後最終的に<quote>0</quote>と<quote>2</quote>という
	サブディレクトリで終わる。現時点では、それらをそこに
	<emphasis>置いてはならない</emphasis>。それらは自動的に
	<command>adddriver</command>サブコマンドによって使われる(もしも共有中にドライバ
	ファイルを置くために、<command>smbclient</command>コマンドを使うならば、
	<quote>$</quote>をエスケープする必要があることに注意。たとえば、
	<command>smbclient //sambaserver/print\$ -U root.</command>)。
	Copy all required driver files to <filename>\\SAMBA\print$\w32x86</filename> and
	<filename>\\SAMBA\print$\win40</filename> as appropriate. They will end up in the <quote>0</quote> respective
	<quote>2</quote> subdirectories later. For now, <emphasis>do not</emphasis> put them there; they'll be
	automatically used by the <command>adddriver</command> subcommand. (If you use <command>smbclient</command> to
	put the driver files into the share, note that you need to escape the <quote>$</quote>: <command>smbclient
	//sambaserver/print\$ -U root.</command>)</para></listitem>

	<listitem><para>接続しているユーザは<smbconfsection name="[print$]"/>共有に
	書き込みとサブディレクトリの作成が出来ねばならない。</para></listitem>

	<listitem><para>Windowsクライアント用に設定しようとしているプリンタは、
	CUPSによってすでにインストールされている必要がある。</para></listitem>

	<listitem><para>
	<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
	<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
	CUPSプリンタはSambaによって認識されねばならない:さもないと、
	<command>setdriver</command>サブコマンドは、NT_STATUS_UNSUCCESSFULというエラーで
	失敗する。Sambaによってプリンタが認識されているかを調べるには、
	 <command>rpcclient</command>で<command>enumprinters</command>サブコマンドを
	 使うことが出来る。長く存在しているバグが、各smbdプロセスがSIGHUPを受け取るか、
	 再起動するまで、プリンタ一覧の適切な更新を阻害している。ごく最近CUPSプリンタを
	 作成して問題が発生した場合、Sambaを再起動することを覚えておいてほしい。
	</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>15ステップでの手動ドライバインストール</title>

<para>
すべての要求されたコマンドを実行して、手動で、プリンタドライバをインストールしてみる。
最初、これは複雑なプロセスなように見えるという理由で、手順を1つずつ、やらなければ
ならない、単一のアクションアイテム毎に説明する。
We are going to install a printer driver now by manually executing all
required commands. Because this may seem a rather complicated process at
first, we go through the procedure step by step, explaining every
single action item as it comes up.
</para>

<procedure>
<title>手動でのドライバインストール</title>

	<step>
	<title>CUPS上でのプリンタのインストール</title>

	<para><screen>
	&rootprompt;<userinput>lpadmin -p mysmbtstprn -v socket://10.160.51.131:9100 -E \
				-P canonIR85.ppd</userinput>
	</screen></para>

	<para>
	これは、CUPSシステムに<parameter>mysmbtstprn</parameter>という名前のプリンタを
	インストールする。プリンタはソケット(JetDirectかDirect TCP/IPとして知られる)
	接続経由で接続される。このステップはrootで行う必要がある。
	</para>
	</step>

	<step>
	<title>(オプション)Sambaによってプリンタが認識されているかを調べる。</title>

	<para>
	<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumprinters' localhost \
  | grep -C2 mysmbtstprn</userinput>
flags:[0x800000]
name:[\\kde-bitshop\mysmbtstprn]
description:[\\kde-bitshop\mysmbtstprn,,mysmbtstprn]
comment:[mysmbtstprn]
</screen>
	</para>

	<para>
	これは、一覧中にプリンタを表示する。層でなければ、Sambaデーモン(smbd)をいったん
	止めて再起動するか、HUPシグナルを送る:
<screen>
&rootprompt;<userinput>kill -HUP `pidof smbd`</userinput>
</screen>
	再度チェックする。成功するまでトラブルシュートを繰り返し行う。
	<quote>description</quote>行中に、2つのカンマの間に<quote>空白</quote>の
	フィールドがあることに注意。すでに1つ存在していれば、ドライバ名はここに現れる。
	このステップと、この後のステップのほとんどのために、rootのSambaでのパスワード
	(<command>smbpasswd</command>コマンドによって設定される)を知っておく必要がある。
	代わりに、<smbconfsection name="[print$]"/>に対して&smb.conf;中で
	<quote>write list</quote>として定義されているユーザからの1つで認証する事が出来る。
	</para>
	</step>

	<step>
	<title>(オプション)プリンタに対するドライバをSambaが認識しているかを調べる。</title>

	<para>
	<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
	<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2'\
 localhost | grep driver </userinput>

drivername:[]

&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' \
 localhost | grep -C4 driv</userinput>

servername:[\\kde-bitshop]
printername:[\\kde-bitshop\mysmbtstprn]
sharename:[mysmbtstprn]
portname:[Samba Printer Port]
drivername:[]
comment:[mysmbtstprn]
location:[]
sepfile:[]
printprocessor:[winprint]
 
&rootprompt;<userinput>rpcclient -U root%xxxx -c 'getdriver mysmbtstprn' localhost</userinput>
 result was WERR_UNKNOWN_PRINTER_DRIVER
</screen></para>

<para>
None of the three commands shown above should show a driver.
This step was done for the purpose of demonstrating this condition. An
attempt to connect to the printer at this stage will prompt a
message along the lines of, <quote>The server does not have the required printer
driver installed.</quote>
</para>
</step>

<step>
<title>Put all required driver files into Samba's
[print$].</title>

<para><screen>
&rootprompt;<userinput>smbclient //localhost/print\$ -U 'root%xxxx' \
	-c 'cd W32X86; \
	put /etc/cups/ppd/mysmbtstprn.ppd mysmbtstprn.PPD; \ 
	put /usr/share/cups/drivers/cupsui.dll cupsui.dll; \
	put /usr/share/cups/drivers/cupsdrvr.dll cupsdrvr.dll; \
	put /usr/share/cups/drivers/cups.hlp cups.hlp'</userinput>
</screen></para>

<para>
(This command should be entered in one long single line. Line breaks and the line ends indicated by
<quote>\</quote> have been inserted for readability reasons.) This step is <emphasis>required</emphasis> for
the next one to succeed. It makes the driver files physically present in the <smbconfsection name="[print$]"/>
share. However, clients would still not be able to install them, because Samba does not yet treat them as
driver files. A client asking for the driver would still be presented with a <quote>not installed here</quote>
message.
</para>
</step>

<step>
<title>Verify where the driver files are now.</title>

<para><screen>
&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/</userinput>
total 669
drwxr-sr-x    2 root     ntadmin       532 May 25 23:08 2
drwxr-sr-x    2 root     ntadmin       670 May 16 03:15 3
-rwxr--r--    1 root     ntadmin     14234 May 25 23:21 cups.hlp
-rwxr--r--    1 root     ntadmin    278380 May 25 23:21 cupsdrvr.dll
-rwxr--r--    1 root     ntadmin    215848 May 25 23:21 cupsui.dll
-rwxr--r--    1 root     ntadmin    169458 May 25 23:21 mysmbtstprn.PPD
</screen></para>

<para>
The driver files now are in the W32X86 architecture <quote>root</quote> of
<smbconfsection name="[print$]"/>.
</para>
</step>

<step>
<title>Tell Samba that these are driver files (<command>adddriver</command>).</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>adddriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'adddriver "Windows NT x86" \
	"mydrivername:cupsdrvr.dll:mysmbtstprn.PPD: \
  cupsui.dll:cups.hlp:NULL:RAW:NULL"' \
  localhost</userinput>
Printer Driver mydrivername successfully installed.
</screen></para>

<para>
You cannot repeat this step if it fails. It could fail even as a result of a simple typo. It will most likely
have moved a part of the driver files into the <quote>2</quote> subdirectory. If this step fails, you need to
go back to the fourth step and repeat it before you can try this one again. In this step, you need to choose a
name for your driver. It is normally a good idea to use the same name as is used for the printer name;
however, in big installations you may use this driver for a number of printers that obviously have different
names, so the name of the driver is not fixed.
</para>
</step>

<step>
<title>Verify where the driver files are now.</title>

<para><screen>
&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/</userinput>
total 1
drwxr-sr-x    2 root     ntadmin       532 May 25 23:22 2
drwxr-sr-x    2 root     ntadmin       670 May 16 03:15 3

&rootprompt;<userinput>ls -l /etc/samba/drivers/W32X86/2</userinput>
total 5039
[....]
-rwxr--r--    1 root     ntadmin     14234 May 25 23:21 cups.hlp
-rwxr--r--    1 root     ntadmin    278380 May 13 13:53 cupsdrvr.dll
-rwxr--r--    1 root     ntadmin    215848 May 13 13:53 cupsui.dll
-rwxr--r--    1 root     ntadmin    169458 May 25 23:21 mysmbtstprn.PPD
</screen></para>

<para>
Notice how step 6 also moved the driver files to the appropriate
subdirectory. Compare this with the situation after step 5.
</para>
</step>

<step>
<title>(Optional.) Verify if Samba now recognizes the driver.</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumdrivers</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumdrivers 3' \
	localhost | grep -B2 -A5 mydrivername</userinput>
Printer Driver Info 3:
Version: [2]
Driver Name: [mydrivername]
Architecture: [Windows NT x86]
Driver Path: [\\kde-bitshop\print$\W32X86\2\cupsdrvr.dll]
Datafile: [\\kde-bitshop\print$\W32X86\2\mysmbtstprn.PPD]
Configfile: [\\kde-bitshop\print$\W32X86\2\cupsui.dll]
Helpfile: [\\kde-bitshop\print$\W32X86\2\cups.hlp]
</screen></para>

<para>
Remember, this command greps for the name you chose for the
driver in step 6. This command must succeed before you can proceed.
</para>
</step>

<step>
<title>Tell Samba which printer should use these driver files (<command>setdriver</command>).</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>setdriver</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'setdriver mysmbtstprn mydrivername' \
	localhost</userinput>
Successfully set mysmbtstprn to driver mydrivername
</screen></para>

<para>
Since you can bind any printer name (print queue) to any driver, this is a convenient way to set up many
queues that use the same driver. You do not need to repeat all the previous steps for the setdriver command to
succeed. The only preconditions are that <command>enumdrivers</command> must find the driver and
<command>enumprinters</command> must find the printer.
</para>
</step>

<step>
<title>(Optional) Verify if Samba has recognized this association.</title>

<para>
<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>getdriver</secondary></indexterm>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
  | grep driver</userinput>
drivername:[mydrivername]
 
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'getprinter mysmbtstprn 2' localhost \
  | grep -C4 driv</userinput>
servername:[\\kde-bitshop]
printername:[\\kde-bitshop\mysmbtstprn]
sharename:[mysmbtstprn]
portname:[Done]
drivername:[mydrivername]
comment:[mysmbtstprn]
location:[]
sepfile:[]
printprocessor:[winprint]
 
&rootprompt;<userinput>rpcclient -U root%xxxx -c 'getdriver mysmbtstprn' localhost</userinput>
[Windows NT x86]
Printer Driver Info 3:
     Version: [2]
     Driver Name: [mydrivername]
     Architecture: [Windows NT x86]
     Driver Path: [\\kde-bitshop\print$\W32X86\2\cupsdrvr.dll]
     Datafile: [\\kde-bitshop\print$\W32X86\2\mysmbtstprn.PPD]
     Configfile: [\\kde-bitshop\print$\W32X86\2\cupsui.dll]
     Helpfile: [\\kde-bitshop\print$\W32X86\2\cups.hlp]
     Monitorname: []
     Defaultdatatype: [RAW]
     Monitorname: []
     Defaultdatatype: [RAW]
 
&rootprompt;<userinput>rpcclient -Uroot%xxxx -c 'enumprinters' localhost \
	| grep mysmbtstprn</userinput>
     name:[\\kde-bitshop\mysmbtstprn]
     description:[\\kde-bitshop\mysmbtstprn,mydrivername,mysmbtstprn]
     comment:[mysmbtstprn]

</screen></para>

<para>
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
Compare these results with the ones from steps 2 and 3. Every one of these commands show the driver is installed. Even
the <command>enumprinters</command> command now lists the driver
on the <quote>description</quote> line.
</para>
</step>

<step>
<title>(Optional.) Tickle the driver into a correct
device mode.</title>

<para>
<indexterm><primary>"Printers" folder</primary></indexterm>
You certainly know how to install the driver on the client. In case
you are not particularly familiar with Windows, here is a short
recipe: Browse the Network Neighborhood, go to the Samba server, and look
for the shares. You should see all shared Samba printers.
Double-click on the one in question. The driver should get
installed and the network connection set up. Another way is to
open the <guilabel>Printers (and Faxes)</guilabel> folder, right-click on the printer in
question, and select <guilabel>Connect</guilabel> or <guilabel>Install</guilabel>. As a result, a new printer
should appear in your client's local <guilabel>Printers (and Faxes)</guilabel>
folder, named something like <guilabel>printersharename on Sambahostname</guilabel>.
</para>

<para>
It is important that you execute this step as a Samba printer admin
(as defined in &smb.conf;). Here is another method
to do this on Windows XP. It uses a command line, which you may type
into the <quote>DOS box</quote> (type root's smbpassword when prompted):
</para>

<para><screen>
&dosprompt;<userinput>runas /netonly /user:root "rundll32 printui.dll,PrintUIEntry \
	/in /n \\sambaserver\mysmbtstprn"</userinput>
</screen></para>

<para>
Change any printer setting once (like changing <emphasis><guilabel>portrait</guilabel> to
<guilabel>landscape</guilabel></emphasis>), click on <guibutton>Apply</guibutton>, and change the setting back.
</para>
</step>

<step>
<title>Install the printer on a client (Point'n'Print).</title>

<para>
<indexterm significance="preferred"><primary>point 'n' print</primary></indexterm>
<screen>
&dosprompt;<userinput>rundll32 printui.dll,PrintUIEntry /in /n &quot;\\sambaserver\mysmbtstprn&quot;</userinput>
</screen>
If it does not work, it could be a permissions problem with the <smbconfsection name="[print$]"/> share.
</para>
</step>

<step>
<title>(Optional) Print a test page.</title>

<indexterm><primary>rundll32</primary></indexterm>
<para><screen>
&dosprompt;<userinput>rundll32 printui.dll,PrintUIEntry /p /n "\\sambaserver\mysmbtstprn"</userinput>
</screen></para>

<para>
Then hit [TAB] five times, [ENTER] twice, [TAB] once, and [ENTER] again, and march to the printer.
</para>
</step>

<step>
<title>(Recommended.) Study the test page.</title>

<para>
Hmmm. Just kidding! By now you know everything about printer installations and you do not need to read a word.
Just put it in a frame and bolt it to the wall with the heading "MY FIRST RPCCLIENT-INSTALLED PRINTER"
&smbmdash; why not just throw it away!
</para>
</step>

<step>
<title>(Obligatory.) Enjoy. Jump. Celebrate your success.</title>

<para><screen>
&rootprompt;<userinput>echo "Cheeeeerioooooo! Success..." &gt;&gt; /var/log/samba/log.smbd</userinput>
</screen></para>
</step>
</procedure>
</sect2>

<sect2>
<title>Troubleshooting Revisited</title>

<para>
<indexterm><primary>adddriver</primary></indexterm>
The setdriver command will fail if in Samba's mind the queue is not
already there. A successful installation displys the promising message that the:
<screen>
Printer Driver ABC successfully installed.
</screen>
following the <command>adddriver</command> parts of the procedure.  But you may also see
a disappointing message like this one:
<computeroutput>
result was NT_STATUS_UNSUCCESSFUL
</computeroutput></para>

<para>
<indexterm><primary>lpstat</primary></indexterm>
<indexterm><primary>rpcclient</primary></indexterm>
It is not good enough that you can see the queue in CUPS, using the <command>lpstat -p ir85wm</command>
command. A bug in most recent versions of Samba prevents the proper update of the queue list. The recognition
of newly installed CUPS printers fails unless you restart Samba or send a HUP to all smbd processes. To verify
if this is the reason why Samba does not execute the <command>setdriver</command> command successfully, check
if Samba <quote>sees</quote> the printer:
<indexterm><primary>rpcclient</primary><secondary>enumprinters</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient transmeta -N -U'root%xxxx' -c 'enumprinters 0'|grep ir85wm</userinput>
        printername:[ir85wm]
</screen></para>

<para>
An alternate command could be this: 
<indexterm><primary>rpcclient</primary><secondary>getprinter</secondary></indexterm>
<screen>
&rootprompt;<userinput>rpcclient transmeta -N -U'root%secret' -c 'getprinter ir85wm' </userinput>
        cmd = getprinter ir85wm
        flags:[0x800000]
        name:[\\transmeta\ir85wm]
        description:[\\transmeta\ir85wm,ir85wm,DPD]
        comment:[CUPS PostScript-Treiber for Windows NT/200x/XP]
</screen></para>

<para>
By the way, you can use these commands, plus a few more, of course, to install drivers on remote Windows NT print servers too!
</para>
</sect2>
</sect1>

<sect1>
<title>The Printing <filename>*.tdb</filename> Files</title>

<para>
<indexterm><primary>TDB</primary></indexterm>
<indexterm><primary>connections.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>printing.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>share_info.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntdrivers.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>unexpected.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>brlock.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>locking.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntforms.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>messages.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>ntprinters.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>sessionid.tdb</primary><seealso>TDB</seealso></indexterm>
<indexterm><primary>secrets.tdb</primary><seealso>TDB</seealso></indexterm>
Some mystery is associated with the series of files with a tdb suffix appearing in every Samba installation.
They are <filename>connections.tdb</filename>, <filename>printing.tdb</filename>,
<filename>share_info.tdb</filename>, <filename>ntdrivers.tdb</filename>, <filename>unexpected.tdb</filename>,
<filename>brlock.tdb</filename>, <filename>locking.tdb</filename>, <filename>ntforms.tdb</filename>,
<filename>messages.tdb</filename> , <filename>ntprinters.tdb</filename>, <filename>sessionid.tdb</filename>,
and <filename>secrets.tdb</filename>. What is their purpose?
</para>

<sect2>
<title>Trivial Database Files</title>

<para>
<indexterm><primary>TDB</primary></indexterm>
A Windows NT (print) server keeps track of all information needed to serve its duty toward its clients by
storing entries in the Windows registry. Client queries are answered by reading from the registry,
Administrator or user configuration settings that are saved by writing into the registry. Samba and UNIX
obviously do not have such a Registry. Samba instead keeps track of all client-related information in a series
of <filename>*.tdb</filename> files. (TDB stands for trivial data base). These are often located in
<filename>/var/lib/samba/</filename> or <filename>/var/lock/samba/</filename>. The printing-related files are
<filename>ntprinters.tdb</filename>, <filename>printing.tdb</filename>,<filename>ntforms.tdb</filename>, and
<filename>ntdrivers.tdb</filename>.
</para>
</sect2>

<sect2>
<title>Binary Format</title>

<para>
<filename>*.tdb</filename> files are not human readable. They are written in a binary format. <quote>Why not
ASCII?</quote>, you may ask. <quote>After all, ASCII configuration files are a good and proven tradition on
UNIX.</quote> The reason for this design decision by the Samba Team is mainly performance. Samba needs to be
fast; it runs a separate <command>smbd</command> process for each client connection, in some environments many
thousands of them. Some of these <command>smbds</command> might need to write-access the same
<filename>*.tdb</filename> file <emphasis>at the same time</emphasis>. The file format of Samba's
<filename>*.tdb</filename> files allows for this provision. Many smbd processes may write to the same
<filename>*.tdb</filename> file at the same time. This wouldn't be possible with pure ASCII files.
</para>
</sect2>

<sect2>
<title>Losing <filename>*.tdb</filename> Files</title>

<para>
It is very important that all <filename>*.tdb</filename> files remain consistent over all write and read
accesses. However, it may happen that these files <emphasis>do</emphasis> get corrupted. (A <command>kill -9
`pidof smbd'</command> while a write access is in progress could do the damage, as could a power interruption,
etc.). In cases of trouble, a deletion of the old printing-related <filename>*.tdb</filename> files may be the
only option. After that, you need to re-create all print-related setups unless you have made a backup of the
<filename>*.tdb</filename> files in time.
</para>
</sect2>

<sect2>
<title>Using <command>tdbbackup</command></title>

<para>
<indexterm><primary>TDB</primary><secondary>backing up</secondary><see>tdbbackup</see></indexterm>
<indexterm><primary>tdbbackup</primary></indexterm>
Samba ships with a little utility that helps the root user of your system to backup your
<filename>*.tdb</filename> files. If you run it with no argument, it prints a usage message:
<screen>
&rootprompt;<userinput>tdbbackup</userinput>
 Usage: tdbbackup [options] &lt;fname...&gt;
 
 Version:3.0a
   -h            this help message
   -s suffix     set the backup suffix
   -v            verify mode (restore if corrupt)
</screen></para>

<para>
Here is how I backed up my <filename>printing.tdb</filename> file:
</para>

<para><screen>
&rootprompt;<userinput>ls</userinput>
.              browse.dat     locking.tdb     ntdrivers.tdb printing.tdb
..             share_info.tdb connections.tdb messages.tdb  ntforms.tdb
printing.tdbkp unexpected.tdb brlock.tdb      gmon.out      namelist.debug  
ntprinters.tdb sessionid.tdb
 
&rootprompt;<userinput>tdbbackup -s .bak printing.tdb</userinput>
 printing.tdb : 135 records
 
&rootprompt;<userinput>ls -l printing.tdb*</userinput>
 -rw-------    1 root     root        40960 May  2 03:44 printing.tdb
 -rw-------    1 root     root        40960 May  2 03:44 printing.tdb.bak

</screen></para>
</sect2>
</sect1>

<sect1>
<title>CUPS Print Drivers from Linuxprinting.org</title>

<para>
<indexterm><primary>Linuxprinting.org</primary></indexterm>
CUPS ships with good support for HP LaserJet-type printers. You can install the generic driver as follows:
<indexterm><primary>lpadmin</primary></indexterm>
<screen>
&rootprompt;<userinput>lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E -m laserjet.ppd</userinput>
</screen></para>

<para>
The <option>-m</option> switch will retrieve the <filename>laserjet.ppd</filename> from the standard
repository for not-yet-installed PPDs, which CUPS typically stores in
<filename>/usr/share/cups/model</filename>. Alternatively, you may use <option>-P /path/to/your.ppd</option>.
</para>

<para>
The generic <filename>laserjet.ppd,</filename> however, does not support every special option for every
LaserJet-compatible model. It constitutes a sort of <quote>least common denominator</quote> of all the models.
If for some reason you must pay for the commercially available ESP Print Pro drivers, your first move should
be to consult the database on the <ulink noescape="1"
url="http://www.linuxprinting.org/printer_list.cgi">Linuxprinting</ulink> Web site.  Linuxprinting.org has
excellent recommendations about which driver is best used for each printer. Its database is kept current by
the tireless work of Till Kamppeter from Mandrakesoft, who is also the principal author of the
<command>foomatic-rip</command> utility.
</para>

<note><para>
<indexterm><primary>foomatic-rip</primary></indexterm>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>Adobe PPD</primary></indexterm>
The former <command>cupsomatic</command> concept is now being replaced by the new successor, a much more
powerful <command>foomatic-rip</command>.  <command>cupsomatic</command> is no longer maintained. Here is the
new URL to the <ulink noescape="1" url="http://www.linuxprinting.org/driver_list.cgi">Foomatic-3.0</ulink>
database.  If you upgrade to <command>foomatic-rip</command>, remember to also upgrade to the new-style PPDs
for your Foomatic-driven printers. foomatic-rip will not work with PPDs generated for the old
<command>cupsomatic</command>. The new-style PPDs are 100% compliant with the Adobe PPD specification. They
are also intended to be used by Samba and the cupsaddsmb utility, to provide the driver files for the Windows
clients!
</para></note>

<sect2>
<title>foomatic-rip and Foomatic Explained</title>


<para>
<indexterm significance="preferred"><primary>foomatic</primary></indexterm>
<indexterm significance="preferred"><primary>foomatic-rip</primary></indexterm>
Nowadays, most Linux distributions rely on the utilities from the <ulink
url="http://www.linuxprinting.org/">Linuxprinting.org</ulink> to create their printing-related software
(which, by the way, works on all UNIXes and on Mac OS X and Darwin, too).  The utilities from this sire have a
very end-user-friendly interface that allows for an easy update of drivers and PPDs for all supported models,
all spoolers, all operating systems, and all package formats (because there is none). Its history goes back a
few years.
</para>

<para>
Recently, Foomatic has achieved the astonishing milestone of <ulink
url="http://www.linuxprinting.org/printer_list.cgi?make=Anyone">1,000 listed</ulink> printer models.
Linuxprinting.org keeps all the important facts about printer drivers, supported models, and which options are
available for the various driver/printer combinations in its <ulink
url="http://www.linuxprinting.org/foomatic.html">Foomatic</ulink> database. Currently there are <ulink
url="http://www.linuxprinting.org/driver_list.cgi">245 drivers</ulink> in the database. Many drivers support
various models, and many models may be driven by different drivers &smbmdash; its your choice!
</para>

<sect3>
<title>690 <quote>Perfect</quote> Printers</title>

<para>
<indexterm><primary>Windows PPD</primary></indexterm>
At present, there are 690 devices dubbed as working perfectly: 181 are <emphasis>mostly</emphasis> perfect, 96
are <emphasis>partially</emphasis> perfect, and 46 are paperweights. Keeping in mind that most of these are
non-PostScript models (PostScript printers are automatically supported by CUPS to perfection by using their
own manufacturer-provided Windows PPD), and that a multifunctional device never qualifies as working perfectly
if it does not also scan and copy and fax under GNU/Linux &smbmdash; then this is a truly astonishing
achievement! Three years ago the number was not more than 500, and Linux or UNIX printing at the time wasn't
anywhere near the quality it is today.
</para>
</sect3>

<sect3>
<title>How the Printing HOWTO Started It All</title>

<para>
A few years ago <ulink url="http://www2.picante.com/">Grant Taylor</ulink> started it all. The
roots of today's Linuxprinting.org are in the first <ulink
url="http://www.linuxprinting.org/foomatic2.9/howto/">Linux Printing HOWTO</ulink> that he authored. As a
side-project to this document, which served many Linux users and admins to guide their first steps in this
complicated and delicate setup (to a scientist, printing is <quote>applying a structured deposition of
distinct patterns of ink or toner particles on paper substrates</quote>), he started to build in a little
Postgres database with information about the hardware and driver zoo that made up Linux printing of the time.
This database became the core component of today's Foomatic collection of tools and data. In the meantime, it
has moved to an XML representation of the data.
</para>
</sect3>

<sect3>
<title>Foomatic's Strange Name</title>


<para>
<indexterm><primary>foomatic</primary></indexterm>
<quote>Why the funny name?</quote> you ask. When it really took off, around spring 2000, CUPS was far less
popular than today, and most systems used LPD, LPRng, or even PDQ to print. CUPS shipped with a few generic
drivers (good for a few hundred different printer models). These didn't support many device-specific options.
CUPS also shipped with its own built-in rasterization filter (<parameter>pstoraster</parameter>, derived from
Ghostscript). On the other hand, CUPS provided brilliant support for <emphasis>controlling</emphasis> all
printer options through standardized and well-defined PPD files.  Plus, CUPS was designed to be easily
extensible.
</para>

<para>
Taylor already had in his database a respectable compilation of facts about many more printers and the
Ghostscript <quote>drivers</quote> they run with. His idea, to generate PPDs from the database information and
use them to make standard Ghostscript filters work within CUPS, proved to work very well. It also killed
several birds with one stone:
</para>

<itemizedlist>
	<listitem><para>It made all current and future Ghostscript filter
	developments available for CUPS.</para></listitem>

	<listitem><para>It made available a lot of additional printer models
	to CUPS users (because often the traditional Ghostscript way of
	printing was the only one available).</para></listitem>

	<listitem><para>It gave all the advanced CUPS options (Web interface,
	GUI driver configurations) to users wanting (or needing) to use
	Ghostscript filters.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>cupsomatic, pdqomatic, lpdomatic, directomatic</title>

<para>
<indexterm><primary>cupsomatic</primary></indexterm>
<indexterm><primary>CUPS-PPD</primary></indexterm>
<indexterm><primary>PPD</primary><secondary>CUPS</secondary><see>CUPS-PPD</see></indexterm>
CUPS worked through a quickly hacked-up filter script named <ulink
url="http://www.linuxprinting.org/download.cgi?filename=cupsomatic&amp;show=0">cupsomatic</ulink>.  cupsomatic
ran the printfile through Ghostscript, constructing automatically the rather complicated command line needed.
It just needed to be copied into the CUPS system to make it work. To configure the way cupsomatic controls the
Ghostscript rendering process, it needs a CUPS-PPD. This PPD is generated directly from the contents of the
database. For CUPS and the respective printer/filter combo, another Perl script named CUPS-O-Matic did the PPD
generation. After that was working, Taylor implemented within a few days a similar thing for two other
spoolers. Names chosen for the config-generator scripts were <ulink
url="http://www.linuxprinting.org/download.cgi?filename=lpdomatic&amp;show=0">PDQ-O-Matic</ulink> (for PDQ)
and <ulink url="http://www.linuxprinting.org/download.cgi?filename=lpdomatic&amp;show=0">LPD-O-Matic</ulink>
(for &smbmdash; you guessed it &smbmdash; LPD); the configuration here didn't use PPDs but other
spooler-specific files.
</para>

<para>
From late summer of that year, <ulink url="http://www.linuxprinting.org/till/">Till Kamppeter</ulink> started
to put work into the database. Kamppeter had been newly employed by <ulink
url="http://www.mandrakesoft.com/">Mandrakesoft</ulink> to convert its printing system over to CUPS, after
they had seen his <ulink url="http://www.fltk.org/">FLTK</ulink>-based <ulink
url="http://cups.sourceforge.net/xpp/">XPP</ulink> (a GUI front-end to the CUPS lp-command). He added a huge
amount of new information and new printers. He also developed the support for other spoolers, like <ulink
url="http://ppr.sourceforge.net/">PPR</ulink> (via ppromatic), <ulink
url="http://sourceforge.net/projects/lpr/">GNUlpr</ulink>, and <ulink
url="http://www.lprng.org/">LPRng</ulink> (both via an extended lpdomatic) and spooler-less printing (<ulink
url="http://www.linuxprinting.org/download.cgi?filename=directomatic&amp;show=0">directomatic</ulink>).
</para>

<para>
So, to answer your question, <quote>Foomatic</quote> is the general name for all the overlapping code and data
behind the <quote>*omatic</quote> scripts.  Foomatic, up to versions 2.0.x, required (ugly) Perl data
structures attached to Linuxprinting.org PPDs for CUPS. It had a different <quote>*omatic</quote> script for
every spooler, as well as different printer configuration files.
</para>
</sect3>

<sect3>
<title>The <emphasis>Grand Unification</emphasis> Achieved</title>

<para>
<indexterm><primary>foomatic-rip</primary></indexterm>
This has all changed in Foomatic versions 2.9 (beta) and released as <quote>stable</quote> 3.0. It has now
achieved the convergence of all *omatic scripts and is called the <ulink
url="http://www.linuxprinting.org/foomatic2.9/download.cgi?filename=foomatic-rip&amp;show=0">foomatic-rip</ulink>.
This single script is the unification of the previously different spooler-specific *omatic scripts.
foomatic-rip is used by all the different spoolers alike, and because it can read PPDs (both the original
PostScript printer PPDs and the Linuxprinting.org-generated ones), all of a sudden all supported spoolers can
have the power of PPDs at their disposal. Users only need to plug foomatic-rip into their system. For users
there is improved media type and source support &smbmdash; paper sizes and trays are easier to configure.
</para>

<para>
<indexterm><primary>PPDs</primary></indexterm>
<indexterm><primary>Foomatic tutorial</primary></indexterm>
<indexterm><primary>LinuxKongress2002</primary></indexterm>
Also, the new generation of Linuxprinting.org PPDs no longer contains Perl data structures. If you are a
distro maintainer and have used the previous version of Foomatic, you may want to give the new one a spin, but
remember to generate a new-version set of PPDs via the new <ulink
url="http://www.linuxprinting.org/download/foomatic/foomatic-db-engine-3.0.0beta1.tar.gz">foomatic-db-engine!</ulink>.
Individual users just need to generate a single new PPD specific to their model by <ulink
url="http://www.linuxprinting.org/kpfeifle/LinuxKongress2002/Tutorial/II.Foomatic-User/II.tutorial-handout-foomatic-user.html">following
the steps</ulink> outlined in the Foomatic tutorial or in this chapter. This new development is truly amazing.
</para>

<para>
<indexterm><primary>foomatic-rip</primary></indexterm>
<indexterm><primary>Adobe</primary></indexterm>
<indexterm><primary>printer drivers</primary></indexterm>
foomatic-rip is a very clever wrapper around the need to run Ghostscript with a different syntax, options,
device selections, and/or filters for each different printer or spooler. At the same time, it can read the PPD
associated with a print queue and modify the print job according to the user selections. Together with this
comes the 100% compliance of the new Foomatic PPDs with the Adobe spec. Some innovative features of the
Foomatic concept may surprise users. It will support custom paper sizes for many printers and will support
printing on media drawn from different paper trays within the same job (in both cases, even where there is no
support for this from Windows-based vendor printer drivers).
</para>
</sect3>

<sect3>
<title>Driver Development Outside</title>

<para>
<indexterm><primary>Linuxprinting.org</primary></indexterm>
Most driver development itself does not happen within Linuxprinting.org. Drivers are written by independent
maintainers.  Linuxprinting.org just pools all the information and stores it in its database. In addition, it
also provides the Foomatic glue to integrate the many drivers into any modern (or legacy) printing system
known to the world.
</para>

<para>
Speaking of the different driver development groups, most of the work is currently done in three projects:
</para>

<itemizedlist>
	<listitem><para>
<indexterm><primary>Omni</primary></indexterm>
	<ulink url="http://www-124.ibm.com/developerworks/oss/linux/projects/omni/">Omni</ulink>
	&smbmdash; a free software project by IBM that tries to convert its printer
	driver knowledge from good-ol' OS/2 times into a modern, modular,
	universal driver architecture for Linux/UNIX (still beta). This
	currently supports 437 models.</para></listitem>

	<listitem><para>
<indexterm><primary>HPIJS</primary></indexterm>
	<ulink url="http://hpinkjet.sf.net/">HPIJS</ulink> &smbmdash;
	a free software project by HP to provide the support for its own
	range of models (very mature, printing in most cases is perfect and
	provides true photo quality). This currently supports 369
	models.</para></listitem>

	<listitem><para>
<indexterm><primary>Gutenprint</primary></indexterm>
	<ulink url="http://gimp-print.sourceforge.net/">Gutenprint</ulink> &smbmdash; a free software
	effort, started by Michael Sweet (also lead developer for CUPS), now
	directed by Robert Krawitz, which has achieved an amazing level of
	photo print quality (many Epson users swear that its quality is
	better than the vendor drivers provided by Epson for the Microsoft
	platforms). This currently supports 522 models.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Forums, Downloads, Tutorials, Howtos (Also for Mac OS X and Commercial UNIX)</title>

<para>
Linuxprinting.org today is the one-stop shop to download printer drivers. Look for printer information and
<ulink url="http://www.linuxprinting.org//kpfeifle/LinuxKongress2002/Tutorial/">tutorials</ulink> or solve
printing problems in its popular <ulink url="http://www.linuxprinting.org/newsportal/">forums</ulink>. This
forum is not just for GNU/Linux users, but admins of <ulink url="http://www.linuxprinting.org/macosx/">
commercial UNIX systems</ulink> are also going there, and the relatively new
<ulink url="http://www.linuxprinting.org/newsportal/thread.php3?name=linuxprinting.macosx.general">Mac OS X
forum</ulink> has turned out to be one of the most frequented forums after only a few weeks.
</para>

<para>
<indexterm><primary>Mandriva</primary></indexterm>
<indexterm><primary>Mandrake</primary></indexterm>
<indexterm><primary>Conectiva</primary></indexterm>
Linuxprinting.org and the Foomatic driver wrappers around Ghostscript are now a standard tool-chain for
printing on all the important distros. Most of them also have CUPS underneath. While in recent years most
printer data had been added by Kamppeter, many additional contributions came from engineers with SuSE, Red
Hat, Conectiva, Debian, and others. Vendor-neutrality is an important goal of the Foomatic project. Mandrake
and Conectiva have merged and are now called Mandriva.
</para>

<note><para>
Till Kamppeter from Mandrakesoft is doing an excellent job in his spare time to maintain Linuxprinting.org and
Foomatic. So if you use it often, please send him a note showing your appreciation.
</para></note>
</sect3>

<sect3>
<title>Foomatic Database-Generated PPDs</title>

<para>
<indexterm><primary>Foomatic database</primary></indexterm>
<indexterm><primary>XML-based datasets</primary></indexterm>
<indexterm><primary>kprinter</primary></indexterm>
<indexterm><primary>gtklp</primary></indexterm>
<indexterm><primary>xpp</primary></indexterm>
<indexterm><primary>HP Photosmart</primary></indexterm>
<indexterm><primary>Epson Stylus inkjet</primary></indexterm>
<indexterm><primary>non-PostScript printers</primary></indexterm>
<indexterm><primary>raster</primary></indexterm>
The Foomatic database is an amazing piece of ingenuity in itself. Not only does it keep the printer and driver
information, but it is organized in a way that it can generate PPD files on the fly from its internal
XML-based datasets. While these PPDs are modeled to the Adobe specification of PPDs, the
Linuxprinting.org/Foomatic-PPDs do not normally drive PostScript printers. They are used to describe all the
bells and whistles you could ring or blow on an Epson Stylus inkjet, or an HP Photosmart, or what-have-you.
The main trick is one little additional line, not envisaged by the PPD specification, starting with the
<parameter>*cupsFilter</parameter> keyword. It tells the CUPS daemon how to proceed with the PostScript print
file (old-style Foomatic-PPDs named the cupsomatic filter script, while the new-style PPDs are now call
foomatic-rip). This filter script calls Ghostscript on the host system (the recommended variant is ESP
Ghostscript) to do the rendering work. foomatic-rip knows which filter or internal device setting it should
ask from Ghostscript to convert the PostScript print job into a raster format ready for the target device.
This usage of PPDs to describe the options of non-PostScript printers was the invention of the CUPS
developers. The rest is easy.  GUI tools (like KDE's marvelous <ulink
url="http://printing.kde.org/overview/kprinter.phtml">kprinter</ulink> or the GNOME <ulink
url="http://gtklp.sourceforge.net/">gtklp</ulink> xpp and the CUPS Web interface) read the PPD as well and use
this information to present the available settings to the user as an intuitive menu selection.
</para>
</sect3>
</sect2>

<sect2>
<title>foomatic-rip and Foomatic PPD Download and Installation</title>

<para>
Here are the steps to install a foomatic-rip-driven LaserJet 4 Plus-compatible
printer in CUPS (note that recent distributions of SuSE, UnitedLinux and
Mandrake may ship with a complete package of Foomatic-PPDs plus the
<command>foomatic-rip</command> utility. Going directly to
Linuxprinting.org ensures that you get the latest driver/PPD files).
</para>

<itemizedlist>
	<listitem><para>Open your browser at the Linuxprinting.org printer list <ulink url="http://www.linuxprinting.org/printer_list.cgi">page.</ulink>
	</para></listitem>

	<listitem><para>Check the complete list of printers in the 
	<ulink url="http://www.linuxprinting.org/printer_list.cgi?make=Anyone">database.</ulink>.
	</para></listitem>

	<listitem><para>Select your model and click on the link.
	</para></listitem>

	<listitem><para>You'll arrive at a page listing all drivers working with this
	model (for all printers, there will always be <emphasis>one</emphasis>
	recommended driver. Try this one first).
	</para></listitem>

	<listitem><para>In our case (HP LaserJet 4 Plus), we'll arrive at the default driver for the
	<ulink url="http://www.linuxprinting.org/show_printer.cgi?recnum=HP-LaserJet_4_Plus">HP-LaserJet 4 Plus.</ulink>
	</para></listitem>

	<listitem><para>The recommended driver is ljet4.</para></listitem>

	<listitem><para>Several links are provided here. You should visit them all if you
	are not familiar with the Linuxprinting.org database.
	</para></listitem>

	<listitem><para>There is a link to the database page for the
	<ulink url="http://www.linuxprinting.org/show_driver.cgi?driver=ljet4">ljet4</ulink>.
	On the driver's page, you'll find important and detailed information
	about how to use that driver within the various available
	spoolers.</para></listitem>

	<listitem><para>Another link may lead you to the home page of the
	author of the driver.</para></listitem>

	<listitem><para>Important links are the ones that provide hints with
	setup instructions for <ulink noescape="1" url="http://www.linuxprinting.org/cups-doc.html">CUPS</ulink>;
	<ulink url="http://www.linuxprinting.org/pdq-doc.html">PDQ</ulink>;
	<ulink url="http://www.linuxprinting.org/lpd-doc.html">LPD, LPRng, and GNUlpr</ulink>);
	as well as <ulink url="http://www.linuxprinting.org/ppr-doc.html">PPR</ulink>
	or <quote>spoolerless</quote> <ulink url="http://www.linuxprinting.org/direct-doc.html">printing</ulink>.
	</para></listitem>

	<listitem><para>You can view the PPD in your browser through this link:
	<ulink noescape="1" url="http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=1">http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=1</ulink>
	</para></listitem> <listitem><para>Most importantly, you can also generate and download
	the <ulink url="http://www.linuxprinting.org/ppd-o-matic.cgi?driver=ljet4&amp;printer=HP-LaserJet_4_Plus&amp;show=0">PPD</ulink>.
	</para></listitem>

	<listitem><para>The PPD contains all the information needed to use our
	model and the driver; once installed, this works transparently
	for the user. Later you'll only need to choose resolution, paper size,
	and so on, from the Web-based menu, or from the print dialog GUI, or from
	the command line.</para></listitem>

	<listitem><para>If you ended up on the drivers
	<ulink url="http://www.linuxprinting.org/show_driver.cgi?driver=ljet4">page</ulink>,
	you can choose to use the <quote>PPD-O-Matic</quote> online PPD generator
	program.</para></listitem>

	<listitem><para>Select the exact model and check either <guilabel>Download</guilabel> or
	<guilabel>Display PPD file</guilabel> and click <guilabel>Generate PPD file</guilabel>.</para></listitem>

	<listitem><para>If you save the PPD file from the browser view, please
	do not use cut and paste (since it could possibly damage line endings
	and tabs, which makes the PPD likely to fail its duty), but use <guimenuitem>Save
	as...</guimenuitem> in your browser's menu. (It is best to use the <guilabel>Download</guilabel> option
	directly from the Web page.)</para></listitem>

	<listitem><para>Another interesting part on each driver page is
	the <guimenuitem>Show execution details</guimenuitem> button. If you
	select your printer model and click on that button,
	a complete Ghostscript command line will be displayed, enumerating all options
	available for that combination of driver and printer model. This is a great way to
	<quote>learn Ghostscript by doing</quote>. It is also an excellent cheat sheet
	for all experienced users who need to reconstruct a good command line
	for that darned printing script, but can't remember the exact
	syntax. </para></listitem>

	<listitem><para>Sometime during your visit to Linuxprinting.org, save
	the PPD to a suitable place on your hard disk, say
	<filename>/path/to/my-printer.ppd</filename> (if you prefer to install
	your printers with the help of the CUPS Web interface, save the PPD to
	the <filename>/usr/share/cups/model/</filename> path and restart
	cupsd).</para></listitem>

	<listitem><para>Then install the printer with a suitable command line,
	like this: 
	</para>

	<para><screen>
	&rootprompt;<userinput>lpadmin -p laserjet4plus -v parallel:/dev/lp0 -E \
		-P path/to/my-printer.ppd</userinput>
	</screen></para></listitem>

	<listitem><para>For all the new-style <quote>Foomatic-PPDs</quote>
	from Linuxprinting.org, you also need a special CUPS filter named
	foomatic-rip. 
	</para></listitem>

	<listitem><para>The foomatic-rip Perl script itself also makes some
	interesting <ulink url="http://www.linuxprinting.org/foomatic2.9/download.cgi?filename=foomatic-rip&amp;show=1">reading</ulink>
	because it is well documented by Kamppeter's in-line comments (even
	non-Perl hackers will learn quite a bit about printing by reading
	it).</para></listitem>

	<listitem><para>Save foomatic-rip either directly in
	<filename>/usr/lib/cups/filter/foomatic-rip</filename> or somewhere in
	your $PATH (and remember to make it world-executable). Again,
	do not save by copy and paste but use the appropriate link or the
	<guimenuitem>Save as...</guimenuitem>  menu item in your browser.</para></listitem>

	<listitem><para>If you save foomatic-rip in your $PATH, create a symlink:
	<screen>
	&rootprompt;<userinput>cd /usr/lib/cups/filter/ ; ln -s `which foomatic-rip'</userinput>
	</screen>
	</para>

	<para>
	CUPS will discover this new available filter at startup after restarting
	cupsd.</para></listitem>
</itemizedlist>

<para>
Once you print to a print queue set up with the Foomatic PPD, CUPS will insert the appropriate commands and
comments into the resulting PostScript job file. foomatic-rip is able to read and act upon these and uses some
specially encoded Foomatic comments embedded in the job file. These in turn are used to construct
(transparently for you, the user) the complicated Ghostscript command line telling the printer driver exactly
how the resulting raster data should look and which printer commands to embed into the data stream. You need:
</para>

<itemizedlist>
	<listitem><para>A <quote>foomatic+something</quote> PPD &smbmdash; but this is not enough
	to print with CUPS (it is only <emphasis>one</emphasis> important
	component).</para></listitem>

	<listitem><para>The <parameter>foomatic-rip</parameter> filter script (Perl) in
	<filename>/usr/lib/cups/filters/</filename>.</para></listitem>

	<listitem><para>Perl to make foomatic-rip run.</para></listitem>

	<listitem><para>Ghostscript (because it is doing the main work,
	controlled by the PPD/foomatic-rip combo) to produce the raster data
	fit for your printer model's consumption.</para></listitem>

	<listitem><para>Ghostscript <emphasis>must</emphasis> (depending on
	the driver/model) contain support for a certain device representing
	the selected driver for your model (as shown by <command>gs -h</command>).</para></listitem>

	<listitem><para>foomatic-rip needs a new version of PPDs (PPD versions
	produced for cupsomatic do not work with foomatic-rip).</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Page Accounting with CUPS</title>


<para>
<indexterm><primary>CUPS</primary><secondary>Page Accounting</secondary></indexterm>
Often there are questions regarding print quotas where Samba users (that is, Windows clients) should not be
able to print beyond a certain number of pages or data volume per day, week, or month. This feature is
dependent on the real print subsystem you're using.  Samba's part is always to receive the job files from the
clients (filtered <emphasis>or</emphasis> unfiltered) and hand them over to this printing subsystem.
</para>

<para>
Of course one could hack things with one's own scripts. But then there is CUPS. CUPS supports quotas that can
be based on the size of jobs or on the number of pages or both, and can span any time period you want.
</para>

<sect2>
<title>Setting Up Quotas</title>

<para>
<indexterm><primary>CUPS</primary><secondary>quotas</secondary></indexterm>
This is an example command of how root would set a print quota in CUPS, assuming an existing printer named
<quote>quotaprinter</quote>:
<indexterm><primary>lpadmin</primary></indexterm>
<screen>
&rootprompt;<userinput>lpadmin -p quotaprinter -o job-quota-period=604800 \
	-o job-k-limit=1024 -o job-page-limit=100</userinput>
</screen></para>

<para>
This would limit every single user to print no more than 100 pages or 1024 KB of
data (whichever comes first) within the last 604,800 seconds ( = 1 week).
</para>
</sect2>

<sect2>
<title>Correct and Incorrect Accounting</title>

<para>
For CUPS to count correctly, the printfile needs to pass the CUPS pstops filter; otherwise it uses a dummy
count of <quote>one</quote>. Some print files do not pass it (e.g., image files), but then those are mostly
one-page jobs anyway. This also means that proprietary drivers for the target printer running on the client
computers and CUPS/Samba, which then spool these files as <quote>raw</quote> (i.e., leaving them untouched,
not filtering them), will be counted as one-pagers too!
</para>

<para>
You need to send PostScript from the clients (i.e., run a PostScript driver there) to have the chance to get
accounting done. If the printer is a non-PostScript model, you need to let CUPS do the job to convert the file
to a print-ready format for the target printer. This is currently working for about a thousand different
printer models.  Linuxprinting.org has a driver <ulink url="http://www.linuxprinting.org/printer_list.cgi">list</ulink>.
</para>
</sect2>

<sect2>
<title>Adobe and CUPS PostScript Drivers for Windows Clients</title>

<para>
<indexterm><primary>Adobe PostScript</primary></indexterm>
<indexterm><primary>pstops</primary></indexterm>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>pstoraster</primary></indexterm>
<indexterm><primary>PJL-header</primary></indexterm>
Before CUPS 1.1.16, your only option was to use the Adobe PostScript driver on the Windows clients. The output
of this driver was not always passed through the <command>pstops</command> filter on the CUPS/Samba side, and
therefore was not counted correctly (the reason is that it often, depending on the PPD being used, wrote a
PJL-header in front of the real PostScript, which caused CUPS to skip <command>pstops</command> and go
directly to the <command>pstoraster</command> stage).
</para>

<para>
From CUPS 1.1.16 and later releases, you can use the CUPS PostScript driver for Windows NT/200x/XP
clients (which is tagged in the download area of <filename>http://www.cups.org/</filename> as the
<filename>cups-samba-1.1.16.tar.gz</filename> package). It does <emphasis>not</emphasis> work for Windows
9x/Me clients, but it guarantees:
</para>

<itemizedlist>
	<listitem><para> <indexterm><primary>PJL</primary></indexterm> To not write a PJL-header.</para></listitem>

	<listitem><para>To still read and support all PJL-options named in the
	driver PPD with its own means.</para></listitem>

	<listitem><para>That the file will pass through the <command>pstops</command> filter
	on the CUPS/Samba server.</para></listitem>

	<listitem><para>To page-count correctly the print file.</para></listitem>
</itemizedlist>

<para>
You can read more about the setup of this combination in the man page for <command>cupsaddsmb</command> (which
is only present with CUPS installed, and only current from CUPS 1.1.16).
</para>
</sect2>

<sect2>
<title>The page_log File Syntax</title>

<para>
<indexterm><primary>page_log</primary></indexterm>
These are the items CUPS logs in the <filename>page_log</filename> for every page of a job:
</para>

<itemizedlist>
	<listitem><para>Printer name</para></listitem>

	<listitem><para>User name</para></listitem>

	<listitem><para>Job ID</para></listitem>

	<listitem><para>Time of printing</para></listitem>

	<listitem><para>Page number</para></listitem>

	<listitem><para>Number of copies</para></listitem>

	<listitem><para>A billing information string (optional)</para></listitem>

	<listitem><para>The host that sent the job (included since version 1.1.19)</para></listitem>
</itemizedlist>

<para>
Here is an extract of my CUPS server's <filename>page_log</filename> file to illustrate the
format and included items:
</para>

<para><screen>
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 1 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 2 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 3 3 #marketing 10.160.50.13
tec_IS2027 kurt 401 [22/Apr/2003:10:28:43 +0100] 4 3 #marketing 10.160.50.13
Dig9110 boss 402 [22/Apr/2003:10:33:22 +0100] 1 440 finance-dep 10.160.51.33
</screen></para>

<para>
This was job ID <parameter>401</parameter>, printed on <parameter>tec_IS2027</parameter>
by user <parameter>kurt</parameter>, a 64-page job printed in three copies, billed to
<parameter>#marketing</parameter>, and sent from IP address <constant>10.160.50.13.</constant>
 The next job had ID <parameter>402</parameter>, was sent by user <parameter>boss</parameter>
from IP address <constant>10.160.51.33</constant>, printed from one page 440 copies, and
is set to be billed to <parameter>finance-dep</parameter>.
</para>
</sect2>

<sect2>
<title>Possible Shortcomings</title>

<para>
What flaws or shortcomings are there with this quota system?
</para>

<itemizedlist>
	<listitem><para>The ones named above (wrongly logged job in case of
	printer hardware failure, and so on).</para></listitem>

	<listitem><para>In reality, CUPS counts the job pages that are being
	processed in <emphasis>software</emphasis> (that is, going through the
	RIP) rather than the physical sheets successfully leaving the
	printing device. Thus, if there is a jam while printing the fifth sheet out
	of 1,000 and the job is aborted by the printer, the page count will
	still show the figure of 1,000 for that job.</para></listitem>

	<listitem><para>All quotas are the same for all users (no flexibility
	to give the boss a higher quota than the clerk) and no support for
	groups.</para></listitem>

	<listitem><para>No means to read out the current balance or the
	<quote>used-up</quote> number of current quota.</para></listitem>

	<listitem><para>A user having used up 99 sheets of a 100 quota will
	still be able to send and print a 1,000 sheet job.</para></listitem>

	<listitem><para>A user being denied a job because of a filled-up quota
	does not get a meaningful error message from CUPS other than
	<quote>client-error-not-possible</quote>.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Future Developments</title>

<para>
This is the best system currently available, and there are huge
improvements under development for CUPS 1.2:
</para>

<itemizedlist>
	<listitem><para>Page counting will go into the backends (these talk
	directly to the printer and will increase the count in sync with the
	actual printing process; thus, a jam at the fifth sheet will lead to a
	stop in the counting).</para></listitem>

	<listitem><para>Quotas will be handled more flexibly.</para></listitem>

	<listitem><para>Probably there will be support for users to inquire
	about their accounts in advance.</para></listitem>

	<listitem><para>Probably there will be support for some other tools
	around this topic.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Other Accounting Tools</title>

<para>
Other accounting tools that can be used includes: PrintAnalyzer, pyKota, printbill, LogReport.
For more information regarding these tools you can try a Google search.
</para>

</sect2>
</sect1>

<sect1>
<title>Additional Material</title>

<para>
A printer queue with <emphasis>no</emphasis> PPD associated to it is a
<quote>raw</quote> printer, and all files will go directly there as received by the
spooler. The exceptions are file types <parameter>application/octet-stream</parameter>
that need the pass-through feature enabled. <quote>Raw</quote> queues do not do any
filtering at all; they hand the file directly to the CUPS backend.
This backend is responsible for sending the data to the device
(as in the <quote>device URI</quote> notation: <filename>lpd://, socket://,
smb://, ipp://, http://, parallel:/, serial:/, usb:/</filename>, and so on).
</para>

<para>
cupsomatic/Foomatic are <emphasis>not</emphasis> native CUPS drivers
and they do not ship with CUPS. They are a third-party add-on
developed at Linuxprinting.org. As such, they are a brilliant hack to
make all models (driven by Ghostscript drivers/filters in traditional
spoolers) also work via CUPS, with the same (good or bad!) quality as
in these other spoolers. <parameter>cupsomatic</parameter> is only a vehicle to execute a
Ghostscript command line at that stage in the CUPS filtering chain
where normally the native CUPS <parameter>pstoraster</parameter> filter would kick
in. <parameter>cupsomatic</parameter> bypasses <parameter>pstoraster</parameter>, kidnaps the print file from CUPS,
and redirects it to go through Ghostscript. CUPS accepts this
because the associated cupsomatic/foomatic-PPD specifies:

<programlisting>
*cupsFilter:  "application/vnd.cups-postscript 0 cupsomatic"
</programlisting>

This line persuades CUPS to hand the file to <parameter>cupsomatic</parameter> once it has
successfully converted it to the MIME type
<parameter>application/vnd.cups-postscript</parameter>. This conversion will not happen for
jobs arriving from Windows that are autotyped
<parameter>application/octet-stream</parameter>, with the according changes in
<filename>/etc/cups/mime.types</filename> in place.
</para>

<para>
CUPS is widely configurable and flexible, even regarding its filtering
mechanism. Another workaround in some situations would be to have in
<filename>/etc/cups/mime.types</filename> entries as follows:

<programlisting>
application/postscript           application/vnd.cups-raw  0  -
application/vnd.cups-postscript  application/vnd.cups-raw  0  -
</programlisting>

This would prevent all PostScript files from being filtered (rather,
they will through the virtual <emphasis>nullfilter</emphasis>
denoted with <quote>-</quote>). This could only be useful for PostScript printers. If you
want to print PostScript code on non-PostScript printers (provided they support ASCII
text printing), an entry as follows could be useful:

<programlisting>
*/*           application/vnd.cups-raw  0  -
</programlisting>

and would effectively send <emphasis>all</emphasis> files to the
backend without further processing.
</para>

<para>
You could have the following entry:

<programlisting>
application/vnd.cups-postscript application/vnd.cups-raw 0 \
	my_PJL_stripping_filter
</programlisting>

You will need to write a <parameter>my_PJL_stripping_filter</parameter>
(which could be a shell script) that parses the PostScript and removes the
unwanted PJL. This needs to conform to CUPS filter design
(mainly, receive and pass the parameters printername, job-id,
username, jobtitle, copies, print options, and possibly the
filename). It is installed as world executable into
<filename>/usr/lib/cups/filters/</filename> and is called by CUPS
if it encounters a MIME type <parameter>application/vnd.cups-postscript</parameter>.
</para>

<para>
CUPS can handle <parameter>-o job-hold-until=indefinite</parameter>.
This keeps the job in the queue on hold. It will only be printed
upon manual release by the printer operator. This is a requirement in
many central reproduction departments, where a few operators manage
the jobs of hundreds of users on some big machine, where no user is
allowed to have direct access (such as when the operators often need
to load the proper paper type before running the 10,000 page job
requested by marketing for the mailing, and so on).
</para>
</sect1>

<sect1>
<title>Autodeletion or Preservation of CUPS Spool Files</title>

<para>
<indexterm><primary>/var/spool/samba</primary></indexterm>
<indexterm><primary>/var/spool/cups/</primary></indexterm>
<indexterm><primary>cupsd.conf</primary></indexterm>
Samba print files pass through two spool directories. One is the incoming directory managed by Samba (set in
the <smbconfoption name="path">/var/spool/samba</smbconfoption> directive in the <smbconfsection
name="[printers]"/> section of &smb.conf;). The other is the spool directory of your UNIX print subsystem. For
CUPS it is normally <filename>/var/spool/cups/</filename>, as set by the <filename>cupsd.conf</filename>
directive <filename>RequestRoot /var/spool/cups</filename>.
</para>

<sect2>
<title>CUPS Configuration Settings Explained</title>

<para>
Some important parameter settings in the CUPS configuration file
<filename>cupsd.conf</filename> are:
</para>

<variablelist>

	<varlistentry><term>PreserveJobHistory Yes</term>
	<listitem><para>
	This keeps some details of jobs in cupsd's mind (well, it keeps the
	c12345, c12346, and so on, files in the CUPS spool directory, which does a
	similar job as the old-fashioned BSD-LPD control files). This is set
	to <quote>Yes</quote> as a default.
	</para></listitem></varlistentry>

	<varlistentry><term>PreserveJobFiles Yes</term>
	<listitem><para>
	This keeps the job files themselves in cupsd's mind
	(it keeps the d12345, d12346, etc., files in the CUPS spool
	directory). This is set to <quote>No</quote> as the CUPS
	default.
	</para></listitem></varlistentry>

	<varlistentry><term><quote>MaxJobs 500</quote></term>
	<listitem><para>
	This directive controls the maximum number of jobs
	that are kept in memory. Once the number of jobs reaches the limit,
	the oldest completed job is automatically purged from the system to
	make room for the new one. If all of the known jobs are still
	pending or active, then the new job will be rejected. Setting the
	maximum to 0 disables this functionality. The default setting is
	0.
	</para></listitem></varlistentry>
</variablelist>

<para>
(There are also additional settings for <parameter>MaxJobsPerUser</parameter> and
<parameter>MaxJobsPerPrinter</parameter>.)
</para>
</sect2>

<sect2>
<title>Preconditions</title>

<para>
For everything to work as it should, you need to have three things:
</para>

<itemizedlist>
	<listitem><para>A Samba smbd that is compiled against <filename>libcups</filename> (check
	on Linux by running <userinput>ldd `which smbd'</userinput>).</para></listitem>

	<listitem><para>A Samba-&smb.conf; setting of
			<smbconfoption name="printing">cups</smbconfoption>.</para></listitem>

	<listitem><para>Another Samba &smb.conf; setting of
			<smbconfoption name="printcap">cups</smbconfoption>.</para></listitem>
</itemizedlist>

<note><para>
In this case, all other manually set printing-related commands (like
<smbconfoption name="print command"/>, 
<smbconfoption name="lpq command"/>, 
<smbconfoption name="lprm command"/>, 
<smbconfoption name="lppause command"/>, and
<smbconfoption name="lpresume command"/>) are ignored, and they should normally have no
influence whatsoever on your printing.
</para></note>
</sect2>

<sect2>
<title>Manual Configuration</title>

<para>
If you want to do things manually, replace the <smbconfoption name="printing">cups</smbconfoption>
by <smbconfoption name="printing">bsd</smbconfoption>. Then your manually set commands may work
(I haven't tested this), and a <smbconfoption name="print command">lp -d %P %s; rm %s</smbconfoption>
may do what you need.
</para>
</sect2>
</sect1>

<sect1>
<title>Printing from CUPS to Windows-Attached Printers</title>

<para>
<indexterm><primary>smbspool</primary></indexterm>
<indexterm><primary>backends</primary></indexterm>
From time to time the question arises, how can you print <emphasis>to</emphasis> a Windows-attached printer
<emphasis>from</emphasis> Samba? Normally the local connection from Windows host to printer would be done by
USB or parallel cable, but this does not matter to Samba. From here only an SMB connection needs to be opened
to the Windows host. Of course, this printer must be shared first. As you have learned by now, CUPS uses
<emphasis>backends</emphasis> to talk to printers and other servers. To talk to Windows shared printers, you
need to use the <filename>smb</filename> (surprise, surprise!) backend. Check if this is in the CUPS backend
directory. This usually resides in <filename>/usr/lib/cups/backend/</filename>. You need to find an
<filename>smb</filename> file there. It should be a symlink to <filename>smbspool</filename>, and the file
must exist and be executable:
<screen>
&rootprompt;<userinput>ls -l /usr/lib/cups/backend/</userinput>
total 253
drwxr-xr-x    3 root   root     720 Apr 30 19:04 .
drwxr-xr-x    6 root   root     125 Dec 19 17:13 ..
-rwxr-xr-x    1 root   root   10692 Feb 16 21:29 canon
-rwxr-xr-x    1 root   root   10692 Feb 16 21:29 epson
lrwxrwxrwx    1 root   root       3 Apr 17 22:50 http -&gt; ipp
-rwxr-xr-x    1 root   root   17316 Apr 17 22:50 ipp
-rwxr-xr-x    1 root   root   15420 Apr 20 17:01 lpd
-rwxr-xr-x    1 root   root    8656 Apr 20 17:01 parallel
-rwxr-xr-x    1 root   root    2162 Mar 31 23:15 pdfdistiller
lrwxrwxrwx    1 root   root      25 Apr 30 19:04 ptal -&gt; /usr/sbin/ptal-cups
-rwxr-xr-x    1 root   root    6284 Apr 20 17:01 scsi
lrwxrwxrwx    1 root   root      17 Apr  2 03:11 smb -&gt; /usr/bin/smbspool
-rwxr-xr-x    1 root   root    7912 Apr 20 17:01 socket
-rwxr-xr-x    1 root   root    9012 Apr 20 17:01 usb

&rootprompt;<userinput>ls -l `which smbspool`</userinput>
-rwxr-xr-x    1 root   root  563245 Dec 28 14:49 /usr/bin/smbspool
</screen></para>

<para>
If this symlink does not exist, create it:
<screen>
&rootprompt;<userinput>ln -s `which smbspool` /usr/lib/cups/backend/smb</userinput>
</screen></para>

<para>
<indexterm><primary>smbspool</primary></indexterm>
<indexterm><primary>troubleshooting</primary></indexterm>
<command>smbspool</command> was written by Mike Sweet from the CUPS folks. It is included and ships with
Samba. It may also be used with print subsystems other than CUPS, to spool jobs to Windows printer shares. To
set up printer <replaceable>winprinter</replaceable> on CUPS, you need to have a driver for it. Essentially
this means to convert the print data on the CUPS/Samba host to a format that the printer can digest (the
Windows host is unable to convert any files you may send). This also means you should be able to print to the
printer if it were hooked directly at your Samba/CUPS host. For troubleshooting purposes, this is what you
should do to determine if that part of the process chain is in order. Then proceed to fix the network
connection/authentication to the Windows host, and so on.
</para>

<para>
To install a printer with the <parameter>smb</parameter> backend on CUPS, use this command:
</para>

<para><screen>
&rootprompt;<userinput>lpadmin -p winprinter -v smb://WINDOWSNETBIOSNAME/printersharename \
  -P /path/to/PPD</userinput>
</screen></para>

<para>
<indexterm><primary>PostScript printers</primary></indexterm>
<indexterm><primary>PPD</primary></indexterm>
<indexterm><primary>Windows NT PostScript driver</primary></indexterm>
The PPD must be able to direct CUPS to generate the print data for the target model. For PostScript printers,
just use the PPD that would be used with the Windows NT PostScript driver. But what can you do if the printer
is only accessible with a password? Or if the printer's host is part of another workgroup? This is provided
for: You can include the required parameters as part of the <filename>smb://</filename> device-URI like this:
</para>

<itemizedlist>
	<listitem><para><filename>smb://WORKGROUP/WINDOWSNETBIOSNAME/printersharename</filename></para></listitem>
	<listitem><para><filename>smb://username:password@WORKGROUP/WINDOWSNETBIOSNAME/printersharename</filename></para></listitem>
	<listitem><para><filename>smb://username:password@WINDOWSNETBIOSNAME/printersharename</filename></para></listitem>
</itemizedlist>

<para>
Note that the device URI will be visible in the process list of the Samba server (e.g., when someone uses the
<command>ps -aux</command> command on Linux), even if the username and passwords are sanitized before they get
written into the log files. This is an inherently insecure option; however, it is the only one. Don't use it
if you want to protect your passwords. Better share the printer in a way that does not require a password!
Printing will only work if you have a working NetBIOS name resolution up and running. Note that this is a
feature of CUPS and you do not necessarily need to have smbd running.

</para>
</sect1>

<sect1>
<title>More CUPS Filtering Chains</title>

<para>
The diagrams in <link linkend="cups1">Filtering Chain 1</link> and <link linkend="cups2">Filtering Chain with
cupsomatic</link> show how CUPS handles print jobs.
</para>

<figure id="cups1">
	<title>Filtering Chain 1.</title>
	<imagefile>cups1</imagefile>
</figure>

<!-- JJJ -->
<figure id="cups2">
	<title>Filtering Chain with cupsomatic</title>
	<imagefile scale="45">cups2</imagefile>
</figure>

</sect1>

<sect1>
<title>Common Errors</title>

	<sect2>
	<title>Windows 9x/Me Client Can't Install Driver</title>

	<para>For Windows 9x/Me, clients require the printer names to be eight
	characters (or <quote>8 plus 3 chars suffix</quote>) max; otherwise, the driver files
	will not get transferred when you want to download them from Samba.</para>

	</sect2>

	<sect2 id="root-ask-loop">
	<title><quote>cupsaddsmb</quote> Keeps Asking for Root Password in Never-ending Loop</title>

	<para>Have you set <smbconfoption name="security">user</smbconfoption>? Have
	you used <command>smbpasswd</command> to give root a Samba account?
	You can do two things: open another terminal and execute
	<command>smbpasswd -a root</command> to create the account and
	continue entering the password into the first terminal. Or, break
	out of the loop by pressing Enter twice (without trying to type a
	password).</para>

	<para>
	If the error is <quote>Tree connect failed: NT_STATUS_BAD_NETWORK_NAME</quote>, 
	you may have forgotten to create the <filename>/etc/samba/drivers</filename> directory.
	</para>
	</sect2>

	<sect2>
	<title><quote>cupsaddsmb</quote> or <quote>rpcclient addriver</quote> Emit Error</title>

	<para>
	If <command>cupsaddsmb</command>, or <command>rpcclient addriver</command> emit the error message
	WERR_BAD_PASSWORD, refer to <link linkend="root-ask-loop">the previous common error</link>.
	</para>
	
	</sect2>

	<sect2>
	<title><quote>cupsaddsmb</quote> Errors</title>

	<para>
	The use of <quote>cupsaddsmb</quote> gives <quote>No PPD file for printer...</quote> 
	message while PPD file is present.  What might the problem be?
	</para>

	<para>
	Have you enabled printer sharing on CUPS? This means, do you have a <literal>&lt;Location
	/printers&gt;....&lt;/Location&gt;</literal> section in CUPS server's <filename>cupsd.conf</filename> that
	does not deny access to the host you run <quote>cupsaddsmb</quote> from?  It <emphasis>could</emphasis> be an
	issue if you use cupsaddsmb remotely, or if you use it with a <option>-h</option> parameter:
	<userinput>cupsaddsmb -H sambaserver -h cupsserver -v printername</userinput>.
	</para>

	<para>Is your <parameter>TempDir</parameter> directive in
	<filename>cupsd.conf</filename> set to a valid value, and is it writable?
	</para>

	</sect2>

	<sect2>
		<title>Client Can't Connect to Samba Printer</title>

	<para>Use <command>smbstatus</command> to check which user
	you are from Samba's point of view. Do you have the privileges to
	write into the <smbconfsection name="[print$]"/>
	share?</para>

	</sect2>

	<sect2>
	<title>New Account Reconnection from Windows 200x/XP Troubles</title>

<para>
Once you are connected as the wrong user (for example, as <constant>nobody</constant>, which often occurs if
you have <smbconfoption name="map to guest">bad user</smbconfoption>), Windows Explorer will not accept an
attempt to connect again as a different user. There will not be any bytes transferred on the wire to Samba,
but still you'll see a stupid error message that makes you think Samba has denied access. Use
<command>smbstatus</command> to check for active connections. Kill the PIDs. You still can't re-connect, and
you get the dreaded <computeroutput>You can't connect with a second account from the same
machine</computeroutput> message as soon as you try. And you do not see a single byte arriving at Samba (see
logs; use <quote>ethereal</quote>) indicating a renewed connection attempt. Shut all Explorer Windows.  This
makes Windows forget what it has cached in its memory as established connections. Then reconnect as the right
user. The best method is to use a DOS terminal window and <emphasis>first</emphasis> do <userinput>net use z:
\\&example.server.samba;\print$ /user:root</userinput>. Check with <command>smbstatus</command> that you are
connected under a different account. Now open the <guilabel>Printers</guilabel> folder (on the Samba server in
the <guilabel>Network Neighborhood</guilabel>), right-click on the printer in question, and select
<guibutton>Connect....</guibutton>.
</para>
</sect2>

<sect2>
<title>Avoid Being Connected to the Samba Server as the Wrong User</title>
	
<para>
<indexterm><primary>smbstatus</primary></indexterm>
You see per <command>smbstatus</command> that you are connected as user nobody, but you want to be root or
printer admin. This is probably due to <smbconfoption name="map to guest">bad user</smbconfoption>, which
silently connected you under the guest account when you gave (maybe by accident) an incorrect username. Remove
<smbconfoption name="map to guest"/> if you want to prevent this.
</para>
</sect2>

<sect2>
<title>Upgrading to CUPS Drivers from Adobe Drivers</title>

<para>
This information came from a mailing list posting regarding problems experienced when
upgrading from Adobe drivers to CUPS drivers on Microsoft Windows NT/200x/XP clients.
</para>

<para>First delete all old Adobe-using printers. Then delete all old Adobe drivers. (On Windows 200x/XP, right-click in
the background of <guilabel>Printers</guilabel> folder, select <guimenuitem>Server Properties...</guimenuitem>, select
tab <guilabel>Drivers</guilabel>, and delete here).</para>
</sect2>

<sect2>
<title>Can't Use <quote>cupsaddsmb</quote> on Samba Server, Which Is a PDC</title>

<para>Do you use the <quote>naked</quote> root user name? Try to do it
this way: <userinput>cupsaddsmb -U <replaceable>DOMAINNAME</replaceable>\\root -v
<replaceable>printername</replaceable></userinput>> (note the two backslashes: the first one is
required to <quote>escape</quote> the second one).</para>

</sect2>

<sect2>
<title>Deleted Windows 200x Printer Driver Is Still Shown</title>

<para>Deleting a printer on the client will not delete the
driver too (to verify, right-click on the white background of the
<guilabel>Printers</guilabel> folder, select <guimenuitem>Server Properties</guimenuitem> and click on the
<guilabel>Drivers</guilabel> tab). These same old drivers will be re-used when you try to
install a printer with the same name. If you want to update to a new
driver, delete the old ones first. Deletion is only possible if no
other printer uses the same driver.</para>
</sect2>

<sect2>
<title>Windows 200x/XP Local Security Policies</title>

<indexterm><primary>Local security policies</primary></indexterm>
<indexterm><primary>unsigned drivers</primary></indexterm>
<para>Local security policies may not allow the installation of unsigned drivers &smbmdash; <quote>local
security policies</quote> may not allow the installation of printer drivers at all.</para>

</sect2>

<sect2>
<title>Administrator Cannot Install Printers for All Local Users</title>

<para>
<indexterm><primary>SMB printers</primary></indexterm>
<indexterm><primary>IPP client</primary></indexterm>
Windows XP handles SMB printers on a <quote>per-user</quote> basis.
This means every user needs to install the printer himself or herself. To have a printer available for
everybody, you might want to use the built-in IPP client capabilities of Win XP. Add a printer with the print
path of <parameter>http://cupsserver:631/printers/printername</parameter>.  We're still looking into this one.
Maybe a logon script could automatically install printers for all users.
</para>

</sect2>

<sect2>
<title>Print Change, Notify Functions on NT Clients</title>

<para>For print change, notify functions on NT++ clients.  These need to run the <command>Server</command>
service first (renamed to <command>File &amp; Print Sharing for MS Networks</command> in XP).</para>

</sect2>

<sect2>
<title>Windows XP SP1</title>

<para>Windows XP SP1 introduced a Point and Print Restriction Policy (this restriction does not apply to
<quote>Administrator</quote> or <quote>Power User</quote> groups of users). In Group Policy Object Editor, go
to <guimenu>User Configuration -> Administrative Templates -> Control Panel -> Printers</guimenu>. The policy
is automatically set to <constant>Enabled</constant> and the <constant>Users can only Point and Print to
machines in their Forest</constant> . You probably need to change it to <constant>Disabled</constant> or
<constant>Users can only Point and Print to these servers</constant> to make driver downloads from Samba
possible.
</para>
</sect2>

<sect2>
<title>Print Options for All Users Can't Be Set on Windows 200x/XP</title>

<para>How are you doing it? I bet the wrong way (it is not easy to find out, though). There are three
different ways to bring you to a dialog that <emphasis>seems</emphasis> to set everything. All three dialogs
<emphasis>look</emphasis> the same, yet only one of them does what you intend. You need to be Administrator or
Print Administrator to do this for all users. Here is how I do it on XP:
</para>

<orderedlist numeration="upperalpha">

	<listitem><para>The first wrong way:

		<orderedlist>
		<listitem><para>Open the <guilabel>Printers</guilabel>
		folder.</para></listitem>

		<listitem><para>Right-click on the printer
		(<guilabel>remoteprinter on cupshost</guilabel>) and
		select in context menu <guimenuitem>Printing
		Preferences...</guimenuitem></para></listitem>.

		<listitem><para>Look at this dialog closely and remember what it looks like.</para></listitem>
		</orderedlist>
	</para></listitem>

	<listitem><para>The second wrong way:
	<orderedlist>
		<listitem><para>Open the <guilabel>Printers</guilabel> folder.</para></listitem>

		<listitem><para>Right-click on the printer (<guilabel>remoteprinter on
		cupshost</guilabel>) and select the context menu
		<guimenuitem>Properties</guimenuitem>.</para></listitem>

		<listitem><para>Click on the <guilabel>General</guilabel> tab.</para></listitem>

		<listitem><para>Click on the button <guibutton>Printing
		Preferences...</guibutton></para></listitem>.

		<listitem><para>A new dialog opens. Keep this dialog open and go back
		to the parent dialog.</para></listitem>
	</orderedlist>
	</para></listitem>

	<listitem><para>The third and correct way: 
	<orderedlist>
		<listitem><para>Open the <guilabel>Printers</guilabel> folder.</para></listitem>

		<listitem><para>Right-click on the printer (<guilabel>remoteprinter on
		cupshost</guilabel>) and select the context menu
		<guimenuitem>Properties</guimenuitem>.</para></listitem>

		<listitem><para>Click on the <guilabel>Advanced</guilabel>
		tab. (If everything is <quote>grayed out,</quote> then you are not logged
		in as a user with enough privileges).</para></listitem>

		<listitem><para>Click on the <guibutton>Printing
		Defaults...</guibutton> button.</para></listitem>

		<listitem><para>On any of the two new tabs, click on the
		<guibutton>Advanced...</guibutton> button.</para></listitem>

		<listitem><para>A new dialog opens. Compare this one to the other
		identical-looking one from step <quote>B.5</quote> or A.3".</para></listitem>
	</orderedlist>
	</para></listitem>
</orderedlist>

<para>
Do you see any difference? I don't either. However, only the last one, which you arrived at with steps
<quote>C.1. to C.6.</quote>, will save any settings permanently and be the defaults for new users. If you want
all clients to get the same defaults, you need to conduct these steps <emphasis>as Administrator</emphasis>
(<smbconfoption name="printer admin"/> in &smb.conf;) <emphasis>before</emphasis> a client downloads the
driver (the clients can later set their own <emphasis>per-user defaults</emphasis> by following the procedures
<emphasis>A</emphasis> or <emphasis>B</emphasis>).
</para>

</sect2>

<sect2>
<title>Most Common Blunders in Driver Settings on Windows Clients</title>

<para>
Don't use <parameter>Optimize for Speed</parameter>, but use <parameter>Optimize for Portability</parameter>
instead (Adobe PS Driver). Don't use <parameter>Page Independence: No</parameter>. Always settle with
<parameter>Page Independence: Yes</parameter> (Microsoft PS Driver and CUPS PS Driver for Windows NT/200x/XP).
If there are problems with fonts, use <parameter>Download as Softfont into printer</parameter> (Adobe PS
Driver). For <guilabel>TrueType Download Options</guilabel> choose <constant>Outline</constant>. Use
PostScript Level 2 if you are having trouble with a non-PS printer and if there is a choice.
</para>

</sect2>

<sect2>
<title><command>cupsaddsmb</command> Does Not Work with Newly Installed Printer</title>

<para>
Symptom: The last command of <command>cupsaddsmb</command> does not complete successfully. If the <command>cmd
= setdriver printername printername</command> result was NT_STATUS_UNSUCCESSFUL, then possibly the printer was
not yet recognized by Samba. Did it show up in Network Neighborhood? Did it show up in <command>rpcclient
hostname -c `enumprinters'</command>? Restart smbd (or send a <command>kill -HUP</command> to all processes
listed by <command>smbstatus</command>, and try again.
</para></sect2>

<sect2>
<title>Permissions on <filename>/var/spool/samba/</filename> Get Reset After Each Reboot</title>

<para>
Have you ever by accident set the CUPS spool directory to the same location (<parameter>RequestRoot
/var/spool/samba/</parameter> in <filename>cupsd.conf</filename> or the other way round:
<filename>/var/spool/cups/</filename> is set as <smbconfoption name="path"/>> in the <smbconfsection
name="[printers]"/> section)? These <parameter>must</parameter> be different. Set <parameter>RequestRoot
/var/spool/cups/</parameter> in <filename>cupsd.conf</filename> and <smbconfoption name="path">
/var/spool/samba</smbconfoption> in the <smbconfsection name="[printers]"/> section of &smb.conf;. Otherwise,
cupsd will sanitize permissions to its spool directory with each restart and printing will not work reliably.
</para>

</sect2>

<sect2>
<title>Print Queue Called <quote>lp</quote> Mishandles Print Jobs</title>

<para>
In this case a print queue called <quote>lp</quote> intermittently swallows jobs and
spits out completely different ones from what was sent.
</para>

<para>
<indexterm><primary>lp</primary></indexterm>
<indexterm><primary>Implicit Classes</primary></indexterm>
<indexterm><primary>BrowseShortNames</primary></indexterm>
It is a bad idea to name any printer <quote>lp</quote>. This is the traditional UNIX name for the default
printer. CUPS may be set up to do an automatic creation of Implicit Classes. This means, to group all printers
with the same name to a pool of devices and load-balance the jobs across them in a round-robin fashion.
Chances are high that someone else has a printer named <quote>lp</quote> too. You may receive that person's
jobs and send your own to his or her device unwittingly. To have tight control over the printer names, set
<parameter>BrowseShortNames No</parameter>. It will present any printer as
<replaceable>printername@cupshost</replaceable>, which gives you better control over what may happen in a
large networked environment.
</para>

</sect2>

<sect2>
<title>Location of Adobe PostScript Driver Files for <quote>cupsaddsmb</quote></title>

<para>
Use <command>smbclient</command> to connect to any Windows box with a shared PostScript printer:
<command>smbclient //windowsbox/print\$ -U guest</command>. You can navigate to the
<filename>W32X86/2</filename> subdir to <command>mget ADOBE*</command> and other files or to
<filename>WIN40/0</filename> to do the same.  Another option is to download the <filename>*.exe</filename>
packaged files from the Adobe Web site.
</para>

</sect2>

</sect1>

<sect1>
<title>Overview of the CUPS Printing Processes</title>

<para>
A complete overview of the CUPS printing processes can be found in <link linkend="a_small">the CUPS
Printing Overview diagram</link>.
</para>

<figure id="a_small">
	<title>CUPS Printing Overview.</title>
	<imagefile scale="45">a_small</imagefile>
</figure>
</sect1>

</chapter>
