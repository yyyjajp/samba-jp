<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="SambaHA">
<chapterinfo>
	&author.jht;
	&author.jeremy;
</chapterinfo>

<title>高可用性</title>

<sect1>
<title>機能と利便性</title>

<para>
<indexterm><primary>可用性</primary></indexterm>
<indexterm><primary>intolerance</primary></indexterm>
<indexterm><primary>vital task</primary></indexterm>
ネットワーク管理者は、しばしばファイルと印刷サービスの可用性について関心を持っている。
ネットワークユーザは、きわめて重要な、責任ある仕事を遂行するのに依存するサービスに
対して、厳しい態度をとりがちである。
</para>

<para>
コンピュータルームにあるサインが、スタッフに、彼らの責任を思い出させるのに
役に立った。それは以下のようなものであった:
A sign in a computer room served to remind staff of their responsibilities. It read:
</para>

<blockquote>
<para>
<indexterm><primary>fail</primary></indexterm>
<indexterm><primary>managed by humans</primary></indexterm>
<indexterm><primary>economically wise</primary></indexterm>
<indexterm><primary>anticipate failure</primary></indexterm>
すべての人間は間違う、大きな事でも小さな事でも、絶えず失敗する方法で。機械も同様に
故障する。コンピュータは、人によって管理する機械であり、故障の結果は鮮烈である。
あなたの責任は、失敗を扱うことであり、それを予想することであり、人間らしさを
可能な限り排除し、適切な費用で目的を達成することである。
あなたの動作は、問題の一部分か、あるいは解決方法の一部分だろうか?
All humans fail, in both great and small ways we fail continually. Machines fail too.
Computers are machines that are managed by humans, the fallout from failure
can be spectacular. Your responsibility is to deal with failure, to anticipate it
and to eliminate it as far as is humanly and economically wise to achieve.
Are your actions part of the problem or part of the solution?
</para>
</blockquote>

<para>
もしも、計画された、かつ精算セキュリティな方法で障害を扱うならば、最初に問題を理解する
必要がある。それがこの章の目的である。
</para>

<para>
<indexterm><primary>高可用性high availability</primary></indexterm>
<indexterm><primary>CIFS/SMB</primary></indexterm>
<indexterm><primary>state of knowledge</primary></indexterm>
付加的に、以下の議論の中には、障害に対してどのようにネットワーク基盤を提供するかに
ついての情報の元が存在する。ここでの目的は、高可用性という題に対する長い論文を
提供することではない。さらに追加すると、高可用性ソリューションの詳細な動作例を
提供しないということを、意識的に行っている。その代わりに、
Sambaと他のCIFS/SMB技術の実装に適用する、高可用性における知識と習慣の現在の状態の
プレゼンテーションにおいて、純粋に着目する、詳細な文書を提供する試みを、誰かが
立ち上げるだろうという希望的観測をこめて、問題の概要を提供する。
Parenthetically, in the following discussion there are seeds of information on how to
provision a network infrastructure against failure. Our purpose here is not to provide
a lengthy dissertation on the subject of high availability. Additionally, we have made
a conscious decision to not provide detailed working examples of high availability
solutions; instead we present an overview of the issues in the hope that someone will
rise to the challenge of providing a detailed document that is focused purely on
presentation of the current state of knowledge and practice in high availability as it
applies to the deployment of Samba and other CIFS/SMB technologies.
</para>

</sect1>

<sect1>
<title>技術的な議論</title>

<para>
<indexterm><primary>SambaXPカンファレンス</primary></indexterm>
<indexterm><primary>ドイツ</primary></indexterm>
<indexterm><primary>inspired structure</primary></indexterm>
以下の要約は、2003年4月に、ドイツのゲッティンンゲンで行われた、SambaXP 2003
カンファレンスで、Jeremy Allisonによって発表されたものの一部である。
素材は他のソースから追加されたが、それをフォローする構造にインスパイアされた
のはJeremyであった。
The following summary was part of a presentation by Jeremy Allison at the SambaXP 2003
conference that was held at Goettingen, Germany, in April 2003. Material has been added
from other sources, but it was Jeremy who inspired the structure that follows.
</para>

	<sect2>
	<title>最終目的</title>

	<para>
<indexterm><primary>クラスタリング技術</primary></indexterm>
<indexterm><primary>affordable power</primary></indexterm>
<indexterm><primary>無停止サービス</primary></indexterm>
	すべてのクラスタリング技術は以下の1つあるいはそれ以上を達成することを目的としている:
	</para>

	<itemizedlist>
		<listitem><para>コンピュータの能力を最大限使えること。</para></listitem>
		<listitem><para>より高速なプロトコル実行を行うこと。</para></listitem>
		<listitem><para>無停止サービスを提供すること。</para></listitem>
		<listitem><para>単一障害点を避けること。</para></listitem>
		<listitem><para>資源を最も効果的に使うこと。</para></listitem>
	</itemizedlist>

	<para>
	クラスタ化されたファイルサーバは理想的に以下の属性を有している:
<indexterm><primary>クラスタ化されたファイルサーバ</primary></indexterm>
<indexterm><primary>透過的な接続</primary></indexterm>
<indexterm><primary>透過的な再接続</primary></indexterm>
<indexterm><primary>分散ファイルシステム</primary></indexterm>
	</para>

	<itemizedlist>
		<listitem><para>すべてのクライアントはどのサーバにも透過的に接続できる。</para></listitem>
		<listitem><para>サーバが故障するとクライアントは透過的に他のサーバに再接続できる。</para></listitem>
		<listitem><para>すべてのサーバは、同じファイル群を提供する。</para></listitem>
		<listitem><para>すべてのファイルの変更は、すべてのサーバで直接行われるように見える。</para>
			<itemizedlist><listitem><para>分散ファイルシステムが必要。</para></listitem></itemizedlist></listitem>
		<listitem><para>より多くのサーバやディスクを追加することで、無限に拡張できる。</para></listitem>
	</itemizedlist>

	</sect2>

	<sect2>
	<title>これがなぜ難しいか?</title>

	<para>
	簡単に言うと、問題は<emphasis>状態(state)</emphasis>にある。
	</para>

	<itemizedlist>
		<listitem>
			<para>
<indexterm><primary>state information</primary></indexterm>
			すべてのTCP/IP接続はステート情報に依存する。
			</para>
			<para>
<indexterm><primary>TCP failover</primary></indexterm>
			TCP接続はパケットシーケンス番号を持っている。このシーケンス
			番号は、シームレスなTCPフェールオーバーを引き起こすために、
			クラスタ中で、すべてのマシン上で動的に更新される必要がある。
			</para>
		</listitem>
		<listitem>
			<para>
<indexterm><primary>CIFS/SMB</primary></indexterm>
<indexterm><primary>TCP</primary></indexterm>
			CIFS/SMB(Windowsネットワークプロトコル)はTCP接続を使用している。
			</para>
			<para>
			これは、基本的な設計の見地から、フェイルオーバーは真剣に考慮
			されていない事を意味する。
			<itemizedlist>
				<listitem><para>
				すべての現在のSMBクラスタはフェールオーバーソリューション
				である。&smbmdash;これらは再接続するクライアントに
				頼っている。これは、サーバのフェールオーバーを提供するが、
				クライアントはサーバの故障のために情報を失う可能性がある。
<indexterm><primary>サーバの故障</primary></indexterm>
				</para></listitem>
			</itemizedlist>
			</para>
		</listitem>
		<listitem>
			<para>
			サーバはクライアント接続に関するステート情報を保存する。
			<itemizedlist>
<indexterm><primary>state</primary></indexterm>
				<listitem><para>CIFS/SMBには多くのステートがある。</para></listitem>
				<listitem><para>すべてのファイルのオープンは、共有モードを
				    チェックするために他のオープンしているファイルと比較する。</para></listitem>
			</itemizedlist>
			</para>
		</listitem>
	</itemizedlist>

		<sect3>
		<title>最先端の状況</title>

		<para>
<indexterm><primary>クラスタサービス</primary></indexterm>
<indexterm><primary>単一サーバ</primary></indexterm>
<indexterm><primary>TCPデータストリーム</primary></indexterm>
<indexterm><primary>front-end virtual server</primary></indexterm>
<indexterm><primary>仮想サーバ</primary></indexterm>
<indexterm><primary>de-multiplex</primary></indexterm>
<indexterm><primary>SMB</primary></indexterm>
		1つの名前と1つのIPアドレスを持つ単一のサーバのように、ファイルサーバの
		クラスタを見せるためにすることは可能で、クライアントから受信した
		TCPデータストリームはフロントエンドの仮想サーバによって処理される必要が
		ある。このサーバはSMBプロトコルレイヤレベルで、入力したパケットを分割し、
		次に、クラスタ中の異なったサーバにSMBパケットを中継する。
		</para>

		<para>
<indexterm><primary>IPC$接続</primary></indexterm>
<indexterm><primary>RPC呼び出し</primary></indexterm>
		印刷とユーザ検索要求を扱うために、1つのサーバに対する、すべてのIPC$接続と
		RPC呼び出しを分割することができた。RPC印刷ハンドルは、異なったIPC$
		セッションで共有される。&smbmdash;これはクラスタサーバをまたがって
		これを分割するのは難しい!
		One could split all IPC$ connections and RPC calls to one server to handle printing and user
		lookup requirements. RPC printing handles are shared between different IPC4 sessions &smbmdash; it is
		hard to split this across clustered servers!
		</para>

		<para>
		概念的に、すべての他のサーバはファイルサービスのみ提供する。これは
		集中するよりも簡単な問題である。
		Conceptually speaking, all other servers would then provide only file services. This is a simpler
		problem to concentrate on.
		</para>

		</sect3>

		<sect3>
		<title>SMBリクエストの分割</title>

		<para>
<indexterm><primary>SMBリクエスト</primary></indexterm>
<indexterm><primary>SMBステート情報</primary></indexterm>
<indexterm><primary>フロントエンド仮想サーバ</primary></indexterm>
<indexterm><primary>込み入った問題</primary></indexterm>
		SMBリクエストを分割する事は、SMBステート情報を知っていることが要求され、そのすべては
		フロントエンドの<emphasis>仮想</emphasis>サーバによって保持されねばならない。
		これは解決するのには複雑で難しい問題である。
		</para>

		<para>
<indexterm><primary>vuid</primary></indexterm>
<indexterm><primary>tid</primary></indexterm>
<indexterm><primary>fid</primary></indexterm>
		Windows XPとその後継は、その意味を変更し、そのため、ステート情報
		(vuid,tid,fid)は操作が成功するために一致しなければならない。これは、
		以前よりも物事を単純にし、前へ進むためのよい一歩である。
		</para>

		<para>
<indexterm><primary>SMBリクエスト</primary></indexterm>
<indexterm><primary>ターミナルサーバ</primary></indexterm>
		SMBリクエストは、それに対応するサーバにvuidによって送られる。
		このソリューションを作り出すコードは現在存在しない。この問題は、
		Samba中で、Windows 2000ターミナルサーバからの複数のリクエストからの
		リクエストを正しく処理する問題と、概念的に似ている。
		</para>

		<para>
<indexterm><primary>分割</primary></indexterm>
		直接クライアントにサーバプールを提示することで開始するという
		1つの可能性がある。これは、分割ステップを省略できる。
		</para>

		</sect3>

		<sect3>
		<title>分散ファイルシステムの試み</title>

		<para>
<indexterm><primary>分散ファイルシステム</primary></indexterm>
		UNIXとLinux用に、たくさんの分散ファイルシステムがある。
		</para>

		<para>
<indexterm><primary>バックエンド</primary></indexterm>
<indexterm><primary>SMB semantics</primary></indexterm>
<indexterm><primary>共有モード</primary></indexterm>
<indexterm><primary>locking</primary></indexterm>
<indexterm><primary>oplock</primary></indexterm>
<indexterm><primary>分散ファイルシステム</primary></indexterm>
		SMB文法を認識することを、ずっと心にとめている間は、我々のクラスタの
		バックエンドに多くが適用できる(共有モード、ロックとoplock問題は特に)。
		一般的な自由に使える分散ファイルシステムには以下がある:
		Many could be adopted to backend our cluster, so long as awareness of SMB
		semantics is kept in mind (share modes, locking, and oplock issues in particular).
		Common free distributed file systems include:
<indexterm><primary>NFS</primary></indexterm>
<indexterm><primary>AFS</primary></indexterm>
<indexterm><primary>OpenGFS</primary></indexterm>
<indexterm><primary>Lustre</primary></indexterm>
		</para>

		<itemizedlist>
			<listitem><para>NFS</para></listitem>
			<listitem><para>AFS</para></listitem>
			<listitem><para>OpenGFS</para></listitem>
			<listitem><para>Lustre</para></listitem>
		</itemizedlist>

		<para>
<indexterm><primary>サーバプール</primary></indexterm>
		サーバプール(クラスタ)は、もしもすべてのSMB文法がそのプール内で実行出来るならば、
		任意の分散ファイルシステムを使える。
		</para>

		</sect3>

		<sect3>
		<title>分散ファイルシステム上の限定的な制約</title>

		<para>
<indexterm><primary>SMBサービス</primary></indexterm>
<indexterm><primary>oplockハンドリング</primary></indexterm>
<indexterm><primary>サーバプール</primary></indexterm>
<indexterm><primary>backend file system pool</primary></indexterm>
		クラスタ化されたサーバが純粋なSMBサービスを提供するとき、oplockの
		取り扱いは、バックエンドのファイルシステムプールに渡される必要なしに
		サーバプール内で完了してもよい。
		Where a clustered server provides purely SMB services, oplock handling
		may be done within the server pool without imposing a need for this to
		be passed to the backend file system pool.
		</para>

		<para>
<indexterm><primary>NFS</primary></indexterm>
<indexterm><primary>相互運用性</primary></indexterm>
		他方、サーバプールがNFSや他のファイルサービスをも提供する場合、
		SMBサービスと相互運用できるように、oplockを認識する実装は基本である。
		これは、現在有意義な挑戦である。これの相互運用性の提供に失敗すると、
		Microsoft Windows クライアントのユーザによってはっきりと気がつく
		明確な性能の低下をもたらす。
		</para>

		<para>
		最後に、すべてのステート情報は、サーバプール間で共有されるべきである。
		</para>

		</sect3>

		<sect3>
		<title>サーバプールの通信</title>

		<para>
<indexterm><primary>POSIX semantics</primary></indexterm>
<indexterm><primary>SMB</primary></indexterm>
<indexterm><primary>POSIX locks</primary></indexterm>
<indexterm><primary>SMB locks</primary></indexterm>
		Most backend file systems support POSIX file semantics. This makes it difficult
		to push SMB semantics back into the file system. POSIX locks have different properties
		and semantics from SMB locks.
		</para>

		<para>
<indexterm><primary>smbd</primary></indexterm>
<indexterm><primary>tdb</primary></indexterm>
<indexterm><primary>Clustered smbds</primary></indexterm>
		All <command>smbd</command> processes in the server pool must of necessity communicate
		very quickly. For this, the current <parameter>tdb</parameter> file structure that Samba
		uses is not suitable for use across a network. Clustered <command>smbd</command>s must use something else.
		</para>

		</sect3>

		<sect3>
		<title>Server Pool Communications Demands</title>

		<para>
		High-speed interserver communications in the server pool is a design prerequisite
		for a fully functional system. Possibilities for this include:
		</para>

		<itemizedlist>
<indexterm><primary>Myrinet</primary></indexterm>
<indexterm><primary>scalable coherent interface</primary><see>SCI</see></indexterm>
			<listitem><para>
			Proprietary shared memory bus (example: Myrinet or SCI [scalable coherent interface]).
			These are high-cost items.
			</para></listitem>
		
			<listitem><para>
			Gigabit Ethernet (now quite affordable).
			</para></listitem>
		
			<listitem><para>
			Raw Ethernet framing (to bypass TCP and UDP overheads).
			</para></listitem>
		</itemizedlist>

		<para>
		We have yet to identify metrics for  performance demands to enable this to happen
		effectively.
		</para>

		</sect3>

		<sect3>
		<title>Required Modifications to Samba</title>

		<para>
		Samba needs to be significantly modified to work with a high-speed server interconnect
		system to permit transparent failover clustering.
		</para>

		<para>
		Particular functions inside Samba that will be affected include:
		</para>

		<itemizedlist>
			<listitem><para>
			The locking database, oplock notifications,
			and the share mode database.
			</para></listitem>

			<listitem><para>
<indexterm><primary>failure semantics</primary></indexterm>
<indexterm><primary>oplock messages</primary></indexterm>
			Failure semantics need to be defined. Samba behaves the same way as Windows.
			When oplock messages fail, a file open request is allowed, but this is 
			potentially dangerous in a clustered environment. So how should interserver
			pool failure semantics function, and how should such functionality be implemented?
			</para></listitem>

			<listitem><para>
			Should this be implemented using a point-to-point lock manager, or can this
			be done using multicast techniques?
			</para></listitem>

		</itemizedlist>

		</sect3>
	</sect2>

	<sect2>
	<title>A Simple Solution</title>

	<para>
<indexterm><primary>failover servers</primary></indexterm>
<indexterm><primary>exported file system</primary></indexterm>
<indexterm><primary>distributed locking protocol</primary></indexterm>
	Allowing failover servers to handle different functions within the exported file system
	removes the problem of requiring a distributed locking protocol.
	</para>

	<para>
<indexterm><primary>high-speed server interconnect</primary></indexterm>
<indexterm><primary>complex file name space</primary></indexterm>
	If only one server is active in a pair, the need for high-speed server interconnect is avoided.
	This allows the use of existing high-availability solutions, instead of inventing a new one.
	This simpler solution comes at a price &smbmdash; the cost of which is the need to manage a more
	complex file name space. Since there is now not a single file system, administrators
	must remember where all services are located &smbmdash; a complexity not easily dealt with.
	</para>

	<para>
<indexterm><primary>virtual server</primary></indexterm>
	The <emphasis>virtual server</emphasis> is still needed to redirect requests to backend
	servers. Backend file space integrity is the responsibility of the administrator.
	</para>

	</sect2>

	<sect2>
	<title>High-Availability Server Products</title>

	<para>
<indexterm><primary>resource failover</primary></indexterm>
<indexterm><primary>high-availability services</primary></indexterm>
<indexterm><primary>dedicated heartbeat</primary></indexterm>
<indexterm><primary>LAN</primary></indexterm>
<indexterm><primary>failover process</primary></indexterm>
	Failover servers must communicate in order to handle resource failover. This is essential
	for high-availability services. The use of a dedicated heartbeat is a common technique to
	introduce some intelligence into the failover process. This is often done over a dedicated
	link (LAN or serial).
	</para>

	<para>
<indexterm><primary>SCSI</primary></indexterm>
<indexterm><primary>Red Hat Cluster Manager</primary></indexterm>
<indexterm><primary>Microsoft Wolfpack</primary></indexterm>
<indexterm><primary>Fiber Channel</primary></indexterm>
<indexterm><primary>failover communication</primary></indexterm>
	Many failover solutions (like Red Hat Cluster Manager and Microsoft Wolfpack)
	can use a shared SCSI of Fiber Channel disk storage array for failover communication.
	Information regarding Red Hat high availability solutions for Samba may be obtained from
	<ulink url="http://www.redhat.com/docs/manuals/enterprise/RHEL-AS-2.1-Manual/cluster-manager/s1-service-samba.html">www.redhat.com</ulink>.
	</para>

	<para>
<indexterm><primary>Linux High Availability project</primary></indexterm>
	The Linux High Availability project is a resource worthy of consultation if your desire is
	to build a highly available Samba file server solution. Please consult the home page at
	<ulink url="http://www.linux-ha.org/">www.linux-ha.org/</ulink>.
	</para>

	<para>
<indexterm><primary>backend failures</primary></indexterm>
<indexterm><primary>continuity of service</primary></indexterm>
	Front-end server complexity remains a challenge for high availability because it must deal
	gracefully with backend failures, while at the same time providing continuity of service
	to all network clients.
	</para>
	
	</sect2>

	<sect2>
	<title>MS-DFS: The Poor Man's Cluster</title>

	<para>
<indexterm><primary>MS-DFS</primary></indexterm>
<indexterm><primary>DFS</primary><see>MS-DFS, Distributed File Systems</see></indexterm>
	MS-DFS links can be used to redirect clients to disparate backend servers. This pushes
	complexity back to the network client, something already included by Microsoft.
	MS-DFS creates the illusion of a simple, continuous file system name space that works even
	at the file level.
	</para>

	<para>
	Above all, at the cost of complexity of management, a distributed system (pseudo-cluster) can
	be created using existing Samba functionality.
	</para>

	</sect2>

	<sect2>
	<title>Conclusions</title>

	<itemizedlist>
		<listitem><para>Transparent SMB clustering is hard to do!</para></listitem>
		<listitem><para>Client failover is the best we can do today.</para></listitem>
		<listitem><para>Much more work is needed before a practical and manageable high-availability transparent cluster solution will be possible.</para></listitem>
		<listitem><para>MS-DFS can be used to create the illusion of a single transparent cluster.</para></listitem>
	</itemizedlist>

	</sect2>

</sect1>
</chapter>
