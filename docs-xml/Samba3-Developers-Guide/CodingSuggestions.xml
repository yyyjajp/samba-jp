<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="CodingSuggestions">
<chapterinfo>
	<author>
		<firstname>Steve</firstname><surname>French</surname>
	</author>
	<author>
		<firstname>Simo</firstname><surname>Sorce</surname>
	</author>
	<author>
		<firstname>Andrew</firstname><surname>Bartlett</surname>
	</author>
	<author>
		<firstname>Tim</firstname><surname>Potter</surname>
	</author>
	<author>
		<firstname>Martin</firstname><surname>Pool</surname>
	</author>
</chapterinfo>

<title>コーディングに対する助言</title>

<para>
Sambaにコードを追加したい場合は...
</para>

<para>
Sambaのためのコードを書こうとしているプログラマーが直面する難題の一つは、プロジェクト中で
最も活躍している人によって使われているコーディングの習慣を理解することである。それらの
習慣はほとんど説明がなく、ポータビリティ、安定性、あるいはコードの一貫性などを
改善するのに役立っている。このドキュメントは、現時点での、Sambaプロジェクト上で
使われている、重要なコーディングの慣習のいくつかについて説明しようと試みている。
コーディングの慣習は長い期間には少し変わり、わかりにくい移植性の考慮点について
より多く学習するように、進歩していく。すでにある
<filename>samba/source/internals.doc</filename>と
<filename>samba/source/architecture.doc</filename>というドキュメントは補足情報を
提供する。
</para>

<para>
コーディングスタイルに付いて、おおざっぱに関連した質問は、非常に個人的で、
このドキュメントはそのような主題について言及はしないが、Sambaソース中では
8桁ごとのタブが好まれるように見受けられることは言っておこう。もしも、コーディング
スタイルについてのトピックに興味があるのであれば、2つの、しばしば引用される
文書は以下の通りである:
</para>

<para>
<ulink url="http://lxr.linux.no/source/Documentation/CodingStyle">http://lxr.linux.no/source/Documentation/CodingStyle</ulink>
</para>

<para>
<ulink url="http://www.fsf.org/prep/standards_toc.html">http://www.fsf.org/prep/standards_toc.html</ulink>
</para>

<para>
しかし、Samba内でのコーディングスタイルはコードを投稿する多くの異なったプログラマーが
いるという理由で変化に富んでいることに注意。
</para>

<para>
Following are some considerations you should use when adding new code to
Samba.  First and foremost remember that:
</para>

<para>
Portability is a primary consideration in adding function, as is network
compatability with de facto, existing, real world CIFS/SMB implementations.
There are lots of platforms that Samba builds on so use caution when adding
a call to a library function that is not invoked in existing Samba code.
Also note that there are many quite different SMB/CIFS clients that Samba
tries to support, not all of which follow the SNIA CIFS Technical Reference
(or the earlier Microsoft reference documents or the X/Open book on the SMB
Standard) perfectly.
</para>

<para>
Here are some other suggestions:
</para>

<orderedlist>

<listitem><para>
	use d_printf instead of printf for display text
	reason: enable auto-substitution of translated language text 
</para></listitem>

<listitem><para>
	use SAFE_FREE instead of free
	reason: reduce traps due to null pointers
</para></listitem>

<listitem><para>
	don't use bzero use memset, or ZERO_STRUCT and ZERO_STRUCTP macros
	reason: not POSIX
</para></listitem>

<listitem><para>
	don't use strcpy and strlen (use safe_* equivalents)
	reason: to avoid traps due to buffer overruns
</para></listitem>

<listitem><para>
	don't use getopt_long, use popt functions instead
	reason: portability
</para></listitem>

<listitem><para>
	explicitly add const qualifiers on parm passing in functions where parm
	is input only (somewhat controversial but const can be #defined away)
</para></listitem>

<listitem><para>
	when passing a va_list as an arg, or assigning one to another
	please use the VA_COPY() macro
	reason: on some platforms, va_list is a struct that must be 
	initialized in each function...can SEGV if you don't.
</para></listitem>

<listitem><para>
	discourage use of threads
	reason: portability (also see architecture.doc)
</para></listitem>

<listitem><para>
	don't explicitly include new header files in C files - new h files 
	should be included by adding them once to includes.h
	reason: consistency
</para></listitem>

<listitem><para>
	don't explicitly extern functions (they are autogenerated by 
	"make proto" into proto.h)
	reason: consistency
</para></listitem>

<listitem><para>
	use endian safe macros when unpacking SMBs (see byteorder.h and
	internals.doc)
	reason: not everyone uses Intel
</para></listitem>

<listitem><para>
	Note Unicode implications of charset handling (see internals.doc).  See
	pull_*  and push_* and convert_string functions.
	reason: Internationalization
</para></listitem>

<listitem><para>
	Don't assume English only
	reason: See above
</para></listitem>

<listitem><para>
	Try to avoid using in/out parameters (functions that return data which
	overwrites input parameters)
	reason: Can cause stability problems
</para></listitem>

<listitem><para>
	Ensure copyright notices are correct, don't append Tridge's name to code
	that he didn't write.  If you did not write the code, make sure that it
	can coexist with the rest of the Samba GPLed code.
</para></listitem>

<listitem><para>
	Consider usage of DATA_BLOBs for length specified byte-data.
	reason: stability
</para></listitem>

<listitem><para>
	Take advantage of tdbs for database like function
	reason: consistency
</para></listitem>

<listitem><para>
	Don't access the SAM_ACCOUNT structure directly, they should be accessed
	via pdb_get...() and pdb_set...() functions.
	reason: stability, consistency
</para></listitem>

<listitem><para>
	Don't check a password directly against the passdb, always use the
	check_password() interface.
	reason: long term pluggability
</para></listitem>

<listitem><para>
	Try to use asprintf rather than pstrings and fstrings where possible
</para></listitem>

<listitem><para>
	Use normal C comments / * instead of C++ comments // like
	this.  Although the C++ comment format is part of the C99
	standard, some older vendor C compilers do not accept it.
</para></listitem>

<listitem><para>
	Try to write documentation for API functions and structures
	explaining the point of the code, the way it should be used, and
	any special conditions or results.  Mark these with a double-star
	comment start / ** so that they can be picked up by Doxygen, as in
	this file.
</para></listitem>

<listitem><para>
	Keep the scope narrow. This means making functions/variables
	static whenever possible. We don't want our namespace
	polluted. Each module should have a minimal number of externally
	visible functions or variables.
</para></listitem>

<listitem><para>
	Use function pointers to keep knowledge about particular pieces of
	code isolated in one place. We don't want a particular piece of
	functionality to be spread out across lots of places - that makes
	for fragile, hand to maintain code. Instead, design an interface
	and use tables containing function pointers to implement specific
	functionality. This is particularly important for command
	interpreters. 
</para></listitem>

<listitem><para>
	Think carefully about what it will be like for someone else to add
	to and maintain your code. If it would be hard for someone else to
	maintain then do it another way. 
</para></listitem>

</orderedlist>

<para>
The suggestions above are simply that, suggestions, but the information may
help in reducing the routine rework done on new code.  The preceeding list
is expected to change routinely as new support routines and macros are
added.
</para>
</chapter>
