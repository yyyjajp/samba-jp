<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="CodingSuggestions">
<chapterinfo>
	<author>
		<firstname>Steve</firstname><surname>French</surname>
	</author>
	<author>
		<firstname>Simo</firstname><surname>Sorce</surname>
	</author>
	<author>
		<firstname>Andrew</firstname><surname>Bartlett</surname>
	</author>
	<author>
		<firstname>Tim</firstname><surname>Potter</surname>
	</author>
	<author>
		<firstname>Martin</firstname><surname>Pool</surname>
	</author>
</chapterinfo>

<title>コーディングに対する助言</title>

<para>
Sambaにコードを追加したい場合は...
</para>

<para>
Sambaのためのコードを書こうとしているプログラマーが直面する難題の一つは、プロジェクト中で
最も活躍している人によって使われているコーディングの習慣を理解することである。それらの
習慣はほとんど説明がなく、ポータビリティ、安定性、あるいはコードの一貫性などを
改善するのに役立っている。このドキュメントは、現時点での、Sambaプロジェクト上で
使われている、重要なコーディングの慣習のいくつかについて説明しようと試みている。
コーディングの慣習は長い期間には少し変わり、わかりにくい移植性の考慮点について
より多く学習するように、進歩していく。すでにある
<filename>samba/source/internals.doc</filename>と
<filename>samba/source/architecture.doc</filename>というドキュメントは補足情報を
提供する。
</para>

<para>
コーディングスタイルに付いて、おおざっぱに関連した質問は、非常に個人的で、
このドキュメントはそのような主題について言及はしないが、Sambaソース中では
8桁ごとのタブが好まれるように見受けられることは言っておこう。もしも、コーディング
スタイルについてのトピックに興味があるのであれば、2つの、しばしば引用される
文書は以下の通りである:
</para>

<para>
<ulink url="http://lxr.linux.no/source/Documentation/CodingStyle">http://lxr.linux.no/source/Documentation/CodingStyle</ulink>
</para>

<para>
<ulink url="http://www.fsf.org/prep/standards_toc.html">http://www.fsf.org/prep/standards_toc.html</ulink>
</para>

<para>
しかし、Samba内でのコーディングスタイルはコードを投稿する多くの異なったプログラマーが
いるという理由で変化に富んでいることに注意。
</para>

<para>
以下は、Sambaに新しいコードを追加するときに使うべきいくつかの考慮点である。
まず最初に、そして、最も重要な、覚えておいてほしい点は以下の通り:
</para>

<para>
移植性は、デ・ファクトで、存在する、実際の世界でのCIFS/SMB実装のような、
ネットワークの互換性が、関数を追加するときに一番考慮することである。
Sambaがコンパイルできるプラットフォームは多数あり、存在するSambaコード中で
起動されないライブラリ関数への呼び出しを追加するときには注意すること。
また、数多くの異なった、SambaがサポートしようとするSMB/CIFSクライアントがあり、
SNIA CIFS技術参照(あるいは最新のMicrosoftリファレンス文書あるいは
SMB標準についてのX/Open書籍)を、すべてが完全に準拠していないことにも注意。
</para>

<para>
以下はその他の助言である:
</para>

<orderedlist>

<listitem><para>
    テキスト表示のために、printfの代わりにd_printfを使う
    理由:翻訳された言語のテキストへの置き換えを有効にする。
</para></listitem>

<listitem><para>
	freeの代わりに SAFE_FREEを使う
	理由: nullポインタをトラップすることを減らす。
</para></listitem>

<listitem><para>
    bzeroを使わないで、memsetあるいはZERO_STRUCT と ZERO_STRUCTPマクロを使う
	理由: これは POSIX ではない
</para></listitem>

<listitem><para>
    strcpyとstrlenを使わない(safe_*という同等品を使う)
    理由:バッファオーバランによるトラップを防ぐため
</para></listitem>

<listitem><para>
    getopt_longを使わないでその代わりにpopt関数を使う
    理由:互換性
</para></listitem>

<listitem><para>
    明示的に、parmが入力のみの場合、関数中に渡すparmはconst識別子を追加する
    (若干議論があるところではあるが、constは#definedで処理できる)
</para></listitem>

<listitem><para>
    argとしてva_listに渡すときか、あるものを他に割り当てるときには、
    VA_COPY()マクロを使うこと
    理由:いくつかのプラットフォーム上では、va_listは、各関数中で初期化しなければならない
    構造体であり、そうでない場合にはセグメンテーションフォルトになり得る。
</para></listitem>

<listitem><para>
    スレッドを使わない
    理由:移植性(archtecture.docを参照)
</para></listitem>

<listitem><para>
    Cファイル中の新しいヘッダを明示的にインクルードしない - 新しいヘッダファイルは
    include.hに1回だけ追加することによりインクルードすべきである。
    理由:一貫性
</para></listitem>

<listitem><para>
    明示的に関数をexternしない(それらはproto.h内に"make proto"によって自動生成される)
    理由:一貫性
</para></listitem>

<listitem><para>
    SMBをアンパックするときにはエンディアン依存性がない安全なマクロを使う
    (byteorder.hとinternals.docを参照)
    理由:すべての人がIntelチップを使うとは限らない
</para></listitem>

<listitem><para>
    文字セットハンドリングのユニコード実装に注意(internals.docを参照)。
    pull_*  と push_* と convert_string を参照。
    理由:国際化
</para></listitem>

<listitem><para>
    英語のみであることを仮定しないこと
    理由:同上
</para></listitem>

<listitem><para>
    in/outパラメータを使わないようにする(関数は、戻りデータに対し、
    入力パラメータを上書きする)
    理由:安定性の問題を引き起こすため
</para></listitem>

<listitem><para>
	Ensure copyright notices are correct, don't append Tridge's name to code
	that he didn't write.  If you did not write the code, make sure that it
	can coexist with the rest of the Samba GPLed code.
</para></listitem>

<listitem><para>
	Consider usage of DATA_BLOBs for length specified byte-data.
	reason: stability
</para></listitem>

<listitem><para>
	Take advantage of tdbs for database like function
	reason: consistency
</para></listitem>

<listitem><para>
	Don't access the SAM_ACCOUNT structure directly, they should be accessed
	via pdb_get...() and pdb_set...() functions.
	reason: stability, consistency
</para></listitem>

<listitem><para>
	Don't check a password directly against the passdb, always use the
	check_password() interface.
	reason: long term pluggability
</para></listitem>

<listitem><para>
	Try to use asprintf rather than pstrings and fstrings where possible
</para></listitem>

<listitem><para>
	Use normal C comments / * instead of C++ comments // like
	this.  Although the C++ comment format is part of the C99
	standard, some older vendor C compilers do not accept it.
</para></listitem>

<listitem><para>
	Try to write documentation for API functions and structures
	explaining the point of the code, the way it should be used, and
	any special conditions or results.  Mark these with a double-star
	comment start / ** so that they can be picked up by Doxygen, as in
	this file.
</para></listitem>

<listitem><para>
	Keep the scope narrow. This means making functions/variables
	static whenever possible. We don't want our namespace
	polluted. Each module should have a minimal number of externally
	visible functions or variables.
</para></listitem>

<listitem><para>
	Use function pointers to keep knowledge about particular pieces of
	code isolated in one place. We don't want a particular piece of
	functionality to be spread out across lots of places - that makes
	for fragile, hand to maintain code. Instead, design an interface
	and use tables containing function pointers to implement specific
	functionality. This is particularly important for command
	interpreters. 
</para></listitem>

<listitem><para>
	Think carefully about what it will be like for someone else to add
	to and maintain your code. If it would be hard for someone else to
	maintain then do it another way. 
</para></listitem>

</orderedlist>

<para>
The suggestions above are simply that, suggestions, but the information may
help in reducing the routine rework done on new code.  The preceeding list
is expected to change routinely as new support routines and macros are
added.
</para>
</chapter>
