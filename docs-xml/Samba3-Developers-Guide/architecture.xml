<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="architecture">
<chapterinfo>
	<author>
		<firstname>Dan</firstname><surname>Shearer</surname>
	</author>
	<pubdate> November 1997</pubdate>
</chapterinfo>

<title>Sambaアーキテクチャ</title>

<sect1>
<title>概要</title>

<para>
この文書は、内部的にSambaがどのように動くかについての一般的な概要を説明している。
Samba Teamは、非常に汚いSMBとCIFSプロトコルによって押しつけられる、優雅さ、セキュリティと
制約の間で、最も良い妥協点であるモデルを見いだそうとした。
</para>

<para>
また、以下のようなよく聞かれる質問のいくつかに答えようともしている:
</para>

<orderedlist>
<listitem><para>
    UNIX上で動かすときにSambaは安全か?xyzプラットフォームでは?
    root特権についての問題は?
</para></listitem>

<listitem><para>Sambaのいくつかの部分中でのマルチスレッドの賛否</para></listitem>

<listitem><para>なぜ、名前解決、WINSとブラウジングに関して分離されたプロセスがあるのか?</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>マルチスレッドとSamba</title>

<para>
人々は時々、一様にスレッドを良いものとして推奨する。それらは推奨する人にとっては
とても良いものであるが、smbdに取ってはまったく不適当である。nmbdは別の問題で、
マルチスレッドそれ自身はとても良いことである。
</para>

<para>
手短に言うと、smbdはマルチスレッド化されておらず、UNIX配下での別のサーバ(例えば、
書いている時点においてはSyntax)はこの方法を取っていて、とても大きな性能上の問題を
抱えていて、頑丈ではない。nmbdもスレッド化されていないが、これは、35以上もの
プラットフォームにまたがって、コードの整合性を取り、ポータブルにするということが、
不可能だからという理由である(この欠点は同じくsmbdをスレッド化することにも当てはまる)。
</para>

<para>
より長い期間において、smbdをマルチスレッドにしない、とても良い理由が存在している。
マルチスレッドはSambaをより遅くし、スケーラビリティを減少させ、移植性をなくし、
とても不安定にさせる。実際、各接続に対して独立したプロセスを使用していて、それは
Sambaの最も大きな利点の1つである。
</para>

</sect1>

<sect1>
<title>smbdのスレッド化</title>

<para>
スレッド化したsmbdから発生するいくつかの問題は以下の通り:
</para>

<orderedlist>
<listitem><para>
    プロセスの代わりにスレッドを作成するだけでなく、スレッド固有で存在しなければならない
    場合、すべての変数について管理を行わなければならない(現在それらはグローバルである)。
</para></listitem>

<listitem><para>
    もしもある1つのスレッドが異常終了すると(例えば、セグメンテーションフォルト)、
    すべてのスレッドが異常終了する。信頼性を損ねることになる。
</para></listitem>

<listitem><para>
    使用している多くのシステムコールがブロックしている。多くのシステムコールで
    ブロックしないか同等のことをするものは、用意されていないか、うまく使えない
    (そして遅い)。そのため、ある1つのスレッドでブロックしている間は、すべての
    クライアントは待たされることになる。ある共有が遅いNFSファイルシステムで、
    その他が早いものだと仮定してみた場合、すべてのクライアントが、NFSのスピードに
    抑制されてしまう。
</para></listitem>

<listitem><para>
    異なったスレッド中で異なったuidとして動作できない。これは、すべてのSMBパケット上で
    uid/gidをスイッチしなければならないと言うことを意味する。それはとてつもなく遅い。
</para></listitem>

<listitem><para>
    プロセスあたりのファイルディスクリプタ制限は、制限されたクライアントの数のみを
    サポートできることを意味する。
</para></listitem>

<listitem><para>
    プロセスに対してfcntl()のコンテキストでロッキングを行うようにスレッドに対して
    システムロッキングを使うことが出来ない。
</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>nmbdのスレッド化</title>

<para>
This would be ideal, but gets sunk by portability requirements.
</para>

<para>
Andrew tried to write a test threads library for nmbd that used only
ansi-C constructs (using setjmp and longjmp). Unfortunately some OSes
defeat this by restricting longjmp to calling addresses that are
shallower than the current address on the stack (apparently AIX does
this). This makes a truly portable threads library impossible. So to
support all our current platforms we would have to code nmbd both with
and without threads, and as the real aim of threads is to make the
code clearer we would not have gained anything. (it is a myth that
threads make things faster. threading is like recursion, it can make
things clear but the same thing can always be done faster by some
other method)
</para>

<para>
Chris tried to spec out a general design that would abstract threading
vs separate processes (vs other methods?) and make them accessible
through some general API. This doesn't work because of the data
sharing requirements of the protocol (packets in the future depending
on packets now, etc.) At least, the code would work but would be very
clumsy, and besides the fork() type model would never work on Unix. (Is there an OS that it would work on, for nmbd?)
</para>

<para>
A fork() is cheap, but not nearly cheap enough to do on every UDP
packet that arrives. Having a pool of processes is possible but is
nasty to program cleanly due to the enormous amount of shared data (in
complex structures) between the processes. We can't rely on each
platform having a shared memory system.
</para>

</sect1>

<sect1>
<title>nbmd Design</title>

<para>
Originally Andrew used recursion to simulate a multi-threaded
environment, which use the stack enormously and made for really
confusing debugging sessions. Luke Leighton rewrote it to use a
queuing system that keeps state information on each packet.  The
first version used a single structure which was used by all the
pending states.  As the initialisation of this structure was
done by adding arguments, as the functionality developed, it got
pretty messy.  So, it was replaced with a higher-order function
and a pointer to a user-defined memory block.  This suddenly
made things much simpler: large numbers of functions could be
made static, and modularised.  This is the same principle as used
in NT's kernel, and achieves the same effect as threads, but in
a single process.
</para>

<para>
Then Jeremy rewrote nmbd. The packet data in nmbd isn't what's on the
wire. It's a nice format that is very amenable to processing but still
keeps the idea of a distinct packet. See "struct packet_struct" in
nameserv.h.  It has all the detail but none of the on-the-wire
mess. This makes it ideal for using in disk or memory-based databases
for browsing and WINS support. 
</para>

</sect1>
</chapter>
