<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="architecture">
<chapterinfo>
	<author>
		<firstname>Dan</firstname><surname>Shearer</surname>
	</author>
	<pubdate> November 1997</pubdate>
</chapterinfo>

<title>Sambaアーキテクチャ</title>

<sect1>
<title>概要</title>

<para>
この文書は、内部的にSambaがどのように動くかについての一般的な概要を説明している。
Samba Teamは、非常に汚いSMBとCIFSプロトコルによって押しつけられる、優雅さ、セキュリティと
制約の間で、最も良い妥協点であるモデルを見いだそうとした。
</para>

<para>
また、以下のようなよく聞かれる質問のいくつかに答えようともしている:
</para>

<orderedlist>
<listitem><para>
    UNIX上で動かすときにSambaは安全か?xyzプラットフォームでは?
    root特権についての問題は?
</para></listitem>

<listitem><para>Sambaのいくつかの部分中でのマルチスレッドの賛否</para></listitem>

<listitem><para>なぜ、名前解決、WINSとブラウジングに関して分離されたプロセスがあるのか?</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>マルチスレッドとSamba</title>

<para>
人々は時々、一様にスレッドを良いものとして推奨する。それらは推奨する人にとっては
とても良いものであるが、smbdに取ってはまったく不適当である。nmbdは別の問題で、
マルチスレッドそれ自身はとても良いことである。
</para>

<para>
手短に言うと、smbdはマルチスレッド化されておらず、UNIX配下での別のサーバ(例えば、
書いている時点においてはSyntax)はこの方法を取っていて、とても大きな性能上の問題を
抱えていて、頑丈ではない。nmbdもスレッド化されていないが、これは、35以上もの
プラットフォームにまたがって、コードの整合性を取り、ポータブルにするということが、
不可能だからという理由である(この欠点は同じくsmbdをスレッド化することにも当てはまる)。
</para>

<para>
より長い期間において、smbdをマルチスレッドにしない、とても良い理由が存在している。
マルチスレッドはSambaをより遅くし、スケーラビリティを減少させ、移植性をなくし、
とても不安定にさせる。実際、各接続に対して独立したプロセスを使用していて、それは
Sambaの最も大きな利点の1つである。
</para>

</sect1>

<sect1>
<title>smbdのスレッド化</title>

<para>
スレッド化したsmbdから発生するいくつかの問題は以下の通り:
</para>

<orderedlist>
<listitem><para>
    プロセスの代わりにスレッドを作成するだけでなく、スレッド固有で存在しなければならない
    場合、すべての変数について管理を行わなければならない(現在それらはグローバルである)。
</para></listitem>

<listitem><para>
    もしもある1つのスレッドが異常終了すると(例えば、セグメンテーションフォルト)、
    すべてのスレッドが異常終了する。信頼性を損ねることになる。
</para></listitem>

<listitem><para>
    使用している多くのシステムコールがブロックしている。多くのシステムコールで
    ブロックしないか同等のことをするものは、用意されていないか、うまく使えない
    (そして遅い)。そのため、ある1つのスレッドでブロックしている間は、すべての
    クライアントは待たされることになる。ある共有が遅いNFSファイルシステムで、
    その他が早いものだと仮定してみた場合、すべてのクライアントが、NFSのスピードに
    抑制されてしまう。
</para></listitem>

<listitem><para>
    異なったスレッド中で異なったuidとして動作できない。これは、すべてのSMBパケット上で
    uid/gidをスイッチしなければならないと言うことを意味する。それはとてつもなく遅い。
</para></listitem>

<listitem><para>
    プロセスあたりのファイルディスクリプタ制限は、制限されたクライアントの数のみを
    サポートできることを意味する。
</para></listitem>

<listitem><para>
    プロセスに対してfcntl()のコンテキストでロッキングを行うようにスレッドに対して
    システムロッキングを使うことが出来ない。
</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>nmbdのスレッド化</title>

<para>
これは理想ではあるが、ポータビリティの要求により実現するのは難しい。
</para>

<para>
Andrew はANSI-Cの範囲のみを使って(setjmpとlongjmpを使って)nmbd用のテスト用
スレッドライブラリを加工とした。残念なことに、いくつかのOSでは、スタック上の
現在のアドレスよりも浅い位置のアドレスを呼び出すためにlongjmpを制限することに
よって、うまくいかなかった(見たところでは、AIXがそうである)。これは、真に
ポータブルなスレッドライブラリを不可能にしている。そのため、現在対応している
すべてのプラットフォームに対して、nmbdのコードをスレッドあり、なしの両方用意
しなければならず、スレッドの本来の目的はコードをきれいにすることであるが、
それを得られない(スレッドが物事を早くするというのは神話である。スレッドは
再帰のようなものであり、物事をきれいにするが、他の何らかの方法によって、いつでも
それはもっと早くすることもできる)。
</para>

<para>
Chrisは、スレッド対独立したプロセス(対他の方法?)を要約する汎用的なデザインを設計
しようとし、いくつかの汎用APCを通して、それらをアクセス可能にした。これは、
プロトコルによるデータ共有要求(現在のパケットに将来のパケットが依存するなど)という
理由でうまく動かなかった。少なくとも、コードは動いたが、非常にぎこちなく、
その上、fork()タイプモデルは、UNIX上では決して動かなかった(nmbdに対して、
それが動くOSはあるのだろうか?)。
</para>

<para>
fork()は安っぽいが、受信したすべてのUDPパケット上で処理を行うのに、十分
安っぽいわけではない。プロセスのプールを持つことは可能であるが、プロセス間で、
(複雑な構造体中で)共有された巨大な量のデータのために、プログラムをきれいにする
ことは、ひどく難しい。各プラットフォームが共有メモリシステムを持つ事を
あてにすることは出来ない。
</para>

</sect1>

<sect1>
<title>nbmdのデザイン</title>

<para>
Originally Andrew used recursion to simulate a multi-threaded
environment, which use the stack enormously and made for really
confusing debugging sessions. Luke Leighton rewrote it to use a
queuing system that keeps state information on each packet.  The
first version used a single structure which was used by all the
pending states.  As the initialisation of this structure was
done by adding arguments, as the functionality developed, it got
pretty messy.  So, it was replaced with a higher-order function
and a pointer to a user-defined memory block.  This suddenly
made things much simpler: large numbers of functions could be
made static, and modularised.  This is the same principle as used
in NT's kernel, and achieves the same effect as threads, but in
a single process.
</para>

<para>
Then Jeremy rewrote nmbd. The packet data in nmbd isn't what's on the
wire. It's a nice format that is very amenable to processing but still
keeps the idea of a distinct packet. See "struct packet_struct" in
nameserv.h.  It has all the detail but none of the on-the-wire
mess. This makes it ideal for using in disk or memory-based databases
for browsing and WINS support. 
</para>

</sect1>
</chapter>
