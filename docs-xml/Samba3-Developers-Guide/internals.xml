<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="internals">
<chapterinfo>
	<author>
		<firstname>David</firstname><surname>Chappell</surname>
		<affiliation>
			<address><email>David.Chappell@mail.trincoll.edu</email></address>
		</affiliation>
	</author>
	<pubdate>8 May 1996</pubdate>
</chapterinfo>

<title>Sambaの内部</title>

<sect1>
<title>文字の取り扱い</title>
<para>
この章では、Samba3.0以降におけるSamba内部での文字セットの取り扱いについて言及する。

</para>

<para>
以前のバージョンのSambaは、とてもその場しのぎの文字セット処理を行っていた。点在する
コードはDOSのコードページへ、あるいはコードページから特定の文字列を変換するのに、
数多くの呼び出しが使われていた。問題は、特定のchar*がdosのコードページかUNIXの
コードページかを確認するすべがないということである。これは、一般的な場合での取り扱いが
ない、特定の場合に対応する事を試みる悪夢のようなコードになってしまう。
</para>
</sect1>

<sect1>
<title>新しい機能</title>

<para>
新しいシステムは以下のように動作する:
</para>

<orderedlist>
<listitem><para>
    Samba内部におけるすべてのchar*文字列は"unix"文字列である。smb.conf中の
    "unix charset"オプションによって定義される文字セット中にはマルチバイト
    文字列が存在する。
</para></listitem>

<listitem><para>
    unix文字列用の1バイト固定文字セットは存在しないが、使われている任意の文字セットは
    以下の性質を必要としている:
	</para>
	<orderedlist>
	
	<listitem><para>
	    行終端を除いて、NULL文字が含まれてはならない
	</para></listitem>

	<listitem><para>
	    Cの文字列と互換がある7ビット文字でなければならず、そのため、C用の
	    定数文字列か文字は、選択された文字セット中で同等の文字列とバイト単位で
	    全く同じである。
	</para></listitem>
	
	<listitem><para>
	    文字列を大文字化あるいは小文字化した場合、もはやオリジナルの文字列と
	    同じではなくなる。
	</para></listitem>

	<listitem><para>
	    クライアントから送信されてきたすべての文字を扱えねばならない。
	</para></listitem>
	</orderedlist>
	
	<para>
	  例えば、UTF-8は良くできていて、ほとんどのマルチバイトのアジアの文字セットに
	  対応するが、UCS2は、内部にNULLが含まれているため、UNIX文字列としては使うことが
	  できない。
	</para>
</listitem>

<listitem><para>
    ネットワーク上に送信しようとするためのバッファ中に文字列を書き込む必要がある場合、
    あるいは、クライアントの文字セットと互換のある文字セット形式での文字列を必要とする
    場合、pull_またはpush_関数を使う必要がある。pull_関数は送信バッファから(マルチバイト)
    UNIX文字列中に変換する。push_関数は文字列を書き込みバッファに書く。
</para></listitem>

<listitem><para>
    理解する必要がある2つの主要なpull_とpush_関数は、pull_stringとpush_stringである。
    これらの関数は文字列が入っているSMBパケットの開始位置をポイントすべきである、
    ベースポインタを取る。関数は、パケットがユニコードパケットとしてマーク
    されているかを自動的に決定するため、パケット中のフラグフィールドをチェックし、
    このフラグに基づいて、文字列に対してユニコードを使うかどうかを決める。また、
    STR_UNICODEかSTR_ASCIIを使うことによって、この決定を強制的に行わせてもよい。
    smbd/とlibsmb/中での使用のために、適切な最初の引数を付けてpull_/push_関数を
    呼び出すclistr_とsrvstr_ラッパー関数がある。
	</para>
	
	<para>
	  また、特定の文字列がASCIIかユニコードか分かっている場合、pull_ascii/
	  pull_ucs2かpush_ascii/push_ucs2関数を呼び出しても良い。たとえば
	  pull_ascii_pstring()のような、特定の共通の引数を持つpush_/pull_関数を
	  呼び出すcharcnv.c中に、数多くの他の便利な関数もある。
	</para>
</listitem>

<listitem><para>
    覚えておかなければならない最も大きな問題は、Samba中の内部(UNIX)文字列は、
    マルチバイト文字を含むかもしれないということである。これは、文字が常時1バイト
    であることを仮定できないと言うことを意味する。しばしばこれは文字列をucs2に
    変換しなければならないということであり、いくつかの(表面上)単純な作業を行うために、
    再度逆変換する必要があるということである。どのようにこれを行うかの例は、
    strchr_m()関数を見ること。これはとても遅いことが分かっていて、結局、これを
    高速化したが、現在、スピードよりも正確さを求めている。
</para></listitem>

<listitem><para>
    すべてのlp_関数は現在UNIX文字列を返す。パラメータ上の特別な"DOS"フラグはなくなった。
</para></listitem>

<listitem><para>
    すべてのvfs関数はUNIX文字列を取る。それに渡すときに変換してはならない。
</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>byteorder.h中のマクロ</title>

<para>
This section describes the macros defined in byteorder.h.  These macros 
are used extensively in the Samba code.
</para>

<sect2>
<title>CVAL(buf,pos)</title>

<para>
returns the byte at offset pos within buffer buf as an unsigned character.
</para>
</sect2>

<sect2>
<title>PVAL(buf,pos)</title>
<para>returns the value of CVAL(buf,pos) cast to type unsigned integer.</para>
</sect2>

<sect2>
<title>SCVAL(buf,pos,val)</title>
<para>sets the byte at offset pos within buffer buf to value val.</para>
</sect2>

<sect2>
<title>SVAL(buf,pos)</title>
<para>
	returns the value of the unsigned short (16 bit) little-endian integer at 
	offset pos within buffer buf.  An integer of this type is sometimes
	refered to as "USHORT".
</para>
</sect2>

<sect2>
<title>IVAL(buf,pos)</title>
<para>returns the value of the unsigned 32 bit little-endian integer at offset 
pos within buffer buf.</para>
</sect2>

<sect2>
<title>SVALS(buf,pos)</title>
<para>returns the value of the signed short (16 bit) little-endian integer at 
offset pos within buffer buf.</para>
</sect2>

<sect2>
<title>IVALS(buf,pos)</title>
<para>returns the value of the signed 32 bit little-endian integer at offset pos
within buffer buf.</para>
</sect2>

<sect2>
<title>SSVAL(buf,pos,val)</title>
<para>sets the unsigned short (16 bit) little-endian integer at offset pos within 
buffer buf to value val.</para>
</sect2>

<sect2>
<title>SIVAL(buf,pos,val)</title>
<para>sets the unsigned 32 bit little-endian integer at offset pos within buffer 
buf to the value val.</para>
</sect2>

<sect2>
<title>SSVALS(buf,pos,val)</title>
<para>sets the short (16 bit) signed little-endian integer at offset pos within 
buffer buf to the value val.</para>
</sect2>

<sect2>
<title>SIVALS(buf,pos,val)</title>
<para>sets the signed 32 bit little-endian integer at offset pos withing buffer
buf to the value val.</para>
</sect2>

<sect2>
<title>RSVAL(buf,pos)</title>
<para>returns the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf.</para>
</sect2>

<sect2>
<title>RIVAL(buf,pos)</title>
<para>returns the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf.</para>
</sect2>

<sect2>
<title>RSSVAL(buf,pos,val)</title>
<para>sets the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf to value val.
refered to as "USHORT".</para>
</sect2>

<sect2>
<title>RSIVAL(buf,pos,val)</title>
<para>sets the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf to value val.</para>
</sect2>

</sect1>


<sect1>
<title>LAN Manager Samba API</title>

<para>
This section describes the functions need to make a LAN Manager RPC call.
This information had been obtained by examining the Samba code and the LAN
Manager 2.0 API documentation.  It should not be considered entirely
reliable.
</para>

<para>
<programlisting>
call_api(int prcnt, int drcnt, int mprcnt, int mdrcnt, 
	char *param, char *data, char **rparam, char **rdata);
</programlisting>
</para>

<para>
This function is defined in client.c.  It uses an SMB transaction to call a
remote api.
</para>

<sect2>
<title>Parameters</title>

<para>The parameters are as follows:</para>

<orderedlist>
<listitem><para>
	prcnt: the number of bytes of parameters begin sent.
</para></listitem>
<listitem><para>
	drcnt:   the number of bytes of data begin sent.
</para></listitem>
<listitem><para>
	mprcnt:  the maximum number of bytes of parameters which should be returned
</para></listitem>
<listitem><para>
	mdrcnt:  the maximum number of bytes of data which should be returned
</para></listitem>
<listitem><para>
	param:   a pointer to the parameters to be sent.
</para></listitem>
<listitem><para>
	data:    a pointer to the data to be sent.
</para></listitem>
<listitem><para>
	rparam:  a pointer to a pointer which will be set to point to the returned
	parameters.  The caller of call_api() must deallocate this memory.
</para></listitem>
<listitem><para>
	rdata:   a pointer to a pointer which will be set to point to the returned 
	data.  The caller of call_api() must deallocate this memory.
</para></listitem>
</orderedlist>

<para>
These are the parameters which you ought to send, in the order of their
appearance in the parameter block:
</para>

<orderedlist>

<listitem><para>
An unsigned 16 bit integer API number.  You should set this value with
SSVAL().  I do not know where these numbers are described.
</para></listitem>

<listitem><para>
An ASCIIZ string describing the parameters to the API function as defined
in the LAN Manager documentation.  The first parameter, which is the server
name, is ommited.  This string is based uppon the API function as described
in the manual, not the data which is actually passed.
</para></listitem>

<listitem><para>
An ASCIIZ string describing the data structure which ought to be returned.
</para></listitem>

<listitem><para>
Any parameters which appear in the function call, as defined in the LAN
Manager API documentation, after the "Server" and up to and including the
"uLevel" parameters.
</para></listitem>

<listitem><para>
An unsigned 16 bit integer which gives the size in bytes of the buffer we
will use to receive the returned array of data structures.  Presumably this
should be the same as mdrcnt.  This value should be set with SSVAL().
</para></listitem>

<listitem><para>
An ASCIIZ string describing substructures which should be returned.  If no 
substructures apply, this string is of zero length.
</para></listitem>

</orderedlist>

<para>
The code in client.c always calls call_api() with no data.  It is unclear
when a non-zero length data buffer would be sent.
</para>

</sect2>

<sect2>
<title>Return value</title>

<para>
The returned parameters (pointed to by rparam), in their order of appearance
are:</para>

<orderedlist>

<listitem><para>
An unsigned 16 bit integer which contains the API function's return code. 
This value should be read with SVAL().
</para></listitem>

<listitem><para>
An adjustment which tells the amount by which pointers in the returned
data should be adjusted.  This value should be read with SVAL().  Basically, 
the address of the start of the returned data buffer should have the returned
pointer value added to it and then have this value subtracted from it in
order to obtain the currect offset into the returned data buffer.
</para></listitem>

<listitem><para>
A count of the number of elements in the array of structures returned. 
It is also possible that this may sometimes be the number of bytes returned.
</para></listitem>
</orderedlist>

<para>
When call_api() returns, rparam points to the returned parameters.  The
first if these is the result code.  It will be zero if the API call
suceeded.  This value by be read with "SVAL(rparam,0)".
</para>

<para>
The second parameter may be read as "SVAL(rparam,2)".  It is a 16 bit offset
which indicates what the base address of the returned data buffer was when
it was built on the server.  It should be used to correct pointer before
use.
</para>

<para>
The returned data buffer contains the array of returned data structures. 
Note that all pointers must be adjusted before use.  The function
fix_char_ptr() in client.c can be used for this purpose.
</para>

<para>
The third parameter (which may be read as "SVAL(rparam,4)") has something to
do with indicating the amount of data returned or possibly the amount of
data which can be returned if enough buffer space is allowed.
</para>

</sect2>
</sect1>

<sect1>
<title>Code character table</title>
<para>
Certain data structures are described by means of ASCIIz strings containing
code characters.  These are the code characters:
</para>

<orderedlist>
<listitem><para>
W	a type byte little-endian unsigned integer
</para></listitem>
<listitem><para>
N	a count of substructures which follow
</para></listitem>
<listitem><para>
D	a four byte little-endian unsigned integer
</para></listitem>
<listitem><para>
B	a byte (with optional count expressed as trailing ASCII digits)
</para></listitem>
<listitem><para>
z	a four byte offset to a NULL terminated string
</para></listitem>
<listitem><para>
l	a four byte offset to non-string user data
</para></listitem>
<listitem><para>
b	an offset to data (with count expressed as trailing ASCII digits)
</para></listitem>
<listitem><para>
r	pointer to returned data buffer???
</para></listitem>
<listitem><para>
L	length in bytes of returned data buffer???
</para></listitem>
<listitem><para>
h	number of bytes of information available???
</para></listitem>
</orderedlist>

</sect1>
</chapter>
