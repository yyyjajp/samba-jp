<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="debug">
<chapterinfo>
	<author>
		<firstname>Chris</firstname><surname>Hertel</surname>
	</author>
	<pubdate>July 1998</pubdate>
</chapterinfo>

<title>Sambaのデバッグシステム</title>

<sect1>
<title>新しい出力形式</title>

<para>
  デバッグログファイルの文法は以下の通り:
</para>

<para><programlisting>
  &gt;debugfile&lt; :== { &gt;debugmsg&lt; }

  &gt;debugmsg&lt;  :== &gt;debughdr&lt; '\n' &gt;debugtext&lt;

  &gt;debughdr&lt;  :== '[' TIME ',' LEVEL ']' FILE ':' [FUNCTION] '(' LINE ')'

  &gt;debugtext&lt; :== { &gt;debugline&lt; }

  &gt;debugline&lt; :== TEXT '\n'
</programlisting></para>

<para>
TEXTは改行文字を含まない文字列である。
</para>

<para>
LEVEL はメッセージのDEBUGレベルである(0から10の範囲の整数値)。
</para>

<para>
TIME はタイムスタンプである。
</para>

<para>
FILE はでバグメッセージが生成されたファイルの名前である。
</para>

<para>
FUNCTIONはデバッグメッセージが生成された関数である。
</para>

<para>
LINEはメッセージが生成されたデバッグ文の行番号である。
</para>

<para>基本的に、それが意味するところは以下の通り:</para>
<orderedlist>
<listitem><para>
デバッグログファイルはデバッグメッセージで構成される。
</para></listitem>
<listitem><para>
核でバッグメッセージはヘッダとテキストから構成される。ヘッダは改行によってテキストと
分離されている。
</para></listitem>
<listitem><para>
ヘッダはタイムスタンプで始まり、括弧の中にデバッグレベルが続く。メッセージによって
生成されたファイル名、関数名、と行番号がそのあとに続く。ファイル名はコロンで終了し、
関数名は行番号を含む括弧で終了する。コンパイラに依存するが、関数名は無いかもしれない
(これは、広く実装はされていない__FUNCTION__マクロによって生成される、dangit)。
</para></listitem>
<listitem><para>
メッセージテキストは0かそれ以上の行から構成され、おのおのは改行で終端する。
</para></listitem>
</orderedlist>

<para>出力の例:</para>

<para><programlisting>
    [1998/08/03 12:55:25, 1] nmbd.c:(659)
      Netbios nameserver version 1.9.19-prealpha started.
      Copyright Andrew Tridgell 1994-1997
    [1998/08/03 12:55:25, 3] loadparm.c:(763)
      Initializing global parameters
</programlisting></para>

<para>
上記の例において関数名はヘッダ行には表示されていないことに注意。これは、上記の例は
SGI Indyによって生成され、SGIコンパイラは__FUNCTION__マクロをサポートしていないという
理由による。
</para>

</sect1>

<sect1>
<title>DEBUG() マクロ</title>

<para>
Use of the DEBUG() macro is unchanged. DEBUG() takes two parameters.
The first is the message level, the second is the body of a function
call to the Debug1() function.
</para>

<para>That's confusing.</para>

<para>Here's an example which may help a bit. If you would write</para>

<para><programlisting>
printf( "This is a %s message.\n", "debug" );
</programlisting></para>

<para>
to send the output to stdout, then you would write
</para>

<para><programlisting>
DEBUG( 0, ( "This is a %s message.\n", "debug" ) );
</programlisting></para>

<para>
to send the output to the debug file.  All of the normal printf()
formatting escapes work.
</para>

<para>
Note that in the above example the DEBUG message level is set to 0.
Messages at level 0 always print.  Basically, if the message level is
less than or equal to the global value DEBUGLEVEL, then the DEBUG
statement is processed.
</para>

<para>
The output of the above example would be something like:
</para>

<para><programlisting>
    [1998/07/30 16:00:51, 0] file.c:function(128)
      This is a debug message.
</programlisting></para>

<para>
Each call to DEBUG() creates a new header *unless* the output produced
by the previous call to DEBUG() did not end with a '\n'. Output to the
debug file is passed through a formatting buffer which is flushed
every time a newline is encountered. If the buffer is not empty when
DEBUG() is called, the new input is simply appended.
</para>

<para>
...but that's really just a Kludge. It was put in place because
DEBUG() has been used to write partial lines. Here's a simple (dumb)
example of the kind of thing I'm talking about:
</para>

<para><programlisting>
    DEBUG( 0, ("The test returned " ) );
    if( test() )
      DEBUG(0, ("True") );
    else
      DEBUG(0, ("False") );
    DEBUG(0, (".\n") );
</programlisting></para>

<para>
Without the format buffer, the output (assuming test() returned true)
would look like this:
</para>

<para><programlisting>
    [1998/07/30 16:00:51, 0] file.c:function(256)
      The test returned
    [1998/07/30 16:00:51, 0] file.c:function(258)
      True
    [1998/07/30 16:00:51, 0] file.c:function(261)
      .
</programlisting></para>

<para>Which isn't much use. The format buffer kludge fixes this problem.
</para>

</sect1>

<sect1>
<title>The DEBUGADD() Macro</title>

<para>
In addition to the kludgey solution to the broken line problem
described above, there is a clean solution. The DEBUGADD() macro never
generates a header. It will append new text to the current debug
message even if the format buffer is empty. The syntax of the
DEBUGADD() macro is the same as that of the DEBUG() macro.
</para>

<para><programlisting>
    DEBUG( 0, ("This is the first line.\n" ) );
    DEBUGADD( 0, ("This is the second line.\nThis is the third line.\n" ) );
</programlisting></para>

<para>Produces</para>

<para><programlisting>
    [1998/07/30 16:00:51, 0] file.c:function(512)
      This is the first line.
      This is the second line.
      This is the third line.
</programlisting></para>

</sect1>

<sect1>
<title>The DEBUGLVL() Macro</title>

<para>
One of the problems with the DEBUG() macro was that DEBUG() lines
tended to get a bit long. Consider this example from
nmbd_sendannounce.c:
</para>

<para><programlisting>
  DEBUG(3,("send_local_master_announcement: type %x for name %s on subnet %s for workgroup %s\n",
            type, global_myname, subrec->subnet_name, work->work_group));
</programlisting></para>

<para>
One solution to this is to break it down using DEBUG() and DEBUGADD(),
as follows:
</para>

<para><programlisting>
  DEBUG( 3, ( "send_local_master_announcement: " ) );
  DEBUGADD( 3, ( "type %x for name %s ", type, global_myname ) );
  DEBUGADD( 3, ( "on subnet %s ", subrec->subnet_name ) );
  DEBUGADD( 3, ( "for workgroup %s\n", work->work_group ) );
</programlisting></para>

<para>
A similar, but arguably nicer approach is to use the DEBUGLVL() macro.
This macro returns True if the message level is less than or equal to
the global DEBUGLEVEL value, so:
</para>

<para><programlisting>
  if( DEBUGLVL( 3 ) )
    {
    dbgtext( "send_local_master_announcement: " );
    dbgtext( "type %x for name %s ", type, global_myname );
    dbgtext( "on subnet %s ", subrec->subnet_name );
    dbgtext( "for workgroup %s\n", work->work_group );
    }
</programlisting></para>

<para>(The dbgtext() function is explained below.)</para>

<para>There are a few advantages to this scheme:</para>
<orderedlist>
<listitem><para>
The test is performed only once.
</para></listitem>
<listitem><para>
You can allocate variables off of the stack that will only be used
within the DEBUGLVL() block.
</para></listitem>
<listitem><para>
Processing that is only relevant to debug output can be contained
within the DEBUGLVL() block.
</para></listitem>
</orderedlist>

</sect1>

<sect1>
<title>New Functions</title>

<sect2>
<title>dbgtext()</title>
<para>
This function prints debug message text to the debug file (and
possibly to syslog) via the format buffer. The function uses a
variable argument list just like printf() or Debug1(). The
input is printed into a buffer using the vslprintf() function,
and then passed to format_debug_text().

If you use DEBUGLVL() you will probably print the body of the
message using dbgtext(). 
</para>
</sect2>

<sect2>
<title>dbghdr()</title>
<para>
This is the function that writes a debug message header.
Headers are not processed via the format buffer. Also note that
if the format buffer is not empty, a call to dbghdr() will not
produce any output. See the comments in dbghdr() for more info.
</para>

<para>
It is not likely that this function will be called directly. It
is used by DEBUG() and DEBUGADD().
</para>
</sect2>

<sect2>
<title>format_debug_text()</title>
<para>
This is a static function in debug.c. It stores the output text
for the body of the message in a buffer until it encounters a
newline. When the newline character is found, the buffer is
written to the debug file via the Debug1() function, and the
buffer is reset. This allows us to add the indentation at the
beginning of each line of the message body, and also ensures
that the output is written a line at a time (which cleans up
syslog output).
</para>
</sect2>
</sect1>
</chapter>
