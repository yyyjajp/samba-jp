<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="devprinting">
<chapterinfo>
	<author>
		<firstname>Gerald</firstname><surname>Carter</surname>
	</author>
	<pubdate>October 2002</pubdate>
</chapterinfo>


<title>Samba印刷機能の詳細</title>


<sect1>
<title>概要</title>
<para>
この文書の目的は、いくつかのSambaの印刷機能についての概要を提供することと、
Windowsクライアントの印刷の特定の機能についての説明を行うことである。
</para>
</sect1>



<sect1>
<title>
種々のバックエンドに対する印刷インタフェース
</title>

<para>
Sambaは7つの機能に対する関数ポインタテーブルを使う。関数のプロトタイプは
<filename>printing.h</filename>中で記述される<varname>printif</varname>構造体中で
定義されている。
</para>

<itemizedlist>
	<listitem><para>retrieve the contents of a print queue</para></listitem>
	<listitem><para>pause the print queue</para></listitem>
	<listitem><para>resume a paused print queue</para></listitem>
	<listitem><para>delete a job from the queue</para></listitem>
	<listitem><para>pause a job in the print queue</para></listitem>
	<listitem><para>result a paused print job in the queue</para></listitem>
	<listitem><para>submit a job to the print queue</para></listitem>
</itemizedlist>

<para>
現在、2つの印刷バックエンドの実装のみが定義されている。
</para>

<itemizedlist>
	<listitem><para>標準UNIX印刷サブシステムと共に動作するための汎用的な機能セット
	</para></listitem>

	<listitem><para>CUPS固有の機能セット(これはCUPSライブラリがコンパイル時に存在
	    する場合にのみ有効となる)。</para></listitem>
</itemizedlist>

</sect1>




<sect1>
<title>
印刷キューTDB
</title>


<para>
Sambaはパフォーマンス向上のために、"lpq command"からの出力を定期的にキャッシュする
機能を提供する。このキャッシュ時間は秒単位で設定可能である。明らかに、キャッシュ時間が
より長いと、それだけsmbdはlpqへのコピーを行う回数が減る。しかし、クライアントに見せる
印刷キューの内容の正確さは、減少するだろう。
</para>

<para>
現在オープンしている印刷キューTDBのリストは、tdb_print_db structuresのリストを
調べることによって見つけることが出来る(printing.c中のprint_db_head参照)。1つのキュー
TDBはラッパー関数printing.c:get_print_db_byname()を使うことによってオープンされる。
関数は、すべての有効なファイルディスクリプタを使い果たしてしまうことから、大きな
印刷サーバを防ぐための効果がある、MAX_PRINT_DBS_OPENよりも数多く開かない事をsmbdに
行わせる。もしもキューTDBのオープン数がMAX_PRINT_DBS_OPENの制限を超過した場合、
smbdはオープンTDBのリストを管理するためMRU(most recently used)アルゴリズムを使う。
</para>

<para>
印刷ジョブを印刷キューTDB中に投入できるための2つの方法がある。最初のものはTDB中に
ジョブ情報を直接挿入するWindowsクライアントからジョブを投入する方法である。2番目の
方法は存在している"lpq command"を実行することで、印刷ジョブをピックアップする方法である。
</para>

<para><programlisting>
/* included from printing.h */
struct printjob {
	pid_t pid; /* which process launched the job */
	int sysjob; /* the system (lp) job number */
	int fd; /* file descriptor of open file if open */
	time_t starttime; /* when the job started spooling */
	int status; /* the status of this job */
	size_t size; /* the size of the job so far */
	int page_count;	/* then number of pages so far */
	BOOL spooled; /* has it been sent to the spooler yet? */
	BOOL smbjob; /* set if the job is a SMB job */
	fstring filename; /* the filename used to spool the file */
	fstring jobname; /* the job name given to us by the client */
	fstring user; /* the user who started the job */
	fstring queuename; /* service number of printer for this job */
	NT_DEVICEMODE *nt_devmode;
};
</programlisting></para>

<para>
printjob 構造体の現在の状態には、"lpq command"から戻されるUNIXジョブIDと、
Windows ジョブID(PRINT_MAX_JOBIDによって32ビットごとに区切られる)
のためのフィールドが含まれている。印刷ジョブが、キューTDB中に存在するジョブに
一致しない"lpq command"によって戻された場合、上記の32ビットジョブID
&lt;*vance doesn't know what word is missing here*&gt;がlpqによって報告される
ID用にUNIX_JOB_STARTを追加して生成される。
</para>

<para>
32ビットWindowsジョブIDを16ビットlanman印刷ジョブIDに一致させるために、smbdは
古いlanmanクライアントのために、前半部分の適切な数値を一致させるためのメモリTDBを使う。
</para>

<para>
印刷キューを更新する時、smbdは以下の手順を実行する
(<filename>print.c:print_queue_update()</filename>を参照):
</para>

<orderedlist>
	<listitem><para>もしも、他のsmbdが現在キューの内容を更新中かどうかを、
	    <constant>LOCK/<replaceable>printer_name</replaceable></constant>に
	    格納されているpidをチェックすることで調べる。もしもそうであれば、
	    TDBの更新をしない。</para></listitem>
	
	<listitem><para>TDB中のmutexエントリをロックし、今のプロセス固有のpidを格納する。
	    それがうまくいったかを調べ、そうでなければ失敗する。</para></listitem>

	<listitem><para>新しいキャッシュ内容の表示のために、更新したタイムスタンプを
	    格納する。</para></listitem>

	<listitem><para>"lpq command"経由でキューの一覧を検索する。</para></listitem>

	<listitem><para><programlisting>
	foreach job in the queue
     	{
		ジョブがUNIXジョブならば、新しいエントリを作成する;
		ジョブがWindowsベースのジョブIDを持つならば、
		{
			ジョブIDでレコードを検索する;
			もしも検索が失敗したら
				それをUNIXジョブとして扱う;
			そうでなければ
				ジョブステータスのみを更新する
		}
	}</programlisting></para></listitem>

	<listitem><para>lpqの一覧中に無い、TDB中のジョブを削除する。</para></listitem>

	<listitem><para>TDB中に印刷キューステータスを格納する。</para></listitem>
	
	<listitem><para>再度キャッシュされたタイムスタンプを更新する。</para></listitem>
	
</orderedlist>

<para>
これは、Windowsクライアントに返されるTDBの内容であり、"lpq command"からの実際の一覧とは
違うことに注意。
</para>

<para>
printjob構造体の一部として格納されるNT_DEVICEMODEは、印刷ジョブに関連づけられる
非標準のDeviceModeへのポインタを格納するのに使われる。ポインタは、クライアントが
OpenPrinterEx()呼び出し中でDevice Modeを含める時にnull以外になり、その同じハンドルで
印刷のために引き続いてジョブを投入する。もしもクライアントがOpenPrinterEx()要求に
対してDevice Modeを含めないのであれば、nt_devmodeフィールドはNULLであり、ジョブは
既定値で、それに関連づけられるプリンタのデバイスモードを持つ。
</para>

<para>
非標準のDevice Modeのみが印刷キューTDB中にプリントジョブと一緒に格納される。それ以外は、
Device Modeは、クライアントがGetJob(level == 2)要求を発行した時、プリンタオブジェクト
から得られたものである。
</para>

</sect1>




<sect1>
<title>
ChangeIDとプリンタ情報のキャッシング
</title>

<para>
[後日作成]
</para>
</sect1>



<sect1>
<title>
Windows NT/2K におけるPrinter Change Notify
</title>

<para>
Windows NT+クライアントで動作している場合、プリンタサーバに対してRPCを使って、
クライアントに、特定のプリンタと印刷ジョブ属性の、非同期な変更通知イベント
を送ることが出来る。これは、クライアントが指定したプリンタに対して新しいジョブが
キューに追加されたことか、プリンタのドライバが変更されたかを知る必要がある時に
便利である。これは、プリンタオブジェクトのなめの新しいChangeID上をベースとした
キャッシュ更新とは完全に無関係に行われることに注意。
</para>

<para>
変更通知を実装するために使われる基本的なRPCの使用範囲は以下の通り
</para>

<itemizedlist>
	<listitem><para>RemoteFindFirstPrinterChangeNotifyEx ( RFFPCN )</para></listitem>
	<listitem><para>RemoteFindNextPrinterChangeNotifyEx ( RFNPCN )</para></listitem>
	<listitem><para>FindClosePrinterChangeNotify( FCPCN )</para></listitem>
	<listitem><para>ReplyOpenPrinter</para></listitem>
	<listitem><para>ReplyClosePrinter</para></listitem>
	<listitem><para>RouteRefreshPrinterChangeNotify ( RRPCN )</para></listitem>
</itemizedlist>

<para>
One additional RPC is available to a server, but is never used by the
Windows spooler service:
</para>

<itemizedlist>
	<listitem><para>RouteReplyPrinter()</para></listitem>
</itemizedlist>

<para>
The opnum for all of these RPC's are defined in include/rpc_spoolss.h
</para>

<para>
Windows NT print servers use a bizarre method of sending print
notification event to clients.  The process of registering a new change
notification handle is as follows.  The 'C' is for client and the
'S' is for server.  All error conditions have been eliminated.
</para>

<para><programlisting>
C:	Obtain handle to printer or to the printer
	server via the standard OpenPrinterEx() call.
S:	Respond with a valid handle to object

C:	Send a RFFPCN request with the previously obtained
	handle with either (a) set of flags for change events
	to monitor, or (b) a PRINTER_NOTIFY_OPTIONS structure
	containing the event information to monitor.  The windows
	spooler has only been observed to use (b).
S:	The &lt;* another missing word*&gt; opens a new TCP session to the client (thus requiring
	all print clients to be CIFS servers as well) and sends
	a ReplyOpenPrinter() request to the client.
C:	The client responds with a printer handle that can be used to
	send event notification messages.
S:	The server replies success to the RFFPCN request.

C:	The windows spooler follows the RFFPCN with a RFNPCN
	request to fetch the current values of all monitored
	attributes.
S:	The server replies with an array SPOOL_NOTIFY_INFO_DATA
	structures (contained in a SPOOL_NOTIFY_INFO structure).

C:	If the change notification handle is ever released by the
	client via a FCPCN request, the server sends a ReplyClosePrinter()
	request back to the client first.  However a request of this
	nature from the client is often an indication that the previous
	notification event was not marshalled correctly by the server
	or a piece of data was wrong.
S:	The server closes the internal change notification handle
	(POLICY_HND) and does not send any further change notification
	events to the client for that printer or job.
</programlisting></para>

<para>
The current list of notification events supported by Samba can be
found by examining the internal tables in srv_spoolss_nt.c
</para>

<itemizedlist>
	<listitem><para>printer_notify_table[]</para></listitem>
	<listitem><para>job_notify_table[]</para></listitem>
</itemizedlist>

<para>
When an event occurs that could be monitored, smbd sends a message
to itself about the change.  The list of events to be transmitted
are queued by the smbd process sending the message to prevent an
overload of TDB usage and the internal message is sent during smbd's
idle loop (refer to printing/notify.c and the functions
send_spoolss_notify2_msg() and print_notify_send_messages() ).
</para>

<para>
The decision of whether or not the change is to be sent to connected
clients is made by the routine which actually sends the notification.
( refer to srv_spoolss_nt.c:recieve_notify2_message() ).
</para>

<para>
Because it possible to receive a listing of multiple changes for
multiple printers, the notification events must be split into
categories by the printer name.  This makes it possible to group
multiple change events to be sent in a single RPC according to the
printer handle obtained via a ReplyOpenPrinter().
</para>

<para>
The actual change notification is performed using the RRPCN request
RPC.  This packet contains
</para>


<itemizedlist>
	
<listitem><para>the printer handle registered with the
client's spooler on which the change occurred</para></listitem>

<listitem><para>The change_low value which was sent as part
of the last RFNPCN request from the client</para></listitem>

<listitem><para>The SPOOL_NOTIFY_INFO container with the event
information</para></listitem>

</itemizedlist>

<para>
A <varname>SPOOL_NOTIFY_INFO</varname> contains:
</para>

<itemizedlist>

<listitem><para>the version and flags field are predefined
and should not be changed</para></listitem>

<listitem><para>The count field is the number of entries
in the SPOOL_NOTIFY_INFO_DATA array</para></listitem>

</itemizedlist>

<para>
The <varname>SPOOL_NOTIFY_INFO_DATA</varname> entries contain:
</para>

<itemizedlist>

<listitem><para>The type defines whether or not this event
is for a printer or a print job</para></listitem>

<listitem><para>The field is the flag identifying the event</para></listitem>

<listitem><para>the notify_data union contains the new valuie of the
attribute</para></listitem>

<listitem><para>The enc_type defines the size of the structure for marshalling
and unmarshalling</para></listitem>

<listitem><para>(a) the id must be 0 for a printer event on a printer handle.
(b) the id must be the job id for an event on a printer job
(c) the id must be the matching number of the printer index used
in the response packet to the RFNPCN when using a print server
handle for notification.  Samba currently uses the snum of
the printer for this which can break if the list of services
has been modified since the notification handle was registered.</para></listitem>

<listitem><para>The size is either (a) the string length in UNICODE for strings,
(b) the size in bytes of the security descriptor, or (c) 0 for
data values.</para></listitem>

</itemizedlist>

</sect1>
</chapter>
