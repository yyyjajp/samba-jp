<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="unix-smb">
<chapterinfo>
	<author>
		<firstname>Andrew</firstname><surname>Tridgell</surname>
	</author>
	<pubdate>April 1995</pubdate>
</chapterinfo>

<title>UNIX領域におけるNetBIOS</title>

<sect1>
<title>概要</title>
<para>
これは、UNIX上でのSMB実装で直面するいくつかの問題について記述し、Sambaがどのように
それらを実装したかを説明した短い文書である。これらはUNIX&lt;-&gt;PC間の相互運用を
調べる人の手助けになるかもしれない。
</para>

<para>
PCへの接続機能を、UNIX上で実装している人の手助けとなるように書かれた。
</para>

</sect1>

<sect1>
<title>ユーザ名</title>
<para>
SMBプロトコルはおおざっぱなユーザ名の概念しか持っていない。初期のSMBプロトコル
(たとえばCOREとCOREPLUS)では、まったくユーザ名の概念がなかった。そのあとの
プロトコルでもクライアントはしばしば(特にプリンタの操作において)、サーバ上で
最初にユーザ名を検証しないで運用をしていた。
</para>

<para>
UNIXのセキュリティは、ユーザ名/パスワードペアを基本としている。UNIXマシンは
ある種の認証なしには、どのような実質的な操作もクライアントには許可しない。
</para>

<para>
UNIXサーバが"共有レベル"でのセキュリティモードになっていたときに、主に問題が
発生する。これは多くのサイトで不評である、各接続済の共有に対して同じユーザとして
クライアントがサーバに接続する事を通常強制する、"ユーザレベル"セキュリティモードの
代替となる既定値のモードである。
</para>

<para>
"共有レベル"セキュリティでは、クライアントは通常"session setup"プロトコル中に
おいて、ユーザ名を提供するが、対応するパスワードは提供しない。クライアントは
次に"tree connect"プロトコルを使ってリソースに接続し、パスワードを提供する。
問題は、PC上のユーザは異なった場面でユーザ名とパスワードを入力することであり、
サーバにアクセスする時に、両方を一緒にする必要があることを知らないということである。
ユーザ名は通常PCに"ログオン"するときに入力する(これはWindows for Workgroupを
仮定している)。パスワードはディスクやプリンタに接続するときに選択する。
</para>

<para>
ユーザは、しばしばドライブの接続のためのログオンに、全く異なったユーザ名を選ぶ。
しばしば、異なったドライブに異なったユーザ名でアクセスすることも望む。UNIX
サーバは各パスワードに結びつけるための正しいユーザ名を何らかの方法で見極める
必要がある。
</para>

<para>
Sambaはこの問題をいくつかの方法を使って防ごうとする。それらは大変多くの場合、
成功する。その方法にはusername map、service%userという書式、後の認証のために
session setupのユーザ名を保持してサービス名からユーザ名を判断する(directoryか
user=オプション経由で)などがある。
</para>

</sect1>

<sect1>
<title>ファイルの所有権</title>

<para>
通常使われるSMBプロトコルは、"ファイルを所有していないのでその操作はできません"
という事を通知する方法を持っていない。要するに、全くファイルの所有権という概念が
ないのである。
</para>

<para>
これは、ある種の興味深い問題を引き起こす。たとえば、UNIXマシンにファイルをコピー
し、ファイルは誰でも書き込み可能(world writeable)だが、他のユーザで所有されている
場合、ファイルは正しく転送されるが、間違った日付を受け取ることになる。これは、
UNIX配下ではutime()システムコールは、たとえファイルがすべてのユーザに対して
書き込み可能だったとしても、ファイルの所有者かrootでのみ成功するという理由による。
セキュリティ上の理由により、Sambaはすべてのファイル操作を認証したユーザの権限で
行い、rootでは行わないので、utime()が失敗する。これは"make"のようなプログラムが
ファイルの時間を正しく取れないということで、共有された開発ディレクトリが不整合になる
可能性がある。
</para>

<para>
この問題に対するいくつかの解決方法があり、その中には、ユーザ名のマップと
特定の共有に対して特定のユーザ名を強制する方法などがある。
</para>

</sect1>

<sect1>
<title>パスワード</title>

<para>
多くのSMBクライアントは送信前にパスワードを大文字にする。なぜそうなっているかの理由は
知らない。興味深いことに、WfWgは、COREPLUSよりもレベルが高いプロトコルで動いている時のみ
パスワードを大文字にするので、データ入力ルーチンに責がないのは明白である。
</para>

<para>
UNIXパスワードは大文字小文字を認識する。そのため、もしもユーザが大文字小文字を混ぜた
パスワードを使う場合には問題が生じる。
</para>

<para>
Sambaは、大文字小文字を、指定された値まで変更しつつ、提供されたパスワードをSambaに
試行させる、"password level"オプションを使うか、他のマシン(通常Windows NTサーバ)
経由でこの検証をSambaに行わせることが出来る、"password server"オプションを使うことに
よって、対処することが出来る。
</para>

<para>
SambaはSMBクライアントによって提供されるパスワード暗号化方法をサポートする。
Microsoftネットワークにおける暗号化パスワードの使用は、"平文と同等の"
パスワードハッシュを提供することと同等であることに注意。これは、それらの
パスワードハッシュを含むSambaのsmbpasswdファイルは、rootのみ読み出し可能に
すべきであることが*とても重要*であることを意味する。詳細は
ENCRYPTION.txtを参照のこと。
</para>

</sect1>

<sect1>
<title>ファイルのロック</title>
<para>
Samba 2.2以降、Sambaは他のロック方法をうまくサポートしている。この節は
時代遅れである。
</para>

<para>
DOS/Windows環境におけるロック呼び出しはunix上でのものよりも機能が豊富である。これは、
SMBのロックを実装するために、fcntl()ベースの標準UNIXロック呼び出しを使うことを選択する
(Sambaのような)UNIXサーバは、多少間に合わせで作る必要があるということである。
The locking calls available under a DOS/Windows environment are much
richer than those available in unix. This means a unix server (like
Samba) choosing to use the standard fcntl() based unix locking calls
to implement SMB locking has to improvise a bit.
</para>

<para>
大きな1つの問題は、DOSのロックは32ビット(符号なし)の幅で行えると言うことである。
UNIXのロック呼び出しは32ビットだが、符号着きであり、31ビット幅しかない。
不幸にも、OLE2クライアントはOLEセマフォのためにロック幅を選択するためにトップ
ビットを使う。
</para>

<para>
この問題に対応するために、Sambaは、適切なビットシフト操作を行うことによって、
32ビット幅を31ビット幅に圧縮する。これは動作するように見えるが、理想的ではない。
将来のバージョンでは、この問題に対処するために、分離されたSMBロックが追加される
かもしれない。
</para>

<para>
多くのUNIXロックデーモンは結構バグがあり、些細なことによってクラッシュすることも
足を引っ張っている。通常、ごくわずかのUNIXプログラムしかバイトレンジロックを使わない
という理由で、UNIX環境では、これらは通常ほとんど使われない。DOS/Windowsからクライアント
からの非常に大量のロック要求の負荷は、ある種のシステムにおいてはデーモンを終了して
しまう。
</para>

<para>
2番目の大きな問題は、ある種のクライアントから要求される"便宜的ロック(opportunistic locking)"
である。もしもクライアントが便宜的ロックを要求した場合、同じファイル上に、他の誰かが
何らかの操作を行おうとしているならば、クライアントがそのロックを開放することを
告げる時、そのことを通知するためにサーバに要求する。UNIXは便宜的ロックを簡単に実装する
すべがなく、現在のSambaはそれをサポートしていない(訳注:古い)。
</para>

</sect1>

<sect1>
<title>拒否モード</title>

<para>
SMBクライアントがファイルをオープンするとき、ファイル上に設定されている特定の
"拒否モード"について問い合わせをする。それらのモード(DENY_NONE, DENY_READ, DENY_WRITE,
DENY_ALL, DENY_FCB と DENY_DOS)は、他の誰かが同じ時に同じファイルを使うときに許可
すべき動作を指定する。たとえば、もしもDENY_READがファイル上に設定されている場合、
読み取りのためのファイルへのオープン操作は失敗する。
</para>

<para>
UNIXは同等の概念を持っていない。これを実装するため、Sambaはファイルのinodeをベースとする
ファイルのロックと、ロックディレクトリを分離するか、あるいは、共有メモリ実装を使う。
ファイルロックによる方式は、あまりかっこよくなく、処理のコストがかかりファイルリソースを
消費するが、共有メモリ実装は非常に好ましく(訳注:preferedはミススペル)、それをサポートする
システムでは既定値で有効となっている。
</para>

</sect1>

<sect1>
<title>Trapdoor UID</title>
<para>
SMBセッションは、1つのソケット上でいくつかのUIDを使って動作することが出来る。これは、
ユーザが、異なったユーザ名で2つの共有に接続するときに起きる。これに対処するために、
UNIXサーバは1つのプロセス内でUIDを切り替える必要がある。ある種のUNIX(たとえばSCO)では、
このようなことが出来ない。これは、そのようなUNIXでは、クライアントは単一のUIDでの処理に
制限されることを意味する。
</para>

<para>
その他の理由により、"trapdoor uid"メッセージも受け取る事があり得ることに注意。
詳細はFAQを参照のこと。
</para>

</sect1>

<sect1>
<title>ポート番号</title>
<para>
ソケット上のクライアントは、ポート番号が大きな値(>1000)の"非特権"ポート番号を使い、
サーバへの接続は小さな値の"特権"ポートを使うという慣習がある。これは、UNIX上では、
1000よりも小さなポート番号上で、非rootなユーザが、リッスンのためにポートを
開けないようにさせている。
</para>

<para>
ほとんどのPCベースのSMBクライアント(たとえばWfWgとWinNT)はこの習慣を完全に守っていない。
主犯はUDPのポート137でのNetBIOSの名前解決である。名前問い合わせ要求はソースポート137
から来る。これは、小さな(低位の)ポート番号で入ってくるパケットを許可しないよくある
ファイアウォールの設定を使うときに問題になる。これは、それらクライアントは、低位の
ポートベースのファイアウォールの反対側にあるNetBIOSネームサーバに問い合わせできないことを
意味する。
</para>

<para>
The problem is more severe with netbios node status queries. I've
found that WfWg, Win95 and WinNT3.5 all respond to netbios node status
queries on port 137 no matter what the source port was in the
request. This works between machines that are both using port 137, but
it means it's not possible for a unix user to do a node status request
to any of these OSes unless they are running as root. The answer comes
back, but it goes to port 137 which the unix user can't listen
on. Interestingly WinNT3.1 got this right - it sends node status
responses back to the source port in the request.
</para>

</sect1>

<sect1>
<title>Protocol Complexity</title>
<para>
There are many "protocol levels" in the SMB protocol. It seems that
each time new functionality was added to a Microsoft operating system,
they added the equivalent functions in a new protocol level of the SMB
protocol to "externalise" the new capabilities.
</para>

<para>
This means the protocol is very "rich", offering many ways of doing
each file operation. This means SMB servers need to be complex and
large. It also means it is very difficult to make them bug free. It is
not just Samba that suffers from this problem, other servers such as
WinNT don't support every variation of every call and it has almost
certainly been a headache for MS developers to support the myriad of
SMB calls that are available.
</para>

<para>
There are about 65 "top level" operations in the SMB protocol (things
like SMBread and SMBwrite). Some of these include hundreds of
sub-functions (SMBtrans has at least 120 sub-functions, like
DosPrintQAdd and NetSessionEnum). All of them take several options
that can change the way they work. Many take dozens of possible
"information levels" that change the structures that need to be
returned. Samba supports all but 2 of the "top level" functions. It
supports only 8 (so far) of the SMBtrans sub-functions. Even NT
doesn't support them all.
</para>

<para>
Samba currently supports up to the "NT LM 0.12" protocol, which is the
one preferred by Win95 and WinNT3.5. Luckily this protocol level has a
"capabilities" field which specifies which super-duper new-fangled
options the server suports. This helps to make the implementation of
this protocol level much easier.
</para>

<para>
There is also a problem with the SMB specications. SMB is a X/Open
spec, but the X/Open book is far from ideal, and fails to cover many
important issues, leaving much to the imagination. Microsoft recently
renamed the SMB protocol CIFS (Common Internet File System) and have 
published new specifications. These are far superior to the old 
X/Open documents but there are still undocumented calls and features. 
This specification is actively being worked on by a CIFS developers 
mailing list hosted by Microsft.
</para>
</sect1>
</chapter>

