<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="unix-smb">
<chapterinfo>
	<author>
		<firstname>Andrew</firstname><surname>Tridgell</surname>
	</author>
	<pubdate>April 1995</pubdate>
</chapterinfo>

<title>UNIX領域におけるNetBIOS</title>

<sect1>
<title>概要</title>
<para>
これは、UNIX上でのSMB実装で直面するいくつかの問題について記述し、Sambaがどのように
それらを実装したかを説明した短い文書である。これらはUNIX&lt;-&gt;PC間の相互運用を
調べる人の手助けになるかもしれない。
</para>

<para>
PCへの接続機能を、UNIX上で実装している人の手助けとなるように書かれた。
</para>

</sect1>

<sect1>
<title>ユーザ名</title>
<para>
SMBプロトコルはおおざっぱなユーザ名の概念しか持っていない。初期のSMBプロトコル
(たとえばCOREとCOREPLUS)では、まったくユーザ名の概念がなかった。そのあとの
プロトコルでもクライアントはしばしば(特にプリンタの操作において)、サーバ上で
最初にユーザ名を検証しないで運用をしていた。
</para>

<para>
UNIXのセキュリティは、ユーザ名/パスワードペアを基本としている。UNIXマシンは
ある種の認証なしには、どのような実質的な操作もクライアントには許可しない。
</para>

<para>
UNIXサーバが"共有レベル"でのセキュリティモードになっていたときに、主に問題が
発生する。これは多くのサイトで不評である、各接続済の共有に対して同じユーザとして
クライアントがサーバに接続する事を通常強制する、"ユーザレベル"セキュリティモードの
代替となる既定値のモードである。
</para>

<para>
"共有レベル"セキュリティでは、クライアントは通常"session setup"プロトコル中に
おいて、ユーザ名を提供するが、対応するパスワードは提供しない。クライアントは
次に"tree connect"プロトコルを使ってリソースに接続し、パスワードを提供する。
問題は、PC上のユーザは異なった場面でユーザ名とパスワードを入力することであり、
サーバにアクセスする時に、両方を一緒にする必要があることを知らないということである。
ユーザ名は通常PCに"ログオン"するときに入力する(これはWindows for Workgroupを
仮定している)。パスワードはディスクやプリンタに接続するときに選択する。
</para>

<para>
ユーザは、しばしばドライブの接続のためのログオンに、全く異なったユーザ名を選ぶ。
しばしば、異なったドライブに異なったユーザ名でアクセスすることも望む。UNIX
サーバは各パスワードに結びつけるための正しいユーザ名を何らかの方法で見極める
必要がある。
</para>

<para>
Sambaはこの問題をいくつかの方法を使って防ごうとする。それらは大変多くの場合、
成功する。その方法にはusername map、service%userという書式、後の認証のために
session setupのユーザ名を保持してサービス名からユーザ名を判断する(directoryか
user=オプション経由で)などがある。
</para>

</sect1>

<sect1>
<title>ファイルの所有権</title>

<para>
通常使われるSMBプロトコルは、"ファイルを所有していないのでその操作はできません"
という事を通知する方法を持っていない。要するに、全くファイルの所有権という概念が
ないのである。
</para>

<para>
これは、ある種の興味深い問題を引き起こす。たとえば、UNIXマシンにファイルをコピー
し、ファイルは誰でも書き込み可能(world writeable)だが、他のユーザで所有されている
場合、ファイルは正しく転送されるが、間違った日付を受け取ることになる。これは、
UNIX配下ではutime()システムコールは、たとえファイルがすべてのユーザに対して
書き込み可能だったとしても、ファイルの所有者かrootでのみ成功するという理由による。
セキュリティ上の理由により、Sambaはすべてのファイル操作を認証したユーザの権限で
行い、rootでは行わないので、utime()が失敗する。これは"make"のようなプログラムが
ファイルの時間を正しく取れないということで、共有された開発ディレクトリが不整合になる
可能性がある。
</para>

<para>
この問題に対するいくつかの解決方法があり、その中には、ユーザ名のマップと
特定の共有に対して特定のユーザ名を強制する方法などがある。
</para>

</sect1>

<sect1>
<title>パスワード</title>

<para>
Many SMB clients uppercase passwords before sending them. I have no
idea why they do this. Interestingly WfWg uppercases the password only
if the server is running a protocol greater than COREPLUS, so
obviously it isn't just the data entry routines that are to blame.
</para>

<para>
Unix passwords are case sensitive. So if users use mixed case
passwords they are in trouble.
</para>

<para>
Samba can try to cope with this by either using the "password level"
option which causes Samba to try the offered password with up to the
specified number of case changes, or by using the "password server"
option which allows Samba to do its validation via another machine
(typically a WinNT server).
</para>

<para>
Samba supports the password encryption method used by SMB
clients. Note that the use of password encryption in Microsoft
networking leads to password hashes that are "plain text equivalent".
This means that it is *VERY* important to ensure that the Samba
smbpasswd file containing these password hashes is only readable
by the root user. See the documentation ENCRYPTION.txt for more
details.
</para>

</sect1>

<sect1>
<title>Locking</title>
<para>
Since samba 2.2, samba supports other types of locking as well. This 
section is outdated.
</para>

<para>
The locking calls available under a DOS/Windows environment are much
richer than those available in unix. This means a unix server (like
Samba) choosing to use the standard fcntl() based unix locking calls
to implement SMB locking has to improvise a bit.
</para>

<para>
One major problem is that dos locks can be in a 32 bit (unsigned)
range. Unix locking calls are 32 bits, but are signed, giving only a 31
bit range. Unfortunately OLE2 clients use the top bit to select a
locking range used for OLE semaphores.
</para>

<para>
To work around this problem Samba compresses the 32 bit range into 31
bits by appropriate bit shifting. This seems to work but is not
ideal. In a future version a separate SMB lockd may be added to cope
with the problem.
</para>

<para>
It also doesn't help that many unix lockd daemons are very buggy and
crash at the slightest provocation. They normally go mostly unused in
a unix environment because few unix programs use byte range
locking. The stress of huge numbers of lock requests from dos/windows
clients can kill the daemon on some systems.
</para>

<para>
The second major problem is the "opportunistic locking" requested by
some clients. If a client requests opportunistic locking then it is
asking the server to notify it if anyone else tries to do something on
the same file, at which time the client will say if it is willing to
give up its lock. Unix has no simple way of implementing
opportunistic locking, and currently Samba has no support for it.
</para>

</sect1>

<sect1>
<title>Deny Modes</title>

<para>
When a SMB client opens a file it asks for a particular "deny mode" to
be placed on the file. These modes (DENY_NONE, DENY_READ, DENY_WRITE,
DENY_ALL, DENY_FCB and DENY_DOS) specify what actions should be
allowed by anyone else who tries to use the file at the same time. If
DENY_READ is placed on the file, for example, then any attempt to open
the file for reading should fail.
</para>

<para>
Unix has no equivalent notion. To implement this Samba uses either lock
files based on the files inode and placed in a separate lock
directory or a shared memory implementation. The lock file method 
is clumsy and consumes processing and file resources,
the shared memory implementation is vastly prefered and is turned on
by default for those systems that support it.
</para>

</sect1>

<sect1>
<title>Trapdoor UIDs</title>
<para>
A SMB session can run with several uids on the one socket. This
happens when a user connects to two shares with different
usernames. To cope with this the unix server needs to switch uids
within the one process. On some unixes (such as SCO) this is not
possible. This means that on those unixes the client is restricted to
a single uid.
</para>

<para>
Note that you can also get the "trapdoor uid" message for other
reasons. Please see the FAQ for details.
</para>

</sect1>

<sect1>
<title>Port numbers</title>
<para>
There is a convention that clients on sockets use high "unprivileged"
port numbers (>1000) and connect to servers on low "privilegedg" port
numbers. This is enforced in Unix as non-root users can't open a
socket for listening on port numbers less than 1000.
</para>

<para>
Most PC based SMB clients (such as WfWg and WinNT) don't follow this
convention completely. The main culprit is the netbios nameserving on
udp port 137. Name query requests come from a source port of 137. This
is a problem when you combine it with the common firewalling technique
of not allowing incoming packets on low port numbers. This means that
these clients can't query a netbios nameserver on the other side of a
low port based firewall.
</para>

<para>
The problem is more severe with netbios node status queries. I've
found that WfWg, Win95 and WinNT3.5 all respond to netbios node status
queries on port 137 no matter what the source port was in the
request. This works between machines that are both using port 137, but
it means it's not possible for a unix user to do a node status request
to any of these OSes unless they are running as root. The answer comes
back, but it goes to port 137 which the unix user can't listen
on. Interestingly WinNT3.1 got this right - it sends node status
responses back to the source port in the request.
</para>

</sect1>

<sect1>
<title>Protocol Complexity</title>
<para>
There are many "protocol levels" in the SMB protocol. It seems that
each time new functionality was added to a Microsoft operating system,
they added the equivalent functions in a new protocol level of the SMB
protocol to "externalise" the new capabilities.
</para>

<para>
This means the protocol is very "rich", offering many ways of doing
each file operation. This means SMB servers need to be complex and
large. It also means it is very difficult to make them bug free. It is
not just Samba that suffers from this problem, other servers such as
WinNT don't support every variation of every call and it has almost
certainly been a headache for MS developers to support the myriad of
SMB calls that are available.
</para>

<para>
There are about 65 "top level" operations in the SMB protocol (things
like SMBread and SMBwrite). Some of these include hundreds of
sub-functions (SMBtrans has at least 120 sub-functions, like
DosPrintQAdd and NetSessionEnum). All of them take several options
that can change the way they work. Many take dozens of possible
"information levels" that change the structures that need to be
returned. Samba supports all but 2 of the "top level" functions. It
supports only 8 (so far) of the SMBtrans sub-functions. Even NT
doesn't support them all.
</para>

<para>
Samba currently supports up to the "NT LM 0.12" protocol, which is the
one preferred by Win95 and WinNT3.5. Luckily this protocol level has a
"capabilities" field which specifies which super-duper new-fangled
options the server suports. This helps to make the implementation of
this protocol level much easier.
</para>

<para>
There is also a problem with the SMB specications. SMB is a X/Open
spec, but the X/Open book is far from ideal, and fails to cover many
important issues, leaving much to the imagination. Microsoft recently
renamed the SMB protocol CIFS (Common Internet File System) and have 
published new specifications. These are far superior to the old 
X/Open documents but there are still undocumented calls and features. 
This specification is actively being worked on by a CIFS developers 
mailing list hosted by Microsft.
</para>
</sect1>
</chapter>

